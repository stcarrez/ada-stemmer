--  Generated by Snowball 2.0.0 - https://snowballstem.org/

package body Stemmer.Finnish is

   pragma Style_Checks ("-mr");
   pragma Warnings (Off, "*variable*is never read and never assigned*");
   pragma Warnings (Off, "*mode could be*instead of*");
   pragma Warnings (Off, "*formal parameter.*is not modified*");
   pragma Warnings (Off, "*this line is too long*");
   pragma Warnings (Off, "*is not referenced*");

   procedure R_Tidy (Z : in out Context_Type; Result : out Boolean);
   procedure R_Other_endings (Z : in out Context_Type; Result : out Boolean);
   procedure R_T_plural (Z : in out Context_Type; Result : out Boolean);
   procedure R_I_plural (Z : in out Context_Type; Result : out Boolean);
   procedure R_Case_ending (Z : in out Context_Type; Result : out Boolean);
   procedure R_VI (Z : in out Context_Type; Result : out Boolean);
   procedure R_LONG (Z : in out Context_Type; Result : out Boolean);
   procedure R_Possessive (Z : in out Context_Type; Result : out Boolean);
   procedure R_Particle_etc (Z : in out Context_Type; Result : out Boolean);
   procedure R_R2 (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean);

   procedure Among_Handler (Context : in out Stemmer.Context_Type'Class; Operation : in Operation_Index; Result : out Boolean);

   G_AEI : constant Grouping_Array (0 .. 135) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, True, False, False, False, False
   );

   G_C : constant Grouping_Array (0 .. 31) := (
      True, True, True, False, True, True, True, False,
      True, True, True, True, True, False, True, True,
      True, True, True, False, True, True, True, False,
      True, False, False, False, False, False, False, False
   );

   G_V1 : constant Grouping_Array (0 .. 151) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      True, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, True, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, True, False, False
   );

   G_V2 : constant Grouping_Array (0 .. 151) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, True, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, True, False, False
   );

   G_Particle_end : constant Grouping_Array (0 .. 151) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, True, True, False,
      False, False, False, True, True, False, False, False,
      True, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, True, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, True, False, False
   );
   Among_String : constant String := "pa" & "sti" & "kaan" & "han" & "kin"
      & "hän" & "kään" & "ko" & "pä" & "kö" & "lla" & "na" & "ssa" & "ta" & "lta"
      & "sta" & "llä" & "nä" & "ssä" & "tä" & "ltä" & "stä" & "lle" & "ine"
      & "nsa" & "mme" & "nne" & "ni" & "si" & "an" & "en" & "än" & "nsä" & "aa"
      & "ee" & "ii" & "oo" & "uu" & "ää" & "öö" & "a" & "lla" & "na" & "ssa" & "ta"
      & "lta" & "sta" & "tta" & "lle" & "ine" & "ksi" & "n" & "han" & "den" & "seen"
      & "hen" & "tten" & "hin" & "siin" & "hon" & "hän" & "hön" & "ä" & "llä"
      & "nä" & "ssä" & "tä" & "ltä" & "stä" & "ttä" & "eja" & "mma" & "imma"
      & "mpa" & "impa" & "mmi" & "immi" & "mpi" & "impi" & "ejä" & "mmä" & "immä"
      & "mpä" & "impä" & "i" & "j" & "mma" & "imma";

   A_0 : constant Among_Array_Type (0 .. 9) := (
      (1, 2, -1, 1, 0),
      (3, 5, -1, 2, 0),
      (6, 9, -1, 1, 0),
      (10, 12, -1, 1, 0),
      (13, 15, -1, 1, 0),
      (16, 19, -1, 1, 0),
      (20, 25, -1, 1, 0),
      (26, 27, -1, 1, 0),
      (28, 30, -1, 1, 0),
      (31, 33, -1, 1, 0));

   A_1 : constant Among_Array_Type (0 .. 5) := (
      (34, 36, -1, -1, 0),
      (37, 38, -1, -1, 0),
      (39, 41, -1, -1, 0),
      (42, 43, -1, -1, 0),
      (44, 46, 3, -1, 0),
      (47, 49, 3, -1, 0));

   A_2 : constant Among_Array_Type (0 .. 5) := (
      (50, 53, -1, -1, 0),
      (54, 56, -1, -1, 0),
      (57, 60, -1, -1, 0),
      (61, 63, -1, -1, 0),
      (64, 67, 3, -1, 0),
      (68, 71, 3, -1, 0));

   A_3 : constant Among_Array_Type (0 .. 1) := (
      (72, 74, -1, -1, 0),
      (75, 77, -1, -1, 0));

   A_4 : constant Among_Array_Type (0 .. 8) := (
      (78, 80, -1, 3, 0),
      (81, 83, -1, 3, 0),
      (84, 86, -1, 3, 0),
      (87, 88, -1, 2, 0),
      (89, 90, -1, 1, 0),
      (91, 92, -1, 4, 0),
      (93, 94, -1, 6, 0),
      (95, 97, -1, 5, 0),
      (98, 101, -1, 3, 0));

   A_5 : constant Among_Array_Type (0 .. 6) := (
      (102, 103, -1, -1, 0),
      (104, 105, -1, -1, 0),
      (106, 107, -1, -1, 0),
      (108, 109, -1, -1, 0),
      (110, 111, -1, -1, 0),
      (112, 115, -1, -1, 0),
      (116, 119, -1, -1, 0));

   A_6 : constant Among_Array_Type (0 .. 29) := (
      (120, 120, -1, 8, 0),
      (121, 123, 0, -1, 0),
      (124, 125, 0, -1, 0),
      (126, 128, 0, -1, 0),
      (129, 130, 0, -1, 0),
      (131, 133, 4, -1, 0),
      (134, 136, 4, -1, 0),
      (137, 139, 4, 2, 0),
      (140, 142, -1, -1, 0),
      (143, 145, -1, -1, 0),
      (146, 148, -1, -1, 0),
      (149, 149, -1, 7, 0),
      (150, 152, 11, 1, 0),
      (153, 155, 11, -1, 1),
      (156, 159, 11, -1, 2),
      (160, 162, 11, 2, 0),
      (163, 166, 11, -1, 3),
      (167, 169, 11, 3, 0),
      (170, 173, 11, -1, 4),
      (174, 176, 11, 4, 0),
      (177, 180, 11, 5, 0),
      (181, 184, 11, 6, 0),
      (185, 186, -1, 8, 0),
      (187, 190, 22, -1, 0),
      (191, 193, 22, -1, 0),
      (194, 197, 22, -1, 0),
      (198, 200, 22, -1, 0),
      (201, 204, 26, -1, 0),
      (205, 208, 26, -1, 0),
      (209, 212, 26, 2, 0));

   A_7 : constant Among_Array_Type (0 .. 13) := (
      (213, 215, -1, -1, 0),
      (216, 218, -1, 1, 0),
      (219, 222, 1, -1, 0),
      (223, 225, -1, 1, 0),
      (226, 229, 3, -1, 0),
      (230, 232, -1, 1, 0),
      (233, 236, 5, -1, 0),
      (237, 239, -1, 1, 0),
      (240, 243, 7, -1, 0),
      (244, 247, -1, -1, 0),
      (248, 251, -1, 1, 0),
      (252, 256, 10, -1, 0),
      (257, 260, -1, 1, 0),
      (261, 265, 12, -1, 0));

   A_8 : constant Among_Array_Type (0 .. 1) := (
      (266, 266, -1, -1, 0),
      (267, 267, -1, -1, 0));

   A_9 : constant Among_Array_Type (0 .. 1) := (
      (268, 270, -1, 1, 0),
      (271, 274, 0, -1, 0));


   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 42
      Z.I_P1 := Z.L;
      Z.I_P2 := Z.L;
            --  goto, line 47
      Out_Grouping (Z, G_V1, 97, 246, True, C);      if C < 0 then
         Result := False;
         return;
      end if;
            --  gopast, line 47
      --  non V1, line 47
      In_Grouping (Z, G_V1, 97, 246, True, C);
      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C + C;
      --  setmark p1, line 47
      Z.I_P1 := Z.C;
            --  goto, line 48
      Out_Grouping (Z, G_V1, 97, 246, True, C);      if C < 0 then
         Result := False;
         return;
      end if;
            --  gopast, line 48
      --  non V1, line 48
      In_Grouping (Z, G_V1, 97, 246, True, C);
      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C + C;
      --  setmark p2, line 48
      Z.I_P2 := Z.C;

      Result := True;
   end R_Mark_regions;

   procedure R_R2 (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_P2 <= Z.C);
   end R_R2;

   procedure R_Particle_etc (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_2 : Integer;
   begin
      --  (, line 55
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 56
      Z.Ket := Z.C;      --  [, line 56

      --  substring, line 56
      Find_Among_Backward (Z, A_0, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 56

      Z.Lb := v_2;
      --  among, line 57
      case A is
         when 1 =>
            --  (, line 63
            In_Grouping_Backward (Z, G_Particle_end, 97, 246, False, C);
            if C /= 0 then
               Result := False;
               return;
            end if;
         when 2 =>
            --  (, line 65
            --  call R2, line 65
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
         when others =>
            null;
      end case;
      --  delete, line 67
      Slice_Del (Z);

      Result := True;
   end R_Particle_etc;

   procedure R_Possessive (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_2 : Integer;
      v_3 : Char_Index;
   begin
      --  (, line 69
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 70
      Z.Ket := Z.C;      --  [, line 70

      --  substring, line 70
      Find_Among_Backward (Z, A_4, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 70

      Z.Lb := v_2;
      --  among, line 71
      case A is
         when 1 =>
            --  (, line 73
            --  not, line 73
            v_3 := Z.L - Z.C;
            --  literal, line 73
            C := Eq_S_Backward (Z, "k");
            if C = 0 then
               goto lab0;
            end if;
            Z.C := Z.C - C;
            Result := False;
            return;

            <<lab0>>
            Z.C := Z.L - v_3;
            --  delete, line 73
            Slice_Del (Z);
         when 2 =>
            --  (, line 75
            --  delete, line 75
            Slice_Del (Z);
            Z.Ket := Z.C;            --  [, line 75

            --  literal, line 75
            C := Eq_S_Backward (Z, "kse");
            if C = 0 then
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 75

            --  <-, line 75
            Slice_From (Z, "ksi");
         when 3 =>
            --  (, line 79
            --  delete, line 79
            Slice_Del (Z);
         when 4 =>
            --  (, line 82
            --  among, line 82
            if Z.C - 1 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 97 then
               Result := False;
               return;
               --  among, line 82
            end if;
            Find_Among_Backward (Z, A_1, Among_String, null, A);
            if A = 0 then
               Result := False;
               return;
            end if;
            --  delete, line 82
            Slice_Del (Z);
         when 5 =>
            --  (, line 84
            --  among, line 84
            if Z.C - 2 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 164 then
               Result := False;
               return;
               --  among, line 84
            end if;
            Find_Among_Backward (Z, A_2, Among_String, null, A);
            if A = 0 then
               Result := False;
               return;
            end if;
            --  delete, line 85
            Slice_Del (Z);
         when 6 =>
            --  (, line 87
            --  among, line 87
            if Z.C - 2 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 101 then
               Result := False;
               return;
               --  among, line 87
            end if;
            Find_Among_Backward (Z, A_3, Among_String, null, A);
            if A = 0 then
               Result := False;
               return;
            end if;
            --  delete, line 87
            Slice_Del (Z);
         when others =>
            null;
      end case;

      Result := True;
   end R_Possessive;

   procedure R_LONG (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  among, line 92
      Find_Among_Backward (Z, A_5, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_LONG;

   procedure R_VI (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 94
      --  literal, line 94
      C := Eq_S_Backward (Z, "i");
      if C = 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C - C;
      In_Grouping_Backward (Z, G_V2, 97, 246, False, C);
      if C /= 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_VI;

   procedure R_Case_ending (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_2 : Integer;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
   begin
      --  (, line 96
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 97
      Z.Ket := Z.C;      --  [, line 97

      --  substring, line 97
      Find_Among_Backward (Z, A_6, Among_String, Among_Handler'Access, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 97

      Z.Lb := v_2;
      --  among, line 98
      case A is
         when 1 =>
            --  (, line 99
            --  literal, line 99
            C := Eq_S_Backward (Z, "a");
            if C = 0 then
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;
         when 2 =>
            --  (, line 100
            --  literal, line 100
            C := Eq_S_Backward (Z, "e");
            if C = 0 then
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;
         when 3 =>
            --  (, line 101
            --  literal, line 101
            C := Eq_S_Backward (Z, "i");
            if C = 0 then
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;
         when 4 =>
            --  (, line 102
            --  literal, line 102
            C := Eq_S_Backward (Z, "o");
            if C = 0 then
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;
         when 5 =>
            --  (, line 103
            --  literal, line 103
            C := Eq_S_Backward (Z, "ä");
            if C = 0 then
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;
         when 6 =>
            --  (, line 104
            --  literal, line 104
            C := Eq_S_Backward (Z, "ö");
            if C = 0 then
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;
         when 7 =>
            --  (, line 112
            --  try, line 112
            v_3 := Z.L - Z.C;
            --  (, line 112
            --  and, line 114
            v_4 := Z.L - Z.C;
            --  or, line 113
            v_5 := Z.L - Z.C;
            --  call LONG, line 112
            R_LONG (Z, Result);
            if not Result then
               goto lab2;
            end if;
            goto lab1;

            <<lab2>>
            Z.C := Z.L - v_5;
            --  literal, line 113
            C := Eq_S_Backward (Z, "ie");
            if C = 0 then
               Z.C := Z.L - v_3;
               goto lab0;
            end if;
            Z.C := Z.C - C;

            <<lab1>>
            Z.C := Z.L - v_4;
            --  next, line 114
            C := Skip_Utf8_Backward (Z);
            if C < 0 then
               Z.C := Z.L - v_3;
               goto lab0;
            end if;
            Z.C := C;
            Z.Bra := Z.C;            --  ], line 114


            <<lab0>>
         when 8 =>
            --  (, line 120
            In_Grouping_Backward (Z, G_V1, 97, 246, False, C);
            if C /= 0 then
               Result := False;
               return;
            end if;
            In_Grouping_Backward (Z, G_C, 98, 122, False, C);
            if C /= 0 then
               Result := False;
               return;
            end if;
         when others =>
            null;
      end case;
      --  delete, line 139
      Slice_Del (Z);
      --  set ending_removed, line 140
      Z.B_Ending_removed := True;

      Result := True;
   end R_Case_ending;

   procedure R_Other_endings (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_2 : Integer;
      v_3 : Char_Index;
   begin
      --  (, line 142
      if Z.C < Z.I_P2 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P2;
      --  (, line 143
      Z.Ket := Z.C;      --  [, line 143

      --  substring, line 143
      Find_Among_Backward (Z, A_7, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 143

      Z.Lb := v_2;
      --  among, line 144
      case A is
         when 1 =>
            --  (, line 147
            --  not, line 147
            v_3 := Z.L - Z.C;
            --  literal, line 147
            C := Eq_S_Backward (Z, "po");
            if C = 0 then
               goto lab0;
            end if;
            Z.C := Z.C - C;
            Result := False;
            return;

            <<lab0>>
            Z.C := Z.L - v_3;
         when others =>
            null;
      end case;
      --  delete, line 152
      Slice_Del (Z);

      Result := True;
   end R_Other_endings;

   procedure R_I_plural (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_2 : Integer;
   begin
      --  (, line 154
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 155
      Z.Ket := Z.C;      --  [, line 155

      --  substring, line 155
      if Z.C <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 105 and then Character'Pos (Z.P (Z.C)) /= 106) then
         Z.Lb := v_2;
         Result := False;
         return;
         --  substring, line 155
      end if;
      Find_Among_Backward (Z, A_8, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 155

      Z.Lb := v_2;
      --  delete, line 159
      Slice_Del (Z);

      Result := True;
   end R_I_plural;

   procedure R_T_plural (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_2 : Integer;
      v_3 : Char_Index;
      v_5 : Integer;
      v_6 : Char_Index;
   begin
      --  (, line 161
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 162
      Z.Ket := Z.C;      --  [, line 163

      --  literal, line 163
      C := Eq_S_Backward (Z, "t");
      if C = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.C := Z.C - C;
      Z.Bra := Z.C;      --  ], line 163

      --  test, line 163
      v_3 := Z.L - Z.C;
      In_Grouping_Backward (Z, G_V1, 97, 246, False, C);
      if C /= 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.C := Z.L - v_3;
      --  delete, line 164
      Slice_Del (Z);
      Z.Lb := v_2;
      if Z.C < Z.I_P2 then
         Result := False;
         return;
      end if;
      v_5 := Z.Lb; Z.Lb := Z.I_P2;
      --  (, line 166
      Z.Ket := Z.C;      --  [, line 166

      --  substring, line 166
      if Z.C - 2 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 97 then
         Z.Lb := v_5;
         Result := False;
         return;
         --  substring, line 166
      end if;
      Find_Among_Backward (Z, A_9, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_5;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 166

      Z.Lb := v_5;
      --  among, line 167
      case A is
         when 1 =>
            --  (, line 168
            --  not, line 168
            v_6 := Z.L - Z.C;
            --  literal, line 168
            C := Eq_S_Backward (Z, "po");
            if C = 0 then
               goto lab0;
            end if;
            Z.C := Z.C - C;
            Result := False;
            return;

            <<lab0>>
            Z.C := Z.L - v_6;
         when others =>
            null;
      end case;
      --  delete, line 171
      Slice_Del (Z);

      Result := True;
   end R_T_plural;

   procedure R_Tidy (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_2 : Integer;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
      v_6 : Char_Index;
      v_7 : Char_Index;
      v_8 : Char_Index;
   begin
      --  (, line 173
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 174
      --  do, line 175
      v_3 := Z.L - Z.C;
      --  (, line 175
      --  and, line 175
      v_4 := Z.L - Z.C;
      --  call LONG, line 175
      R_LONG (Z, Result);
      if not Result then
         goto lab0;
      end if;
      Z.C := Z.L - v_4;
      --  (, line 175
      Z.Ket := Z.C;      --  [, line 175

      --  next, line 175
      C := Skip_Utf8_Backward (Z);
      if C < 0 then
         goto lab0;
      end if;
      Z.C := C;
      Z.Bra := Z.C;      --  ], line 175

      --  delete, line 175
      Slice_Del (Z);

      <<lab0>>
      Z.C := Z.L - v_3;
      --  do, line 176
      v_5 := Z.L - Z.C;
      --  (, line 176
      Z.Ket := Z.C;      --  [, line 176

      In_Grouping_Backward (Z, G_AEI, 97, 228, False, C);
      if C /= 0 then
         goto lab1;
      end if;
      Z.Bra := Z.C;      --  ], line 176

      In_Grouping_Backward (Z, G_C, 98, 122, False, C);
      if C /= 0 then
         goto lab1;
      end if;
      --  delete, line 176
      Slice_Del (Z);

      <<lab1>>
      Z.C := Z.L - v_5;
      --  do, line 177
      v_6 := Z.L - Z.C;
      --  (, line 177
      Z.Ket := Z.C;      --  [, line 177

      --  literal, line 177
      C := Eq_S_Backward (Z, "j");
      if C = 0 then
         goto lab2;
      end if;
      Z.C := Z.C - C;
      Z.Bra := Z.C;      --  ], line 177

      --  or, line 177
      v_7 := Z.L - Z.C;
      --  literal, line 177
      C := Eq_S_Backward (Z, "o");
      if C = 0 then
         goto lab4;
      end if;
      Z.C := Z.C - C;
      goto lab3;

      <<lab4>>
      Z.C := Z.L - v_7;
      --  literal, line 177
      C := Eq_S_Backward (Z, "u");
      if C = 0 then
         goto lab2;
      end if;
      Z.C := Z.C - C;

      <<lab3>>
      --  delete, line 177
      Slice_Del (Z);

      <<lab2>>
      Z.C := Z.L - v_6;
      --  do, line 178
      v_8 := Z.L - Z.C;
      --  (, line 178
      Z.Ket := Z.C;      --  [, line 178

      --  literal, line 178
      C := Eq_S_Backward (Z, "o");
      if C = 0 then
         goto lab5;
      end if;
      Z.C := Z.C - C;
      Z.Bra := Z.C;      --  ], line 178

      --  literal, line 178
      C := Eq_S_Backward (Z, "j");
      if C = 0 then
         goto lab5;
      end if;
      Z.C := Z.C - C;
      --  delete, line 178
      Slice_Del (Z);

      <<lab5>>
      Z.C := Z.L - v_8;
      Z.Lb := v_2;
            --  goto, line 180
      In_Grouping_Backward (Z, G_V1, 97, 246, True, C);      if C < 0 then
         Result := False;
         return;
      end if;
      Z.Ket := Z.C;      --  [, line 180

      In_Grouping_Backward (Z, G_C, 98, 122, False, C);
      if C /= 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 180

      --  -> x, line 180
      Z.S_X := Ada.Strings.Unbounded.To_Unbounded_String (Slice_To (Z));
      --  name x, line 180
      C := Eq_S_Backward (Z, Ada.Strings.Unbounded.To_String (Z.S_X));      if C = 0 then
         Result := False;
         return;
      end if;
      --  delete, line 180
      Slice_Del (Z);

      Result := True;
   end R_Tidy;

   procedure Stem (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
      v_7 : Char_Index;
      v_8 : Char_Index;
      v_9 : Char_Index;
   begin
      --  (, line 184
      --  do, line 186
      v_1 := Z.C;
      --  call mark_regions, line 186
      R_Mark_regions (Z, Result);
      Z.C := v_1;
      --  unset ending_removed, line 187
      Z.B_Ending_removed := False;
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 188

      --  (, line 188
      --  do, line 189
      v_2 := Z.L - Z.C;
      --  call particle_etc, line 189
      R_Particle_etc (Z, Result);
      Z.C := Z.L - v_2;
      --  do, line 190
      v_3 := Z.L - Z.C;
      --  call possessive, line 190
      R_Possessive (Z, Result);
      Z.C := Z.L - v_3;
      --  do, line 191
      v_4 := Z.L - Z.C;
      --  call case_ending, line 191
      R_Case_ending (Z, Result);
      Z.C := Z.L - v_4;
      --  do, line 192
      v_5 := Z.L - Z.C;
      --  call other_endings, line 192
      R_Other_endings (Z, Result);
      Z.C := Z.L - v_5;
      --  or, line 193
      --  (, line 193
      --  Boolean test ending_removed, line 193
      if not Z.B_Ending_removed then
         goto lab1;
      end if;
      --  do, line 193
      v_7 := Z.L - Z.C;
      --  call i_plural, line 193
      R_I_plural (Z, Result);
      Z.C := Z.L - v_7;
      goto lab0;

      <<lab1>>
      --  do, line 193
      v_8 := Z.L - Z.C;
      --  call t_plural, line 193
      R_T_plural (Z, Result);
      Z.C := Z.L - v_8;

      <<lab0>>
      --  do, line 194
      v_9 := Z.L - Z.C;
      --  call tidy, line 194
      R_Tidy (Z, Result);
      Z.C := Z.L - v_9;
      Z.C := Z.Lb;

      Result := True;
   end Stem;

   procedure Among_Handler (Context : in out Stemmer.Context_Type'Class; Operation : in Operation_Index; Result : out Boolean) is
   begin
      case Operation is
         when 1 =>
            R_VI (Context_Type (Context), Result);
         when 2 =>
            R_LONG (Context_Type (Context), Result);
         when 3 =>
            R_VI (Context_Type (Context), Result);
         when 4 =>
            R_VI (Context_Type (Context), Result);
         when others =>
            Result := False;
      end case;
   end Among_Handler;
end Stemmer.Finnish;
