--  Generated by Snowball 2.0.0 - https://snowballstem.org/

package body Stemmer.Turkish is

   pragma Style_Checks ("-mr");
   pragma Warnings (Off, "*variable*is never read and never assigned*");
   pragma Warnings (Off, "*mode could be*instead of*");
   pragma Warnings (Off, "*formal parameter.*is not modified*");
   pragma Warnings (Off, "*this line is too long*");
   pragma Warnings (Off, "*is not referenced*");

   procedure R_Stem_suffix_chain_before_ki (Z : in out Context_Type; Result : out Boolean);
   procedure R_Stem_noun_suffixes (Z : in out Context_Type; Result : out Boolean);
   procedure R_Stem_nominal_verb_suffixes (Z : in out Context_Type; Result : out Boolean);
   procedure R_Postlude (Z : in out Context_Type; Result : out Boolean);
   procedure R_Post_process_last_consonants (Z : in out Context_Type; Result : out Boolean);
   procedure R_More_than_one_syllable_word (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_suffix_with_optional_s_consonant (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_suffix_with_optional_n_consonant (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_suffix_with_optional_U_vowel (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_suffix_with_optional_y_consonant (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_ysA (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_ymUs_E (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_yken (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_yDU (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_yUz (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_yUm (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_yU (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_ylA (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_yA (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_possessives (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_sUnUz (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_sUn (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_sU (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_nUz (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_nUn (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_nU (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_ndAn (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_ndA (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_ncA (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_nA (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_lArI (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_lAr (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_ki (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_DUr (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_DAn (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_DA (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_cAsInA (Z : in out Context_Type; Result : out Boolean);
   procedure R_Is_reserved_word (Z : in out Context_Type; Result : out Boolean);
   procedure R_Check_vowel_harmony (Z : in out Context_Type; Result : out Boolean);
   procedure R_Append_U_to_stems_ending_with_d_or_g (Z : in out Context_Type; Result : out Boolean);

   G_Vowel : constant Grouping_Array (0 .. 215) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, True, False, False,
      False, False, False, True, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      True, False, False, False, False, False, False, False
   );

   G_U : constant Grouping_Array (0 .. 207) := (
      True, False, False, False, False, False, False, False,
      False, False, False, False, True, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, True, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      True, False, False, False, False, False, False, False
   );

   G_Vowel1 : constant Grouping_Array (0 .. 215) := (
      True, False, False, False, False, False, False, False,
      False, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      True, False, False, False, False, False, False, False
   );

   G_Vowel2 : constant Grouping_Array (0 .. 151) := (
      True, False, False, False, True, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, True, False, False, False, False, False, True
   );

   G_Vowel3 : constant Grouping_Array (0 .. 215) := (
      True, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      True, False, False, False, False, False, False, False
   );

   G_Vowel4 : constant Grouping_Array (0 .. 7) := (
      True, False, False, False, True, False, False, False
   );

   G_Vowel5 : constant Grouping_Array (0 .. 7) := (
      True, False, False, False, False, False, True, False
   );

   G_Vowel6 : constant Grouping_Array (0 .. 7) := (
      True, False, False, False, False, False, True, False
   );
   Among_String : constant String := "m" & "n" & "miz" & "niz" & "muz"
      & "nuz" & "mız" & "nız" & "müz" & "nüz" & "leri" & "ları" & "ni" & "nu"
      & "nı" & "nü" & "in" & "un" & "ın" & "ün" & "a" & "e" & "na" & "ne" & "da"
      & "ta" & "de" & "te" & "nda" & "nde" & "dan" & "tan" & "den" & "ten" & "ndan"
      & "nden" & "la" & "le" & "ca" & "ce" & "im" & "um" & "ım" & "üm" & "sin"
      & "sun" & "sın" & "sün" & "iz" & "uz" & "ız" & "üz" & "siniz" & "sunuz"
      & "sınız" & "sünüz" & "lar" & "ler" & "niz" & "nuz" & "nız" & "nüz" & "dir"
      & "tir" & "dur" & "tur" & "dır" & "tır" & "dür" & "tür" & "casına"
      & "cesine" & "di" & "ti" & "dik" & "tik" & "duk" & "tuk" & "dık" & "tık"
      & "dük" & "tük" & "dim" & "tim" & "dum" & "tum" & "dım" & "tım" & "düm"
      & "tüm" & "din" & "tin" & "dun" & "tun" & "dın" & "tın" & "dün" & "tün"
      & "du" & "tu" & "dı" & "tı" & "dü" & "tü" & "sa" & "se" & "sak" & "sek"
      & "sam" & "sem" & "san" & "sen" & "miş" & "muş" & "mış" & "müş" & "b" & "c"
      & "d" & "ğ";

   A_0 : constant Among_Array_Type (0 .. 9) := (
      (1, 1, -1, -1, 0),
      (2, 2, -1, -1, 0),
      (3, 5, -1, -1, 0),
      (6, 8, -1, -1, 0),
      (9, 11, -1, -1, 0),
      (12, 14, -1, -1, 0),
      (15, 18, -1, -1, 0),
      (19, 22, -1, -1, 0),
      (23, 26, -1, -1, 0),
      (27, 30, -1, -1, 0));

   A_1 : constant Among_Array_Type (0 .. 1) := (
      (31, 34, -1, -1, 0),
      (35, 39, -1, -1, 0));

   A_2 : constant Among_Array_Type (0 .. 3) := (
      (40, 41, -1, -1, 0),
      (42, 43, -1, -1, 0),
      (44, 46, -1, -1, 0),
      (47, 49, -1, -1, 0));

   A_3 : constant Among_Array_Type (0 .. 3) := (
      (50, 51, -1, -1, 0),
      (52, 53, -1, -1, 0),
      (54, 56, -1, -1, 0),
      (57, 59, -1, -1, 0));

   A_4 : constant Among_Array_Type (0 .. 1) := (
      (60, 60, -1, -1, 0),
      (61, 61, -1, -1, 0));

   A_5 : constant Among_Array_Type (0 .. 1) := (
      (62, 63, -1, -1, 0),
      (64, 65, -1, -1, 0));

   A_6 : constant Among_Array_Type (0 .. 3) := (
      (66, 67, -1, -1, 0),
      (68, 69, -1, -1, 0),
      (70, 71, -1, -1, 0),
      (72, 73, -1, -1, 0));

   A_7 : constant Among_Array_Type (0 .. 1) := (
      (74, 76, -1, -1, 0),
      (77, 79, -1, -1, 0));

   A_8 : constant Among_Array_Type (0 .. 3) := (
      (80, 82, -1, -1, 0),
      (83, 85, -1, -1, 0),
      (86, 88, -1, -1, 0),
      (89, 91, -1, -1, 0));

   A_9 : constant Among_Array_Type (0 .. 1) := (
      (92, 95, -1, -1, 0),
      (96, 99, -1, -1, 0));

   A_10 : constant Among_Array_Type (0 .. 1) := (
      (100, 101, -1, -1, 0),
      (102, 103, -1, -1, 0));

   A_11 : constant Among_Array_Type (0 .. 1) := (
      (104, 105, -1, -1, 0),
      (106, 107, -1, -1, 0));

   A_12 : constant Among_Array_Type (0 .. 3) := (
      (108, 109, -1, -1, 0),
      (110, 111, -1, -1, 0),
      (112, 114, -1, -1, 0),
      (115, 117, -1, -1, 0));

   A_13 : constant Among_Array_Type (0 .. 3) := (
      (118, 120, -1, -1, 0),
      (121, 123, -1, -1, 0),
      (124, 127, -1, -1, 0),
      (128, 131, -1, -1, 0));

   A_14 : constant Among_Array_Type (0 .. 3) := (
      (132, 133, -1, -1, 0),
      (134, 135, -1, -1, 0),
      (136, 138, -1, -1, 0),
      (139, 141, -1, -1, 0));

   A_15 : constant Among_Array_Type (0 .. 3) := (
      (142, 146, -1, -1, 0),
      (147, 151, -1, -1, 0),
      (152, 158, -1, -1, 0),
      (159, 165, -1, -1, 0));

   A_16 : constant Among_Array_Type (0 .. 1) := (
      (166, 168, -1, -1, 0),
      (169, 171, -1, -1, 0));

   A_17 : constant Among_Array_Type (0 .. 3) := (
      (172, 174, -1, -1, 0),
      (175, 177, -1, -1, 0),
      (178, 181, -1, -1, 0),
      (182, 185, -1, -1, 0));

   A_18 : constant Among_Array_Type (0 .. 7) := (
      (186, 188, -1, -1, 0),
      (189, 191, -1, -1, 0),
      (192, 194, -1, -1, 0),
      (195, 197, -1, -1, 0),
      (198, 201, -1, -1, 0),
      (202, 205, -1, -1, 0),
      (206, 209, -1, -1, 0),
      (210, 213, -1, -1, 0));

   A_19 : constant Among_Array_Type (0 .. 1) := (
      (214, 220, -1, -1, 0),
      (221, 226, -1, -1, 0));

   A_20 : constant Among_Array_Type (0 .. 31) := (
      (227, 228, -1, -1, 0),
      (229, 230, -1, -1, 0),
      (231, 233, -1, -1, 0),
      (234, 236, -1, -1, 0),
      (237, 239, -1, -1, 0),
      (240, 242, -1, -1, 0),
      (243, 246, -1, -1, 0),
      (247, 250, -1, -1, 0),
      (251, 254, -1, -1, 0),
      (255, 258, -1, -1, 0),
      (259, 261, -1, -1, 0),
      (262, 264, -1, -1, 0),
      (265, 267, -1, -1, 0),
      (268, 270, -1, -1, 0),
      (271, 274, -1, -1, 0),
      (275, 278, -1, -1, 0),
      (279, 282, -1, -1, 0),
      (283, 286, -1, -1, 0),
      (287, 289, -1, -1, 0),
      (290, 292, -1, -1, 0),
      (293, 295, -1, -1, 0),
      (296, 298, -1, -1, 0),
      (299, 302, -1, -1, 0),
      (303, 306, -1, -1, 0),
      (307, 310, -1, -1, 0),
      (311, 314, -1, -1, 0),
      (315, 316, -1, -1, 0),
      (317, 318, -1, -1, 0),
      (319, 321, -1, -1, 0),
      (322, 324, -1, -1, 0),
      (325, 327, -1, -1, 0),
      (328, 330, -1, -1, 0));

   A_21 : constant Among_Array_Type (0 .. 7) := (
      (331, 332, -1, -1, 0),
      (333, 334, -1, -1, 0),
      (335, 337, -1, -1, 0),
      (338, 340, -1, -1, 0),
      (341, 343, -1, -1, 0),
      (344, 346, -1, -1, 0),
      (347, 349, -1, -1, 0),
      (350, 352, -1, -1, 0));

   A_22 : constant Among_Array_Type (0 .. 3) := (
      (353, 356, -1, -1, 0),
      (357, 360, -1, -1, 0),
      (361, 365, -1, -1, 0),
      (366, 370, -1, -1, 0));

   A_23 : constant Among_Array_Type (0 .. 3) := (
      (371, 371, -1, 1, 0),
      (372, 372, -1, 2, 0),
      (373, 373, -1, 3, 0),
      (374, 375, -1, 4, 0));


   procedure R_Check_vowel_harmony (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
   begin
      --  (, line 109
      --  test, line 110
      v_1 := Z.L - Z.C;
      --  (, line 111
      --  (, line 112
            --  goto, line 112
      Out_Grouping_Backward (Z, G_Vowel, 97, 305, True, C);      if C < 0 then
         Result := False;
         return;
      end if;
      --  (, line 113
      --  or, line 114
      v_2 := Z.L - Z.C;
      --  (, line 114
      --  literal, line 114
      C := Eq_S_Backward (Z, "a");
      if C = 0 then
         goto lab2;
      end if;
      Z.C := Z.C - C;
            --  goto, line 114
      Out_Grouping_Backward (Z, G_Vowel1, 97, 305, True, C);      if C < 0 then
         goto lab2;
      end if;
      goto lab1;

      <<lab2>>
      Z.C := Z.L - v_2;
      --  (, line 115
      --  literal, line 115
      C := Eq_S_Backward (Z, "e");
      if C = 0 then
         goto lab4;
      end if;
      Z.C := Z.C - C;
            --  goto, line 115
      Out_Grouping_Backward (Z, G_Vowel2, 101, 252, True, C);      if C < 0 then
         goto lab4;
      end if;
      goto lab1;

      <<lab4>>
      Z.C := Z.L - v_2;
      --  (, line 116
      --  literal, line 116
      C := Eq_S_Backward (Z, "ı");
      if C = 0 then
         goto lab6;
      end if;
      Z.C := Z.C - C;
            --  goto, line 116
      Out_Grouping_Backward (Z, G_Vowel3, 97, 305, True, C);      if C < 0 then
         goto lab6;
      end if;
      goto lab1;

      <<lab6>>
      Z.C := Z.L - v_2;
      --  (, line 117
      --  literal, line 117
      C := Eq_S_Backward (Z, "i");
      if C = 0 then
         goto lab8;
      end if;
      Z.C := Z.C - C;
            --  goto, line 117
      Out_Grouping_Backward (Z, G_Vowel4, 101, 105, True, C);      if C < 0 then
         goto lab8;
      end if;
      goto lab1;

      <<lab8>>
      Z.C := Z.L - v_2;
      --  (, line 118
      --  literal, line 118
      C := Eq_S_Backward (Z, "o");
      if C = 0 then
         goto lab10;
      end if;
      Z.C := Z.C - C;
            --  goto, line 118
      Out_Grouping_Backward (Z, G_Vowel5, 111, 117, True, C);      if C < 0 then
         goto lab10;
      end if;
      goto lab1;

      <<lab10>>
      Z.C := Z.L - v_2;
      --  (, line 119
      --  literal, line 119
      C := Eq_S_Backward (Z, "ö");
      if C = 0 then
         goto lab12;
      end if;
      Z.C := Z.C - C;
            --  goto, line 119
      Out_Grouping_Backward (Z, G_Vowel6, 246, 252, True, C);      if C < 0 then
         goto lab12;
      end if;
      goto lab1;

      <<lab12>>
      Z.C := Z.L - v_2;
      --  (, line 120
      --  literal, line 120
      C := Eq_S_Backward (Z, "u");
      if C = 0 then
         goto lab14;
      end if;
      Z.C := Z.C - C;
            --  goto, line 120
      Out_Grouping_Backward (Z, G_Vowel5, 111, 117, True, C);      if C < 0 then
         goto lab14;
      end if;
      goto lab1;

      <<lab14>>
      Z.C := Z.L - v_2;
      --  (, line 121
      --  literal, line 121
      C := Eq_S_Backward (Z, "ü");
      if C = 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C - C;
            --  goto, line 121
      Out_Grouping_Backward (Z, G_Vowel6, 246, 252, True, C);      if C < 0 then
         Result := False;
         return;
      end if;

      <<lab1>>
      Z.C := Z.L - v_1;

      Result := True;
   end R_Check_vowel_harmony;

   procedure R_Mark_suffix_with_optional_n_consonant (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
      v_5 : Integer;
   begin
      --  (, line 130
      --  or, line 132
      v_1 := Z.L - Z.C;
      --  (, line 131
      --  literal, line 131
      C := Eq_S_Backward (Z, "n");
      if C = 0 then
         goto lab1;
      end if;
      Z.C := Z.C - C;
      --  (, line 131
      --  test, line 131
      v_2 := Z.L - Z.C;
      In_Grouping_Backward (Z, G_Vowel, 97, 305, False, C);
      if C /= 0 then
         goto lab1;
      end if;
      Z.C := Z.L - v_2;
      goto lab0;

      <<lab1>>
      Z.C := Z.L - v_1;
      --  (, line 133
      --  (, line 133
      --  not, line 133
      v_3 := Z.L - Z.C;
      --  (, line 133
      --  test, line 133
      v_4 := Z.L - Z.C;
      --  literal, line 133
      C := Eq_S_Backward (Z, "n");
      if C = 0 then
         goto lab2;
      end if;
      Z.C := Z.C - C;
      Z.C := Z.L - v_4;
      Result := False;
      return;

      <<lab2>>
      Z.C := Z.L - v_3;
      --  test, line 133
      v_5 := Z.L - Z.C;
      --  (, line 133
      --  next, line 133
      C := Skip_Utf8_Backward (Z, 1);      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      In_Grouping_Backward (Z, G_Vowel, 97, 305, False, C);
      if C /= 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.L - v_5;

      <<lab0>>

      Result := True;
   end R_Mark_suffix_with_optional_n_consonant;

   procedure R_Mark_suffix_with_optional_s_consonant (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
      v_5 : Integer;
   begin
      --  (, line 141
      --  or, line 143
      v_1 := Z.L - Z.C;
      --  (, line 142
      --  literal, line 142
      C := Eq_S_Backward (Z, "s");
      if C = 0 then
         goto lab1;
      end if;
      Z.C := Z.C - C;
      --  (, line 142
      --  test, line 142
      v_2 := Z.L - Z.C;
      In_Grouping_Backward (Z, G_Vowel, 97, 305, False, C);
      if C /= 0 then
         goto lab1;
      end if;
      Z.C := Z.L - v_2;
      goto lab0;

      <<lab1>>
      Z.C := Z.L - v_1;
      --  (, line 144
      --  (, line 144
      --  not, line 144
      v_3 := Z.L - Z.C;
      --  (, line 144
      --  test, line 144
      v_4 := Z.L - Z.C;
      --  literal, line 144
      C := Eq_S_Backward (Z, "s");
      if C = 0 then
         goto lab2;
      end if;
      Z.C := Z.C - C;
      Z.C := Z.L - v_4;
      Result := False;
      return;

      <<lab2>>
      Z.C := Z.L - v_3;
      --  test, line 144
      v_5 := Z.L - Z.C;
      --  (, line 144
      --  next, line 144
      C := Skip_Utf8_Backward (Z, 1);      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      In_Grouping_Backward (Z, G_Vowel, 97, 305, False, C);
      if C /= 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.L - v_5;

      <<lab0>>

      Result := True;
   end R_Mark_suffix_with_optional_s_consonant;

   procedure R_Mark_suffix_with_optional_y_consonant (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
      v_5 : Integer;
   begin
      --  (, line 151
      --  or, line 153
      v_1 := Z.L - Z.C;
      --  (, line 152
      --  literal, line 152
      C := Eq_S_Backward (Z, "y");
      if C = 0 then
         goto lab1;
      end if;
      Z.C := Z.C - C;
      --  (, line 152
      --  test, line 152
      v_2 := Z.L - Z.C;
      In_Grouping_Backward (Z, G_Vowel, 97, 305, False, C);
      if C /= 0 then
         goto lab1;
      end if;
      Z.C := Z.L - v_2;
      goto lab0;

      <<lab1>>
      Z.C := Z.L - v_1;
      --  (, line 154
      --  (, line 154
      --  not, line 154
      v_3 := Z.L - Z.C;
      --  (, line 154
      --  test, line 154
      v_4 := Z.L - Z.C;
      --  literal, line 154
      C := Eq_S_Backward (Z, "y");
      if C = 0 then
         goto lab2;
      end if;
      Z.C := Z.C - C;
      Z.C := Z.L - v_4;
      Result := False;
      return;

      <<lab2>>
      Z.C := Z.L - v_3;
      --  test, line 154
      v_5 := Z.L - Z.C;
      --  (, line 154
      --  next, line 154
      C := Skip_Utf8_Backward (Z, 1);      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      In_Grouping_Backward (Z, G_Vowel, 97, 305, False, C);
      if C /= 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.L - v_5;

      <<lab0>>

      Result := True;
   end R_Mark_suffix_with_optional_y_consonant;

   procedure R_Mark_suffix_with_optional_U_vowel (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
      v_5 : Integer;
   begin
      --  (, line 157
      --  or, line 159
      v_1 := Z.L - Z.C;
      --  (, line 158
      In_Grouping_Backward (Z, G_U, 105, 305, False, C);
      if C /= 0 then
         goto lab1;
      end if;
      --  (, line 158
      --  test, line 158
      v_2 := Z.L - Z.C;
      Out_Grouping_Backward (Z, G_Vowel, 97, 305, False, C);
      if C /= 0 then
         goto lab1;
      end if;
      Z.C := Z.L - v_2;
      goto lab0;

      <<lab1>>
      Z.C := Z.L - v_1;
      --  (, line 160
      --  (, line 160
      --  not, line 160
      v_3 := Z.L - Z.C;
      --  (, line 160
      --  test, line 160
      v_4 := Z.L - Z.C;
      In_Grouping_Backward (Z, G_U, 105, 305, False, C);
      if C /= 0 then
         goto lab2;
      end if;
      Z.C := Z.L - v_4;
      Result := False;
      return;

      <<lab2>>
      Z.C := Z.L - v_3;
      --  test, line 160
      v_5 := Z.L - Z.C;
      --  (, line 160
      --  next, line 160
      C := Skip_Utf8_Backward (Z, 1);      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      Out_Grouping_Backward (Z, G_Vowel, 97, 305, False, C);
      if C /= 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.L - v_5;

      <<lab0>>

      Result := True;
   end R_Mark_suffix_with_optional_U_vowel;

   procedure R_Mark_possessives (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 164
      --  among, line 165
      if Z.C <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#4006000#) then
         Result := False;
         return;
         --  among, line 165
      end if;
      Find_Among_Backward (Z, A_0, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      --  (, line 167
      --  call mark_suffix_with_optional_U_vowel, line 167
      R_Mark_suffix_with_optional_U_vowel (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_possessives;

   procedure R_Mark_sU (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 170
      --  call check_vowel_harmony, line 171
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      In_Grouping_Backward (Z, G_U, 105, 305, False, C);
      if C /= 0 then
         Result := False;
         return;
      end if;
      --  (, line 173
      --  call mark_suffix_with_optional_s_consonant, line 173
      R_Mark_suffix_with_optional_s_consonant (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_sU;

   procedure R_Mark_lArI (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 176
      --  among, line 177
      if Z.C - 3 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 105 and then Character'Pos (Z.P (Z.C)) /= 177) then
         Result := False;
         return;
         --  among, line 177
      end if;
      Find_Among_Backward (Z, A_1, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_lArI;

   procedure R_Mark_yU (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 180
      --  call check_vowel_harmony, line 181
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      In_Grouping_Backward (Z, G_U, 105, 305, False, C);
      if C /= 0 then
         Result := False;
         return;
      end if;
      --  (, line 183
      --  call mark_suffix_with_optional_y_consonant, line 183
      R_Mark_suffix_with_optional_y_consonant (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_yU;

   procedure R_Mark_nU (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 186
      --  call check_vowel_harmony, line 187
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 188
      Find_Among_Backward (Z, A_2, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_nU;

   procedure R_Mark_nUn (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 191
      --  call check_vowel_harmony, line 192
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 193
      if Z.C - 1 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 110 then
         Result := False;
         return;
         --  among, line 193
      end if;
      Find_Among_Backward (Z, A_3, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      --  (, line 194
      --  call mark_suffix_with_optional_n_consonant, line 194
      R_Mark_suffix_with_optional_n_consonant (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_nUn;

   procedure R_Mark_yA (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 197
      --  call check_vowel_harmony, line 198
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 199
      if Z.C <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 97 and then Character'Pos (Z.P (Z.C)) /= 101) then
         Result := False;
         return;
         --  among, line 199
      end if;
      Find_Among_Backward (Z, A_4, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      --  (, line 200
      --  call mark_suffix_with_optional_y_consonant, line 200
      R_Mark_suffix_with_optional_y_consonant (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_yA;

   procedure R_Mark_nA (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 203
      --  call check_vowel_harmony, line 204
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 205
      if Z.C - 1 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 97 and then Character'Pos (Z.P (Z.C)) /= 101) then
         Result := False;
         return;
         --  among, line 205
      end if;
      Find_Among_Backward (Z, A_5, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_nA;

   procedure R_Mark_DA (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 208
      --  call check_vowel_harmony, line 209
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 210
      if Z.C - 1 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 97 and then Character'Pos (Z.P (Z.C)) /= 101) then
         Result := False;
         return;
         --  among, line 210
      end if;
      Find_Among_Backward (Z, A_6, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_DA;

   procedure R_Mark_ndA (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 213
      --  call check_vowel_harmony, line 214
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 215
      if Z.C - 2 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 97 and then Character'Pos (Z.P (Z.C)) /= 101) then
         Result := False;
         return;
         --  among, line 215
      end if;
      Find_Among_Backward (Z, A_7, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_ndA;

   procedure R_Mark_DAn (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 218
      --  call check_vowel_harmony, line 219
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 220
      if Z.C - 2 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 110 then
         Result := False;
         return;
         --  among, line 220
      end if;
      Find_Among_Backward (Z, A_8, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_DAn;

   procedure R_Mark_ndAn (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 223
      --  call check_vowel_harmony, line 224
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 225
      if Z.C - 3 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 110 then
         Result := False;
         return;
         --  among, line 225
      end if;
      Find_Among_Backward (Z, A_9, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_ndAn;

   procedure R_Mark_ylA (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 228
      --  call check_vowel_harmony, line 229
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 230
      if Z.C - 1 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 97 and then Character'Pos (Z.P (Z.C)) /= 101) then
         Result := False;
         return;
         --  among, line 230
      end if;
      Find_Among_Backward (Z, A_10, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      --  (, line 231
      --  call mark_suffix_with_optional_y_consonant, line 231
      R_Mark_suffix_with_optional_y_consonant (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_ylA;

   procedure R_Mark_ki (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 234
      --  literal, line 235
      C := Eq_S_Backward (Z, "ki");
      if C = 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C - C;

      Result := True;
   end R_Mark_ki;

   procedure R_Mark_ncA (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 238
      --  call check_vowel_harmony, line 239
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 240
      if Z.C - 1 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 97 and then Character'Pos (Z.P (Z.C)) /= 101) then
         Result := False;
         return;
         --  among, line 240
      end if;
      Find_Among_Backward (Z, A_11, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      --  (, line 241
      --  call mark_suffix_with_optional_n_consonant, line 241
      R_Mark_suffix_with_optional_n_consonant (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_ncA;

   procedure R_Mark_yUm (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 244
      --  call check_vowel_harmony, line 245
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 246
      if Z.C - 1 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 109 then
         Result := False;
         return;
         --  among, line 246
      end if;
      Find_Among_Backward (Z, A_12, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      --  (, line 247
      --  call mark_suffix_with_optional_y_consonant, line 247
      R_Mark_suffix_with_optional_y_consonant (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_yUm;

   procedure R_Mark_sUn (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 250
      --  call check_vowel_harmony, line 251
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 252
      if Z.C - 2 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 110 then
         Result := False;
         return;
         --  among, line 252
      end if;
      Find_Among_Backward (Z, A_13, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_sUn;

   procedure R_Mark_yUz (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 255
      --  call check_vowel_harmony, line 256
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 257
      if Z.C - 1 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 122 then
         Result := False;
         return;
         --  among, line 257
      end if;
      Find_Among_Backward (Z, A_14, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      --  (, line 258
      --  call mark_suffix_with_optional_y_consonant, line 258
      R_Mark_suffix_with_optional_y_consonant (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_yUz;

   procedure R_Mark_sUnUz (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 261
      --  among, line 262
      if Z.C - 4 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 122 then
         Result := False;
         return;
         --  among, line 262
      end if;
      Find_Among_Backward (Z, A_15, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_sUnUz;

   procedure R_Mark_lAr (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 265
      --  call check_vowel_harmony, line 266
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 267
      if Z.C - 2 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 114 then
         Result := False;
         return;
         --  among, line 267
      end if;
      Find_Among_Backward (Z, A_16, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_lAr;

   procedure R_Mark_nUz (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 270
      --  call check_vowel_harmony, line 271
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 272
      if Z.C - 2 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 122 then
         Result := False;
         return;
         --  among, line 272
      end if;
      Find_Among_Backward (Z, A_17, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_nUz;

   procedure R_Mark_DUr (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 275
      --  call check_vowel_harmony, line 276
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 277
      if Z.C - 2 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 114 then
         Result := False;
         return;
         --  among, line 277
      end if;
      Find_Among_Backward (Z, A_18, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_DUr;

   procedure R_Mark_cAsInA (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 280
      --  among, line 281
      if Z.C - 5 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 97 and then Character'Pos (Z.P (Z.C)) /= 101) then
         Result := False;
         return;
         --  among, line 281
      end if;
      Find_Among_Backward (Z, A_19, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_cAsInA;

   procedure R_Mark_yDU (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 284
      --  call check_vowel_harmony, line 285
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 286
      Find_Among_Backward (Z, A_20, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      --  (, line 290
      --  call mark_suffix_with_optional_y_consonant, line 290
      R_Mark_suffix_with_optional_y_consonant (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_yDU;

   procedure R_Mark_ysA (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 294
      --  among, line 295
      if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#6822#) then
         Result := False;
         return;
         --  among, line 295
      end if;
      Find_Among_Backward (Z, A_21, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      --  (, line 296
      --  call mark_suffix_with_optional_y_consonant, line 296
      R_Mark_suffix_with_optional_y_consonant (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_ysA;

   procedure R_Mark_ymUs_E (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 299
      --  call check_vowel_harmony, line 300
      R_Check_vowel_harmony (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 301
      if Z.C - 3 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 159 then
         Result := False;
         return;
         --  among, line 301
      end if;
      Find_Among_Backward (Z, A_22, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      --  (, line 302
      --  call mark_suffix_with_optional_y_consonant, line 302
      R_Mark_suffix_with_optional_y_consonant (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_ymUs_E;

   procedure R_Mark_yken (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 305
      --  literal, line 306
      C := Eq_S_Backward (Z, "ken");
      if C = 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C - C;
      --  (, line 306
      --  call mark_suffix_with_optional_y_consonant, line 306
      R_Mark_suffix_with_optional_y_consonant (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Mark_yken;

   procedure R_Stem_nominal_verb_suffixes (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
      v_5 : Integer;
      v_6 : Integer;
      v_7 : Integer;
      v_8 : Integer;
      v_9 : Integer;
      v_10 : Integer;
   begin
      --  (, line 309
      Z.Ket := Z.C;      --  [, line 310

      --  set continue_stemming_noun_suffixes, line 311
      Z.B_Continue_stemming_noun_suffixes := True;
      --  or, line 313
      v_1 := Z.L - Z.C;
      --  (, line 312
      --  or, line 312
      v_2 := Z.L - Z.C;
      --  call mark_ymUs_, line 312
      R_Mark_ymUs_E (Z, Result);
      if not Result then
         goto lab3;
      end if;
      goto lab2;

      <<lab3>>
      Z.C := Z.L - v_2;
      --  call mark_yDU, line 312
      R_Mark_yDU (Z, Result);
      if not Result then
         goto lab4;
      end if;
      goto lab2;

      <<lab4>>
      Z.C := Z.L - v_2;
      --  call mark_ysA, line 312
      R_Mark_ysA (Z, Result);
      if not Result then
         goto lab5;
      end if;
      goto lab2;

      <<lab5>>
      Z.C := Z.L - v_2;
      --  call mark_yken, line 312
      R_Mark_yken (Z, Result);
      if not Result then
         goto lab1;
      end if;

      <<lab2>>
      goto lab0;

      <<lab1>>
      Z.C := Z.L - v_1;
      --  (, line 314
      --  call mark_cAsInA, line 314
      R_Mark_cAsInA (Z, Result);
      if not Result then
         goto lab6;
      end if;
      --  (, line 314
      --  or, line 314
      v_3 := Z.L - Z.C;
      --  call mark_sUnUz, line 314
      R_Mark_sUnUz (Z, Result);
      if not Result then
         goto lab8;
      end if;
      goto lab7;

      <<lab8>>
      Z.C := Z.L - v_3;
      --  call mark_lAr, line 314
      R_Mark_lAr (Z, Result);
      if not Result then
         goto lab9;
      end if;
      goto lab7;

      <<lab9>>
      Z.C := Z.L - v_3;
      --  call mark_yUm, line 314
      R_Mark_yUm (Z, Result);
      if not Result then
         goto lab10;
      end if;
      goto lab7;

      <<lab10>>
      Z.C := Z.L - v_3;
      --  call mark_sUn, line 314
      R_Mark_sUn (Z, Result);
      if not Result then
         goto lab11;
      end if;
      goto lab7;

      <<lab11>>
      Z.C := Z.L - v_3;
      --  call mark_yUz, line 314
      R_Mark_yUz (Z, Result);
      if not Result then
         goto lab12;
      end if;
      goto lab7;

      <<lab12>>
      Z.C := Z.L - v_3;

      <<lab7>>
      --  call mark_ymUs_, line 314
      R_Mark_ymUs_E (Z, Result);
      if not Result then
         goto lab6;
      end if;
      goto lab0;

      <<lab6>>
      Z.C := Z.L - v_1;
      --  (, line 316
      --  call mark_lAr, line 317
      R_Mark_lAr (Z, Result);
      if not Result then
         goto lab13;
      end if;
      Z.Bra := Z.C;      --  ], line 317

      --  delete, line 317
      Slice_Del (Z);
      --  try, line 317
      v_4 := Z.L - Z.C;
      --  (, line 317
      Z.Ket := Z.C;      --  [, line 317

      --  (, line 317
      --  or, line 317
      v_5 := Z.L - Z.C;
      --  call mark_DUr, line 317
      R_Mark_DUr (Z, Result);
      if not Result then
         goto lab16;
      end if;
      goto lab15;

      <<lab16>>
      Z.C := Z.L - v_5;
      --  call mark_yDU, line 317
      R_Mark_yDU (Z, Result);
      if not Result then
         goto lab17;
      end if;
      goto lab15;

      <<lab17>>
      Z.C := Z.L - v_5;
      --  call mark_ysA, line 317
      R_Mark_ysA (Z, Result);
      if not Result then
         goto lab18;
      end if;
      goto lab15;

      <<lab18>>
      Z.C := Z.L - v_5;
      --  call mark_ymUs_, line 317
      R_Mark_ymUs_E (Z, Result);
      if not Result then
         Z.C := Z.L - v_4;
         goto lab14;
      end if;

      <<lab15>>

      <<lab14>>
      --  unset continue_stemming_noun_suffixes, line 318
      Z.B_Continue_stemming_noun_suffixes := False;
      goto lab0;

      <<lab13>>
      Z.C := Z.L - v_1;
      --  (, line 321
      --  call mark_nUz, line 321
      R_Mark_nUz (Z, Result);
      if not Result then
         goto lab19;
      end if;
      --  (, line 321
      --  or, line 321
      v_6 := Z.L - Z.C;
      --  call mark_yDU, line 321
      R_Mark_yDU (Z, Result);
      if not Result then
         goto lab21;
      end if;
      goto lab20;

      <<lab21>>
      Z.C := Z.L - v_6;
      --  call mark_ysA, line 321
      R_Mark_ysA (Z, Result);
      if not Result then
         goto lab19;
      end if;

      <<lab20>>
      goto lab0;

      <<lab19>>
      Z.C := Z.L - v_1;
      --  (, line 323
      --  (, line 323
      --  or, line 323
      v_7 := Z.L - Z.C;
      --  call mark_sUnUz, line 323
      R_Mark_sUnUz (Z, Result);
      if not Result then
         goto lab24;
      end if;
      goto lab23;

      <<lab24>>
      Z.C := Z.L - v_7;
      --  call mark_yUz, line 323
      R_Mark_yUz (Z, Result);
      if not Result then
         goto lab25;
      end if;
      goto lab23;

      <<lab25>>
      Z.C := Z.L - v_7;
      --  call mark_sUn, line 323
      R_Mark_sUn (Z, Result);
      if not Result then
         goto lab26;
      end if;
      goto lab23;

      <<lab26>>
      Z.C := Z.L - v_7;
      --  call mark_yUm, line 323
      R_Mark_yUm (Z, Result);
      if not Result then
         goto lab22;
      end if;

      <<lab23>>
      Z.Bra := Z.C;      --  ], line 323

      --  delete, line 323
      Slice_Del (Z);
      --  try, line 323
      v_8 := Z.L - Z.C;
      --  (, line 323
      Z.Ket := Z.C;      --  [, line 323

      --  call mark_ymUs_, line 323
      R_Mark_ymUs_E (Z, Result);
      if not Result then
         Z.C := Z.L - v_8;
         goto lab27;
      end if;

      <<lab27>>
      goto lab0;

      <<lab22>>
      Z.C := Z.L - v_1;
      --  (, line 325
      --  call mark_DUr, line 325
      R_Mark_DUr (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 325

      --  delete, line 325
      Slice_Del (Z);
      --  try, line 325
      v_9 := Z.L - Z.C;
      --  (, line 325
      Z.Ket := Z.C;      --  [, line 325

      --  (, line 325
      --  or, line 325
      v_10 := Z.L - Z.C;
      --  call mark_sUnUz, line 325
      R_Mark_sUnUz (Z, Result);
      if not Result then
         goto lab30;
      end if;
      goto lab29;

      <<lab30>>
      Z.C := Z.L - v_10;
      --  call mark_lAr, line 325
      R_Mark_lAr (Z, Result);
      if not Result then
         goto lab31;
      end if;
      goto lab29;

      <<lab31>>
      Z.C := Z.L - v_10;
      --  call mark_yUm, line 325
      R_Mark_yUm (Z, Result);
      if not Result then
         goto lab32;
      end if;
      goto lab29;

      <<lab32>>
      Z.C := Z.L - v_10;
      --  call mark_sUn, line 325
      R_Mark_sUn (Z, Result);
      if not Result then
         goto lab33;
      end if;
      goto lab29;

      <<lab33>>
      Z.C := Z.L - v_10;
      --  call mark_yUz, line 325
      R_Mark_yUz (Z, Result);
      if not Result then
         goto lab34;
      end if;
      goto lab29;

      <<lab34>>
      Z.C := Z.L - v_10;

      <<lab29>>
      --  call mark_ymUs_, line 325
      R_Mark_ymUs_E (Z, Result);
      if not Result then
         Z.C := Z.L - v_9;
         goto lab28;
      end if;

      <<lab28>>

      <<lab0>>
      Z.Bra := Z.C;      --  ], line 326

      --  delete, line 326
      Slice_Del (Z);

      Result := True;
   end R_Stem_nominal_verb_suffixes;

   procedure R_Stem_suffix_chain_before_ki (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
      v_5 : Integer;
      v_6 : Integer;
      v_7 : Integer;
      v_8 : Integer;
      v_9 : Integer;
      v_10 : Integer;
      v_11 : Integer;
   begin
      --  (, line 330
      Z.Ket := Z.C;      --  [, line 331

      --  call mark_ki, line 332
      R_Mark_ki (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  (, line 333
      --  or, line 340
      v_1 := Z.L - Z.C;
      --  (, line 334
      --  call mark_DA, line 334
      R_Mark_DA (Z, Result);
      if not Result then
         goto lab1;
      end if;
      Z.Bra := Z.C;      --  ], line 334

      --  delete, line 334
      Slice_Del (Z);
      --  try, line 334
      v_2 := Z.L - Z.C;
      --  (, line 334
      Z.Ket := Z.C;      --  [, line 334

      --  or, line 336
      v_3 := Z.L - Z.C;
      --  (, line 335
      --  call mark_lAr, line 335
      R_Mark_lAr (Z, Result);
      if not Result then
         goto lab4;
      end if;
      Z.Bra := Z.C;      --  ], line 335

      --  delete, line 335
      Slice_Del (Z);
      --  try, line 335
      v_4 := Z.L - Z.C;
      --  (, line 335
      --  call stem_suffix_chain_before_ki, line 335
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_4;
         goto lab5;
      end if;

      <<lab5>>
      goto lab3;

      <<lab4>>
      Z.C := Z.L - v_3;
      --  (, line 337
      --  call mark_possessives, line 337
      R_Mark_possessives (Z, Result);
      if not Result then
         Z.C := Z.L - v_2;
         goto lab2;
      end if;
      Z.Bra := Z.C;      --  ], line 337

      --  delete, line 337
      Slice_Del (Z);
      --  try, line 337
      v_5 := Z.L - Z.C;
      --  (, line 337
      Z.Ket := Z.C;      --  [, line 337

      --  call mark_lAr, line 337
      R_Mark_lAr (Z, Result);
      if not Result then
         Z.C := Z.L - v_5;
         goto lab6;
      end if;
      Z.Bra := Z.C;      --  ], line 337

      --  delete, line 337
      Slice_Del (Z);
      --  call stem_suffix_chain_before_ki, line 337
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_5;
         goto lab6;
      end if;

      <<lab6>>

      <<lab3>>

      <<lab2>>
      goto lab0;

      <<lab1>>
      Z.C := Z.L - v_1;
      --  (, line 341
      --  call mark_nUn, line 341
      R_Mark_nUn (Z, Result);
      if not Result then
         goto lab7;
      end if;
      Z.Bra := Z.C;      --  ], line 341

      --  delete, line 341
      Slice_Del (Z);
      --  try, line 341
      v_6 := Z.L - Z.C;
      --  (, line 341
      Z.Ket := Z.C;      --  [, line 341

      --  or, line 343
      v_7 := Z.L - Z.C;
      --  (, line 342
      --  call mark_lArI, line 342
      R_Mark_lArI (Z, Result);
      if not Result then
         goto lab10;
      end if;
      Z.Bra := Z.C;      --  ], line 342

      --  delete, line 342
      Slice_Del (Z);
      goto lab9;

      <<lab10>>
      Z.C := Z.L - v_7;
      --  (, line 344
      Z.Ket := Z.C;      --  [, line 344

      --  or, line 344
      v_8 := Z.L - Z.C;
      --  call mark_possessives, line 344
      R_Mark_possessives (Z, Result);
      if not Result then
         goto lab13;
      end if;
      goto lab12;

      <<lab13>>
      Z.C := Z.L - v_8;
      --  call mark_sU, line 344
      R_Mark_sU (Z, Result);
      if not Result then
         goto lab11;
      end if;

      <<lab12>>
      Z.Bra := Z.C;      --  ], line 344

      --  delete, line 344
      Slice_Del (Z);
      --  try, line 344
      v_9 := Z.L - Z.C;
      --  (, line 344
      Z.Ket := Z.C;      --  [, line 344

      --  call mark_lAr, line 344
      R_Mark_lAr (Z, Result);
      if not Result then
         Z.C := Z.L - v_9;
         goto lab14;
      end if;
      Z.Bra := Z.C;      --  ], line 344

      --  delete, line 344
      Slice_Del (Z);
      --  call stem_suffix_chain_before_ki, line 344
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_9;
         goto lab14;
      end if;

      <<lab14>>
      goto lab9;

      <<lab11>>
      Z.C := Z.L - v_7;
      --  (, line 346
      --  call stem_suffix_chain_before_ki, line 346
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_6;
         goto lab8;
      end if;

      <<lab9>>

      <<lab8>>
      goto lab0;

      <<lab7>>
      Z.C := Z.L - v_1;
      --  (, line 349
      --  call mark_ndA, line 349
      R_Mark_ndA (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  (, line 349
      --  or, line 351
      v_10 := Z.L - Z.C;
      --  (, line 350
      --  call mark_lArI, line 350
      R_Mark_lArI (Z, Result);
      if not Result then
         goto lab16;
      end if;
      Z.Bra := Z.C;      --  ], line 350

      --  delete, line 350
      Slice_Del (Z);
      goto lab15;

      <<lab16>>
      Z.C := Z.L - v_10;
      --  (, line 352
      --  (, line 352
      --  call mark_sU, line 352
      R_Mark_sU (Z, Result);
      if not Result then
         goto lab17;
      end if;
      Z.Bra := Z.C;      --  ], line 352

      --  delete, line 352
      Slice_Del (Z);
      --  try, line 352
      v_11 := Z.L - Z.C;
      --  (, line 352
      Z.Ket := Z.C;      --  [, line 352

      --  call mark_lAr, line 352
      R_Mark_lAr (Z, Result);
      if not Result then
         Z.C := Z.L - v_11;
         goto lab18;
      end if;
      Z.Bra := Z.C;      --  ], line 352

      --  delete, line 352
      Slice_Del (Z);
      --  call stem_suffix_chain_before_ki, line 352
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_11;
         goto lab18;
      end if;

      <<lab18>>
      goto lab15;

      <<lab17>>
      Z.C := Z.L - v_10;
      --  (, line 354
      --  call stem_suffix_chain_before_ki, line 354
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      <<lab15>>

      <<lab0>>

      Result := True;
   end R_Stem_suffix_chain_before_ki;

   procedure R_Stem_noun_suffixes (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
      v_5 : Integer;
      v_6 : Integer;
      v_7 : Integer;
      v_8 : Integer;
      v_9 : Integer;
      v_10 : Integer;
      v_11 : Integer;
      v_12 : Integer;
      v_13 : Integer;
      v_14 : Integer;
      v_15 : Integer;
      v_16 : Integer;
      v_17 : Integer;
      v_18 : Integer;
      v_19 : Integer;
      v_20 : Integer;
      v_21 : Integer;
      v_22 : Integer;
      v_23 : Integer;
      v_24 : Integer;
      v_25 : Integer;
      v_26 : Integer;
      v_27 : Integer;
   begin
      --  (, line 359
      --  or, line 361
      v_1 := Z.L - Z.C;
      --  (, line 360
      Z.Ket := Z.C;      --  [, line 360

      --  call mark_lAr, line 360
      R_Mark_lAr (Z, Result);
      if not Result then
         goto lab1;
      end if;
      Z.Bra := Z.C;      --  ], line 360

      --  delete, line 360
      Slice_Del (Z);
      --  try, line 360
      v_2 := Z.L - Z.C;
      --  (, line 360
      --  call stem_suffix_chain_before_ki, line 360
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_2;
         goto lab2;
      end if;

      <<lab2>>
      goto lab0;

      <<lab1>>
      Z.C := Z.L - v_1;
      --  (, line 362
      Z.Ket := Z.C;      --  [, line 362

      --  call mark_ncA, line 362
      R_Mark_ncA (Z, Result);
      if not Result then
         goto lab3;
      end if;
      Z.Bra := Z.C;      --  ], line 362

      --  delete, line 362
      Slice_Del (Z);
      --  try, line 363
      v_3 := Z.L - Z.C;
      --  (, line 363
      --  or, line 365
      v_4 := Z.L - Z.C;
      --  (, line 364
      Z.Ket := Z.C;      --  [, line 364

      --  call mark_lArI, line 364
      R_Mark_lArI (Z, Result);
      if not Result then
         goto lab6;
      end if;
      Z.Bra := Z.C;      --  ], line 364

      --  delete, line 364
      Slice_Del (Z);
      goto lab5;

      <<lab6>>
      Z.C := Z.L - v_4;
      --  (, line 366
      Z.Ket := Z.C;      --  [, line 366

      --  or, line 366
      v_5 := Z.L - Z.C;
      --  call mark_possessives, line 366
      R_Mark_possessives (Z, Result);
      if not Result then
         goto lab9;
      end if;
      goto lab8;

      <<lab9>>
      Z.C := Z.L - v_5;
      --  call mark_sU, line 366
      R_Mark_sU (Z, Result);
      if not Result then
         goto lab7;
      end if;

      <<lab8>>
      Z.Bra := Z.C;      --  ], line 366

      --  delete, line 366
      Slice_Del (Z);
      --  try, line 366
      v_6 := Z.L - Z.C;
      --  (, line 366
      Z.Ket := Z.C;      --  [, line 366

      --  call mark_lAr, line 366
      R_Mark_lAr (Z, Result);
      if not Result then
         Z.C := Z.L - v_6;
         goto lab10;
      end if;
      Z.Bra := Z.C;      --  ], line 366

      --  delete, line 366
      Slice_Del (Z);
      --  call stem_suffix_chain_before_ki, line 366
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_6;
         goto lab10;
      end if;

      <<lab10>>
      goto lab5;

      <<lab7>>
      Z.C := Z.L - v_4;
      --  (, line 368
      Z.Ket := Z.C;      --  [, line 368

      --  call mark_lAr, line 368
      R_Mark_lAr (Z, Result);
      if not Result then
         Z.C := Z.L - v_3;
         goto lab4;
      end if;
      Z.Bra := Z.C;      --  ], line 368

      --  delete, line 368
      Slice_Del (Z);
      --  call stem_suffix_chain_before_ki, line 368
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_3;
         goto lab4;
      end if;

      <<lab5>>

      <<lab4>>
      goto lab0;

      <<lab3>>
      Z.C := Z.L - v_1;
      --  (, line 372
      Z.Ket := Z.C;      --  [, line 372

      --  (, line 372
      --  or, line 372
      v_7 := Z.L - Z.C;
      --  call mark_ndA, line 372
      R_Mark_ndA (Z, Result);
      if not Result then
         goto lab13;
      end if;
      goto lab12;

      <<lab13>>
      Z.C := Z.L - v_7;
      --  call mark_nA, line 372
      R_Mark_nA (Z, Result);
      if not Result then
         goto lab11;
      end if;

      <<lab12>>
      --  (, line 373
      --  or, line 375
      v_8 := Z.L - Z.C;
      --  (, line 374
      --  call mark_lArI, line 374
      R_Mark_lArI (Z, Result);
      if not Result then
         goto lab15;
      end if;
      Z.Bra := Z.C;      --  ], line 374

      --  delete, line 374
      Slice_Del (Z);
      goto lab14;

      <<lab15>>
      Z.C := Z.L - v_8;
      --  (, line 376
      --  call mark_sU, line 376
      R_Mark_sU (Z, Result);
      if not Result then
         goto lab16;
      end if;
      Z.Bra := Z.C;      --  ], line 376

      --  delete, line 376
      Slice_Del (Z);
      --  try, line 376
      v_9 := Z.L - Z.C;
      --  (, line 376
      Z.Ket := Z.C;      --  [, line 376

      --  call mark_lAr, line 376
      R_Mark_lAr (Z, Result);
      if not Result then
         Z.C := Z.L - v_9;
         goto lab17;
      end if;
      Z.Bra := Z.C;      --  ], line 376

      --  delete, line 376
      Slice_Del (Z);
      --  call stem_suffix_chain_before_ki, line 376
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_9;
         goto lab17;
      end if;

      <<lab17>>
      goto lab14;

      <<lab16>>
      Z.C := Z.L - v_8;
      --  (, line 378
      --  call stem_suffix_chain_before_ki, line 378
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         goto lab11;
      end if;

      <<lab14>>
      goto lab0;

      <<lab11>>
      Z.C := Z.L - v_1;
      --  (, line 382
      Z.Ket := Z.C;      --  [, line 382

      --  (, line 382
      --  or, line 382
      v_10 := Z.L - Z.C;
      --  call mark_ndAn, line 382
      R_Mark_ndAn (Z, Result);
      if not Result then
         goto lab20;
      end if;
      goto lab19;

      <<lab20>>
      Z.C := Z.L - v_10;
      --  call mark_nU, line 382
      R_Mark_nU (Z, Result);
      if not Result then
         goto lab18;
      end if;

      <<lab19>>
      --  (, line 382
      --  or, line 382
      v_11 := Z.L - Z.C;
      --  (, line 382
      --  call mark_sU, line 382
      R_Mark_sU (Z, Result);
      if not Result then
         goto lab22;
      end if;
      Z.Bra := Z.C;      --  ], line 382

      --  delete, line 382
      Slice_Del (Z);
      --  try, line 382
      v_12 := Z.L - Z.C;
      --  (, line 382
      Z.Ket := Z.C;      --  [, line 382

      --  call mark_lAr, line 382
      R_Mark_lAr (Z, Result);
      if not Result then
         Z.C := Z.L - v_12;
         goto lab23;
      end if;
      Z.Bra := Z.C;      --  ], line 382

      --  delete, line 382
      Slice_Del (Z);
      --  call stem_suffix_chain_before_ki, line 382
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_12;
         goto lab23;
      end if;

      <<lab23>>
      goto lab21;

      <<lab22>>
      Z.C := Z.L - v_11;
      --  (, line 382
      --  call mark_lArI, line 382
      R_Mark_lArI (Z, Result);
      if not Result then
         goto lab18;
      end if;

      <<lab21>>
      goto lab0;

      <<lab18>>
      Z.C := Z.L - v_1;
      --  (, line 384
      Z.Ket := Z.C;      --  [, line 384

      --  call mark_DAn, line 384
      R_Mark_DAn (Z, Result);
      if not Result then
         goto lab24;
      end if;
      Z.Bra := Z.C;      --  ], line 384

      --  delete, line 384
      Slice_Del (Z);
      --  try, line 384
      v_13 := Z.L - Z.C;
      --  (, line 384
      Z.Ket := Z.C;      --  [, line 384

      --  (, line 385
      --  or, line 387
      v_14 := Z.L - Z.C;
      --  (, line 386
      --  call mark_possessives, line 386
      R_Mark_possessives (Z, Result);
      if not Result then
         goto lab27;
      end if;
      Z.Bra := Z.C;      --  ], line 386

      --  delete, line 386
      Slice_Del (Z);
      --  try, line 386
      v_15 := Z.L - Z.C;
      --  (, line 386
      Z.Ket := Z.C;      --  [, line 386

      --  call mark_lAr, line 386
      R_Mark_lAr (Z, Result);
      if not Result then
         Z.C := Z.L - v_15;
         goto lab28;
      end if;
      Z.Bra := Z.C;      --  ], line 386

      --  delete, line 386
      Slice_Del (Z);
      --  call stem_suffix_chain_before_ki, line 386
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_15;
         goto lab28;
      end if;

      <<lab28>>
      goto lab26;

      <<lab27>>
      Z.C := Z.L - v_14;
      --  (, line 388
      --  call mark_lAr, line 388
      R_Mark_lAr (Z, Result);
      if not Result then
         goto lab29;
      end if;
      Z.Bra := Z.C;      --  ], line 388

      --  delete, line 388
      Slice_Del (Z);
      --  try, line 388
      v_16 := Z.L - Z.C;
      --  (, line 388
      --  call stem_suffix_chain_before_ki, line 388
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_16;
         goto lab30;
      end if;

      <<lab30>>
      goto lab26;

      <<lab29>>
      Z.C := Z.L - v_14;
      --  (, line 390
      --  call stem_suffix_chain_before_ki, line 390
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_13;
         goto lab25;
      end if;

      <<lab26>>

      <<lab25>>
      goto lab0;

      <<lab24>>
      Z.C := Z.L - v_1;
      --  (, line 394
      Z.Ket := Z.C;      --  [, line 394

      --  or, line 394
      v_17 := Z.L - Z.C;
      --  call mark_nUn, line 394
      R_Mark_nUn (Z, Result);
      if not Result then
         goto lab33;
      end if;
      goto lab32;

      <<lab33>>
      Z.C := Z.L - v_17;
      --  call mark_ylA, line 394
      R_Mark_ylA (Z, Result);
      if not Result then
         goto lab31;
      end if;

      <<lab32>>
      Z.Bra := Z.C;      --  ], line 394

      --  delete, line 394
      Slice_Del (Z);
      --  try, line 395
      v_18 := Z.L - Z.C;
      --  (, line 395
      --  or, line 397
      v_19 := Z.L - Z.C;
      --  (, line 396
      Z.Ket := Z.C;      --  [, line 396

      --  call mark_lAr, line 396
      R_Mark_lAr (Z, Result);
      if not Result then
         goto lab36;
      end if;
      Z.Bra := Z.C;      --  ], line 396

      --  delete, line 396
      Slice_Del (Z);
      --  call stem_suffix_chain_before_ki, line 396
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         goto lab36;
      end if;
      goto lab35;

      <<lab36>>
      Z.C := Z.L - v_19;
      --  (, line 398
      Z.Ket := Z.C;      --  [, line 398

      --  or, line 398
      v_20 := Z.L - Z.C;
      --  call mark_possessives, line 398
      R_Mark_possessives (Z, Result);
      if not Result then
         goto lab39;
      end if;
      goto lab38;

      <<lab39>>
      Z.C := Z.L - v_20;
      --  call mark_sU, line 398
      R_Mark_sU (Z, Result);
      if not Result then
         goto lab37;
      end if;

      <<lab38>>
      Z.Bra := Z.C;      --  ], line 398

      --  delete, line 398
      Slice_Del (Z);
      --  try, line 398
      v_21 := Z.L - Z.C;
      --  (, line 398
      Z.Ket := Z.C;      --  [, line 398

      --  call mark_lAr, line 398
      R_Mark_lAr (Z, Result);
      if not Result then
         Z.C := Z.L - v_21;
         goto lab40;
      end if;
      Z.Bra := Z.C;      --  ], line 398

      --  delete, line 398
      Slice_Del (Z);
      --  call stem_suffix_chain_before_ki, line 398
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_21;
         goto lab40;
      end if;

      <<lab40>>
      goto lab35;

      <<lab37>>
      Z.C := Z.L - v_19;
      --  call stem_suffix_chain_before_ki, line 400
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_18;
         goto lab34;
      end if;

      <<lab35>>

      <<lab34>>
      goto lab0;

      <<lab31>>
      Z.C := Z.L - v_1;
      --  (, line 404
      Z.Ket := Z.C;      --  [, line 404

      --  call mark_lArI, line 404
      R_Mark_lArI (Z, Result);
      if not Result then
         goto lab41;
      end if;
      Z.Bra := Z.C;      --  ], line 404

      --  delete, line 404
      Slice_Del (Z);
      goto lab0;

      <<lab41>>
      Z.C := Z.L - v_1;
      --  (, line 406
      --  call stem_suffix_chain_before_ki, line 406
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         goto lab42;
      end if;
      goto lab0;

      <<lab42>>
      Z.C := Z.L - v_1;
      --  (, line 408
      Z.Ket := Z.C;      --  [, line 408

      --  or, line 408
      v_22 := Z.L - Z.C;
      --  call mark_DA, line 408
      R_Mark_DA (Z, Result);
      if not Result then
         goto lab45;
      end if;
      goto lab44;

      <<lab45>>
      Z.C := Z.L - v_22;
      --  call mark_yU, line 408
      R_Mark_yU (Z, Result);
      if not Result then
         goto lab46;
      end if;
      goto lab44;

      <<lab46>>
      Z.C := Z.L - v_22;
      --  call mark_yA, line 408
      R_Mark_yA (Z, Result);
      if not Result then
         goto lab43;
      end if;

      <<lab44>>
      Z.Bra := Z.C;      --  ], line 408

      --  delete, line 408
      Slice_Del (Z);
      --  try, line 408
      v_23 := Z.L - Z.C;
      --  (, line 408
      Z.Ket := Z.C;      --  [, line 408

      --  (, line 408
      --  or, line 408
      v_24 := Z.L - Z.C;
      --  (, line 408
      --  call mark_possessives, line 408
      R_Mark_possessives (Z, Result);
      if not Result then
         goto lab49;
      end if;
      Z.Bra := Z.C;      --  ], line 408

      --  delete, line 408
      Slice_Del (Z);
      --  try, line 408
      v_25 := Z.L - Z.C;
      --  (, line 408
      Z.Ket := Z.C;      --  [, line 408

      --  call mark_lAr, line 408
      R_Mark_lAr (Z, Result);
      if not Result then
         Z.C := Z.L - v_25;
         goto lab50;
      end if;

      <<lab50>>
      goto lab48;

      <<lab49>>
      Z.C := Z.L - v_24;
      --  call mark_lAr, line 408
      R_Mark_lAr (Z, Result);
      if not Result then
         Z.C := Z.L - v_23;
         goto lab47;
      end if;

      <<lab48>>
      Z.Bra := Z.C;      --  ], line 408

      --  delete, line 408
      Slice_Del (Z);
      Z.Ket := Z.C;      --  [, line 408

      --  call stem_suffix_chain_before_ki, line 408
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_23;
         goto lab47;
      end if;

      <<lab47>>
      goto lab0;

      <<lab43>>
      Z.C := Z.L - v_1;
      --  (, line 410
      Z.Ket := Z.C;      --  [, line 410

      --  or, line 410
      v_26 := Z.L - Z.C;
      --  call mark_possessives, line 410
      R_Mark_possessives (Z, Result);
      if not Result then
         goto lab52;
      end if;
      goto lab51;

      <<lab52>>
      Z.C := Z.L - v_26;
      --  call mark_sU, line 410
      R_Mark_sU (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      <<lab51>>
      Z.Bra := Z.C;      --  ], line 410

      --  delete, line 410
      Slice_Del (Z);
      --  try, line 410
      v_27 := Z.L - Z.C;
      --  (, line 410
      Z.Ket := Z.C;      --  [, line 410

      --  call mark_lAr, line 410
      R_Mark_lAr (Z, Result);
      if not Result then
         Z.C := Z.L - v_27;
         goto lab53;
      end if;
      Z.Bra := Z.C;      --  ], line 410

      --  delete, line 410
      Slice_Del (Z);
      --  call stem_suffix_chain_before_ki, line 410
      R_Stem_suffix_chain_before_ki (Z, Result);
      if not Result then
         Z.C := Z.L - v_27;
         goto lab53;
      end if;

      <<lab53>>

      <<lab0>>

      Result := True;
   end R_Stem_noun_suffixes;

   procedure R_Post_process_last_consonants (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 413
      Z.Ket := Z.C;      --  [, line 414

      --  substring, line 414
      Find_Among_Backward (Z, A_23, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 414

      --  among, line 414
      case A is
         when 1 =>
            --  (, line 415
            --  <-, line 415
            Slice_From (Z, "p");
         when 2 =>
            --  (, line 416
            --  <-, line 416
            Slice_From (Z, "ç");
         when 3 =>
            --  (, line 417
            --  <-, line 417
            Slice_From (Z, "t");
         when 4 =>
            --  (, line 418
            --  <-, line 418
            Slice_From (Z, "k");
         when others =>
            null;
      end case;

      Result := True;
   end R_Post_process_last_consonants;

   procedure R_Append_U_to_stems_ending_with_d_or_g (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
      v_5 : Integer;
      v_6 : Integer;
      v_7 : Integer;
      v_8 : Integer;
      v_9 : Integer;
      v_10 : Integer;
      v_11 : Integer;
   begin
      --  (, line 428
      --  test, line 429
      v_1 := Z.L - Z.C;
      --  (, line 429
      --  or, line 429
      v_2 := Z.L - Z.C;
      --  literal, line 429
      C := Eq_S_Backward (Z, "d");
      if C = 0 then
         goto lab1;
      end if;
      Z.C := Z.C - C;
      goto lab0;

      <<lab1>>
      Z.C := Z.L - v_2;
      --  literal, line 429
      C := Eq_S_Backward (Z, "g");
      if C = 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C - C;

      <<lab0>>
      Z.C := Z.L - v_1;
      --  or, line 431
      v_3 := Z.L - Z.C;
      --  (, line 430
      --  test, line 430
      v_4 := Z.L - Z.C;
      --  (, line 430
      --  (, line 430
            --  goto, line 430
      Out_Grouping_Backward (Z, G_Vowel, 97, 305, True, C);      if C < 0 then
         goto lab3;
      end if;
      --  or, line 430
      v_5 := Z.L - Z.C;
      --  literal, line 430
      C := Eq_S_Backward (Z, "a");
      if C = 0 then
         goto lab6;
      end if;
      Z.C := Z.C - C;
      goto lab5;

      <<lab6>>
      Z.C := Z.L - v_5;
      --  literal, line 430
      C := Eq_S_Backward (Z, "ı");
      if C = 0 then
         goto lab3;
      end if;
      Z.C := Z.C - C;

      <<lab5>>
      Z.C := Z.L - v_4;
      --  <+, line 430
      C := Z.C;
      Insert (Z, Z.C, Z.C, "ı");
      Z.C := C;
      goto lab2;

      <<lab3>>
      Z.C := Z.L - v_3;
      --  (, line 432
      --  test, line 432
      v_6 := Z.L - Z.C;
      --  (, line 432
      --  (, line 432
            --  goto, line 432
      Out_Grouping_Backward (Z, G_Vowel, 97, 305, True, C);      if C < 0 then
         goto lab7;
      end if;
      --  or, line 432
      v_7 := Z.L - Z.C;
      --  literal, line 432
      C := Eq_S_Backward (Z, "e");
      if C = 0 then
         goto lab10;
      end if;
      Z.C := Z.C - C;
      goto lab9;

      <<lab10>>
      Z.C := Z.L - v_7;
      --  literal, line 432
      C := Eq_S_Backward (Z, "i");
      if C = 0 then
         goto lab7;
      end if;
      Z.C := Z.C - C;

      <<lab9>>
      Z.C := Z.L - v_6;
      --  <+, line 432
      C := Z.C;
      Insert (Z, Z.C, Z.C, "i");
      Z.C := C;
      goto lab2;

      <<lab7>>
      Z.C := Z.L - v_3;
      --  (, line 434
      --  test, line 434
      v_8 := Z.L - Z.C;
      --  (, line 434
      --  (, line 434
            --  goto, line 434
      Out_Grouping_Backward (Z, G_Vowel, 97, 305, True, C);      if C < 0 then
         goto lab11;
      end if;
      --  or, line 434
      v_9 := Z.L - Z.C;
      --  literal, line 434
      C := Eq_S_Backward (Z, "o");
      if C = 0 then
         goto lab14;
      end if;
      Z.C := Z.C - C;
      goto lab13;

      <<lab14>>
      Z.C := Z.L - v_9;
      --  literal, line 434
      C := Eq_S_Backward (Z, "u");
      if C = 0 then
         goto lab11;
      end if;
      Z.C := Z.C - C;

      <<lab13>>
      Z.C := Z.L - v_8;
      --  <+, line 434
      C := Z.C;
      Insert (Z, Z.C, Z.C, "u");
      Z.C := C;
      goto lab2;

      <<lab11>>
      Z.C := Z.L - v_3;
      --  (, line 436
      --  test, line 436
      v_10 := Z.L - Z.C;
      --  (, line 436
      --  (, line 436
            --  goto, line 436
      Out_Grouping_Backward (Z, G_Vowel, 97, 305, True, C);      if C < 0 then
         Result := False;
         return;
      end if;
      --  or, line 436
      v_11 := Z.L - Z.C;
      --  literal, line 436
      C := Eq_S_Backward (Z, "ö");
      if C = 0 then
         goto lab17;
      end if;
      Z.C := Z.C - C;
      goto lab16;

      <<lab17>>
      Z.C := Z.L - v_11;
      --  literal, line 436
      C := Eq_S_Backward (Z, "ü");
      if C = 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C - C;

      <<lab16>>
      Z.C := Z.L - v_10;
      --  <+, line 436
      C := Z.C;
      Insert (Z, Z.C, Z.C, "ü");
      Z.C := C;

      <<lab2>>

      Result := True;
   end R_Append_U_to_stems_ending_with_d_or_g;

   procedure R_Is_reserved_word (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
   begin
      --  (, line 439
      --  literal, line 440
      C := Eq_S_Backward (Z, "ad");
      if C = 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C - C;
      --  try, line 440
      v_1 := Z.L - Z.C;
      --  literal, line 440
      C := Eq_S_Backward (Z, "soy");
      if C = 0 then
         Z.C := Z.L - v_1;
         goto lab0;
      end if;
      Z.C := Z.C - C;

      <<lab0>>
      --  atlimit, line 440
      if Z.C > Z.Lb then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Is_reserved_word;

   procedure R_More_than_one_syllable_word (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
   begin
      --  (, line 446
      --  test, line 447
      v_1 := Z.C;
      --  (, line 447
      --  atleast, line 447
      begin
         v_2 := 2;

         <<lab0>>

         loop
            v_3 := Z.C;
            --  (, line 447
                        --  gopast, line 447
            --  grouping vowel, line 447
            Out_Grouping (Z, G_Vowel, 97, 305, True, C);
            if C < 0 then
               goto lab1;
            end if;
            Z.C := Z.C + C;
            v_2 := v_2 - 1;
            goto lab0;

            <<lab1>>
            Z.C := v_3;

            exit;
         end loop;
         if v_2 > 0 then
            Result := False;
            return;
         end if;
      end;
      Z.C := v_1;

      Result := True;
   end R_More_than_one_syllable_word;

   procedure R_Postlude (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
   begin
      --  (, line 450
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 451

      --  (, line 451
      --  not, line 452
      v_1 := Z.L - Z.C;
      --  (, line 452
      --  call is_reserved_word, line 452
      R_Is_reserved_word (Z, Result);
      if not Result then
         goto lab0;
      end if;
      Result := False;
      return;

      <<lab0>>
      Z.C := Z.L - v_1;
      --  do, line 453
      v_2 := Z.L - Z.C;
      --  call append_U_to_stems_ending_with_d_or_g, line 453
      R_Append_U_to_stems_ending_with_d_or_g (Z, Result);
      Z.C := Z.L - v_2;
      --  do, line 454
      v_3 := Z.L - Z.C;
      --  call post_process_last_consonants, line 454
      R_Post_process_last_consonants (Z, Result);
      Z.C := Z.L - v_3;
      Z.C := Z.Lb;

      Result := True;
   end R_Postlude;

   procedure Stem (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
   begin
      --  (, line 459
      --  (, line 460
      --  call more_than_one_syllable_word, line 460
      R_More_than_one_syllable_word (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  (, line 461
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 462

      --  (, line 462
      --  do, line 463
      v_1 := Z.L - Z.C;
      --  call stem_nominal_verb_suffixes, line 463
      R_Stem_nominal_verb_suffixes (Z, Result);
      Z.C := Z.L - v_1;
      --  Boolean test continue_stemming_noun_suffixes, line 464
      if not Z.B_Continue_stemming_noun_suffixes then
         Result := False;
         return;
      end if;
      --  do, line 465
      v_2 := Z.L - Z.C;
      --  call stem_noun_suffixes, line 465
      R_Stem_noun_suffixes (Z, Result);
      Z.C := Z.L - v_2;
      Z.C := Z.Lb;
      --  call postlude, line 468
      R_Postlude (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end Stem;
end Stemmer.Turkish;
