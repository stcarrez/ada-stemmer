--  Generated by Snowball 2.0.0 - https://snowballstem.org/

package body Stemmer.Swedish is

   pragma Style_Checks ("-mr");
   pragma Warnings (Off, "*variable*is never read and never assigned*");
   pragma Warnings (Off, "*mode could be*instead of*");
   pragma Warnings (Off, "*formal parameter.*is not modified*");
   pragma Warnings (Off, "*this line is too long*");
   pragma Warnings (Off, "*is not referenced*");

   procedure R_Other_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Consonant_pair (Z : in out Context_Type; Result : out Boolean);
   procedure R_Main_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean);

   G_V : constant Grouping_Array (0 .. 151) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      True, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, True, True, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, True, False, False
   );

   G_S_ending : constant Grouping_Array (0 .. 23) := (
      True, True, True, False, True, True, True, False,
      True, True, True, True, True, True, True, False,
      True, False, True, False, True, False, False, True
   );
   Among_String : constant String := "a" & "arna" & "erna" & "heterna"
      & "orna" & "ad" & "e" & "ade" & "ande" & "arne" & "are" & "aste" & "en" & "anden"
      & "aren" & "heten" & "ern" & "ar" & "er" & "heter" & "or" & "s" & "as" & "arnas"
      & "ernas" & "ornas" & "es" & "ades" & "andes" & "ens" & "arens" & "hetens"
      & "erns" & "at" & "andet" & "het" & "ast" & "dd" & "gd" & "nn" & "dt" & "gt"
      & "kt" & "tt" & "ig" & "lig" & "els" & "fullt" & "löst";

   A_0 : constant Among_Array_Type (0 .. 36) := (
      (1, 1, -1, 1, 0),
      (2, 5, 0, 1, 0),
      (6, 9, 0, 1, 0),
      (10, 16, 2, 1, 0),
      (17, 20, 0, 1, 0),
      (21, 22, -1, 1, 0),
      (23, 23, -1, 1, 0),
      (24, 26, 6, 1, 0),
      (27, 30, 6, 1, 0),
      (31, 34, 6, 1, 0),
      (35, 37, 6, 1, 0),
      (38, 41, 6, 1, 0),
      (42, 43, -1, 1, 0),
      (44, 48, 12, 1, 0),
      (49, 52, 12, 1, 0),
      (53, 57, 12, 1, 0),
      (58, 60, -1, 1, 0),
      (61, 62, -1, 1, 0),
      (63, 64, -1, 1, 0),
      (65, 69, 18, 1, 0),
      (70, 71, -1, 1, 0),
      (72, 72, -1, 2, 0),
      (73, 74, 21, 1, 0),
      (75, 79, 22, 1, 0),
      (80, 84, 22, 1, 0),
      (85, 89, 22, 1, 0),
      (90, 91, 21, 1, 0),
      (92, 95, 26, 1, 0),
      (96, 100, 26, 1, 0),
      (101, 103, 21, 1, 0),
      (104, 108, 29, 1, 0),
      (109, 114, 29, 1, 0),
      (115, 118, 21, 1, 0),
      (119, 120, -1, 1, 0),
      (121, 125, -1, 1, 0),
      (126, 128, -1, 1, 0),
      (129, 131, -1, 1, 0));

   A_1 : constant Among_Array_Type (0 .. 6) := (
      (132, 133, -1, -1, 0),
      (134, 135, -1, -1, 0),
      (136, 137, -1, -1, 0),
      (138, 139, -1, -1, 0),
      (140, 141, -1, -1, 0),
      (142, 143, -1, -1, 0),
      (144, 145, -1, -1, 0));

   A_2 : constant Among_Array_Type (0 .. 4) := (
      (146, 147, -1, 1, 0),
      (148, 150, 0, 1, 0),
      (151, 153, -1, 1, 0),
      (154, 158, -1, 3, 0),
      (159, 163, -1, 2, 0));


   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
   begin
      --  (, line 26
      Z.I_P1 := Z.L;
      --  test, line 29
      v_1 := Z.C;
      --  (, line 29
      C := Skip_Utf8 (Z, 3);      --  hop, line 29

      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      --  setmark x, line 29
      Z.I_X := Z.C;
      Z.C := v_1;
            --  goto, line 30
      Out_Grouping (Z, G_V, 97, 246, True, C);      if C < 0 then
         Result := False;
         return;
      end if;
            --  gopast, line 30
      --  non v, line 30
      In_Grouping (Z, G_V, 97, 246, True, C);
      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C + C;
      --  setmark p1, line 30
      Z.I_P1 := Z.C;
      --  try, line 31
      --  (, line 31
      if not (Z.I_P1 < Z.I_X) then
         goto lab2;
      end if;
      Z.I_P1 := Z.I_X;

      <<lab2>>

      Result := True;
   end R_Mark_regions;

   procedure R_Main_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_2 : Integer;
   begin
      --  (, line 36
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 37
      Z.Ket := Z.C;      --  [, line 37

      --  substring, line 37
      if Z.C <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#1c4032#) then
         Z.Lb := v_2;
         Result := False;
         return;
         --  substring, line 37
      end if;
      Find_Among_Backward (Z, A_0, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 37

      Z.Lb := v_2;
      --  among, line 38
      case A is
         when 1 =>
            --  (, line 44
            --  delete, line 44
            Slice_Del (Z);
         when 2 =>
            --  (, line 46
            In_Grouping_Backward (Z, G_S_ending, 98, 121, False, C);
            if C /= 0 then
               Result := False;
               return;
            end if;
            --  delete, line 46
            Slice_Del (Z);
         when others =>
            null;
      end case;

      Result := True;
   end R_Main_suffix;

   procedure R_Consonant_pair (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_2 : Integer;
      v_3 : Integer;
   begin
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 50
      --  and, line 52
      v_3 := Z.L - Z.C;
      --  among, line 51
      if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#104010#) then
         Z.Lb := v_2;
         Result := False;
         return;
         --  among, line 51
      end if;
      Find_Among_Backward (Z, A_1, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.C := Z.L - v_3;
      --  (, line 52
      Z.Ket := Z.C;      --  [, line 52

      --  next, line 52
      C := Skip_Utf8_Backward (Z, 1);      if C < 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.C := C;
      Z.Bra := Z.C;      --  ], line 52

      --  delete, line 52
      Slice_Del (Z);
      Z.Lb := v_2;

      Result := True;
   end R_Consonant_pair;

   procedure R_Other_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_2 : Integer;
   begin
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 55
      Z.Ket := Z.C;      --  [, line 56

      --  substring, line 56
      if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#180080#) then
         Z.Lb := v_2;
         Result := False;
         return;
         --  substring, line 56
      end if;
      Find_Among_Backward (Z, A_2, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 56

      --  among, line 56
      case A is
         when 1 =>
            --  (, line 57
            --  delete, line 57
            Slice_Del (Z);
         when 2 =>
            --  (, line 58
            --  <-, line 58
            Slice_From (Z, "lös");
         when 3 =>
            --  (, line 59
            --  <-, line 59
            Slice_From (Z, "full");
         when others =>
            null;
      end case;
      Z.Lb := v_2;

      Result := True;
   end R_Other_suffix;

   procedure Stem (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
   begin
      --  (, line 64
      --  do, line 66
      v_1 := Z.C;
      --  call mark_regions, line 66
      R_Mark_regions (Z, Result);
      Z.C := v_1;
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 67

      --  (, line 67
      --  do, line 68
      v_2 := Z.L - Z.C;
      --  call main_suffix, line 68
      R_Main_suffix (Z, Result);
      Z.C := Z.L - v_2;
      --  do, line 69
      v_3 := Z.L - Z.C;
      --  call consonant_pair, line 69
      R_Consonant_pair (Z, Result);
      Z.C := Z.L - v_3;
      --  do, line 70
      v_4 := Z.L - Z.C;
      --  call other_suffix, line 70
      R_Other_suffix (Z, Result);
      Z.C := Z.L - v_4;
      Z.C := Z.Lb;

      Result := True;
   end Stem;
end Stemmer.Swedish;
