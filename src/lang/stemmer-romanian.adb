--  Generated by Snowball 2.0.0 - https://snowballstem.org/

package body Stemmer.Romanian is

   pragma Style_Checks ("-mr");
   pragma Warnings (Off, "*variable*is never read and never assigned*");
   pragma Warnings (Off, "*mode could be*instead of*");
   pragma Warnings (Off, "*formal parameter.*is not modified*");
   pragma Warnings (Off, "*this line is too long*");
   pragma Warnings (Off, "*is not referenced*");

   procedure R_Vowel_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Verb_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Combo_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Standard_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Step_0 (Z : in out Context_Type; Result : out Boolean);
   procedure R_R2 (Z : in out Context_Type; Result : out Boolean);
   procedure R_R1 (Z : in out Context_Type; Result : out Boolean);
   procedure R_RV (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean);
   procedure R_Postlude (Z : in out Context_Type; Result : out Boolean);
   procedure R_Prelude (Z : in out Context_Type; Result : out Boolean);

   G_V : constant Grouping_Array (0 .. 167) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, True, False, False, False, False, False, False,
      False, False, False, False, False, True, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, True, False, False, False, False, False
   );
   Among_String : constant String := "" & "I" & "U" & "ea" & "aţia" & "aua" & "iua" & "aţie" & "ele" & "ile" & "iile"
      & "iei" & "atei" & "ii" & "ului" & "ul" & "elor" & "ilor" & "iilor" & "icala"
      & "iciva" & "ativa" & "itiva" & "icale" & "aţiune" & "iţiune" & "atoare"
      & "itoare" & "ătoare" & "icitate" & "abilitate" & "ibilitate" & "ivitate"
      & "icive" & "ative" & "itive" & "icali" & "atori" & "icatori" & "itori"
      & "ători" & "icitati" & "abilitati" & "ivitati" & "icivi" & "ativi" & "itivi"
      & "icităi" & "abilităi" & "ivităi" & "icităţi" & "abilităţi" & "ivităţi"
      & "ical" & "ator" & "icator" & "itor" & "ător" & "iciv" & "ativ" & "itiv"
      & "icală" & "icivă" & "ativă" & "itivă" & "ica" & "abila" & "ibila" & "oasa"
      & "ata" & "ita" & "anta" & "ista" & "uta" & "iva" & "ic" & "ice" & "abile"
      & "ibile" & "isme" & "iune" & "oase" & "ate" & "itate" & "ite" & "ante" & "iste"
      & "ute" & "ive" & "ici" & "abili" & "ibili" & "iuni" & "atori" & "osi" & "ati"
      & "itati" & "iti" & "anti" & "isti" & "uti" & "işti" & "ivi" & "ităi" & "oşi"
      & "ităţi" & "abil" & "ibil" & "ism" & "ator" & "os" & "at" & "it" & "ant"
      & "ist" & "ut" & "iv" & "ică" & "abilă" & "ibilă" & "oasă" & "ată" & "ită"
      & "antă" & "istă" & "ută" & "ivă" & "ea" & "ia" & "esc" & "ăsc" & "ind"
      & "ând" & "are" & "ere" & "ire" & "âre" & "se" & "ase" & "sese" & "ise" & "use"
      & "âse" & "eşte" & "ăşte" & "eze" & "ai" & "eai" & "iai" & "sei" & "eşti"
      & "ăşti" & "ui" & "ezi" & "aşi" & "seşi" & "aseşi" & "seseşi" & "iseşi"
      & "useşi" & "âseşi" & "işi" & "uşi" & "âşi" & "âi" & "aţi" & "eaţi"
      & "iaţi" & "eţi" & "iţi" & "arăţi" & "serăţi" & "aserăţi" & "seserăţi"
      & "iserăţi" & "userăţi" & "âserăţi" & "irăţi" & "urăţi" & "ârăţi"
      & "âţi" & "am" & "eam" & "iam" & "em" & "asem" & "sesem" & "isem" & "usem"
      & "âsem" & "im" & "ăm" & "arăm" & "serăm" & "aserăm" & "seserăm"
      & "iserăm" & "userăm" & "âserăm" & "irăm" & "urăm" & "ârăm" & "âm"
      & "au" & "eau" & "iau" & "indu" & "ându" & "ez" & "ească" & "ară" & "seră"
      & "aseră" & "seseră" & "iseră" & "useră" & "âseră" & "iră" & "ură"
      & "âră" & "ează" & "a" & "e" & "ie" & "i" & "ă";

   A_0 : constant Among_Array_Type (0 .. 2) := (
      (1, 0, -1, 3, 0),
      (1, 1, 0, 1, 0),
      (2, 2, 0, 2, 0));

   A_1 : constant Among_Array_Type (0 .. 15) := (
      (3, 4, -1, 3, 0),
      (5, 9, -1, 7, 0),
      (10, 12, -1, 2, 0),
      (13, 15, -1, 4, 0),
      (16, 20, -1, 7, 0),
      (21, 23, -1, 3, 0),
      (24, 26, -1, 5, 0),
      (27, 30, 6, 4, 0),
      (31, 33, -1, 4, 0),
      (34, 37, -1, 6, 0),
      (38, 39, -1, 4, 0),
      (40, 43, -1, 1, 0),
      (44, 45, -1, 1, 0),
      (46, 49, -1, 3, 0),
      (50, 53, -1, 4, 0),
      (54, 58, 14, 4, 0));

   A_2 : constant Among_Array_Type (0 .. 45) := (
      (59, 63, -1, 4, 0),
      (64, 68, -1, 4, 0),
      (69, 73, -1, 5, 0),
      (74, 78, -1, 6, 0),
      (79, 83, -1, 4, 0),
      (84, 90, -1, 5, 0),
      (91, 97, -1, 6, 0),
      (98, 103, -1, 5, 0),
      (104, 109, -1, 6, 0),
      (110, 116, -1, 5, 0),
      (117, 123, -1, 4, 0),
      (124, 132, -1, 1, 0),
      (133, 141, -1, 2, 0),
      (142, 148, -1, 3, 0),
      (149, 153, -1, 4, 0),
      (154, 158, -1, 5, 0),
      (159, 163, -1, 6, 0),
      (164, 168, -1, 4, 0),
      (169, 173, -1, 5, 0),
      (174, 180, 18, 4, 0),
      (181, 185, -1, 6, 0),
      (186, 191, -1, 5, 0),
      (192, 198, -1, 4, 0),
      (199, 207, -1, 1, 0),
      (208, 214, -1, 3, 0),
      (215, 219, -1, 4, 0),
      (220, 224, -1, 5, 0),
      (225, 229, -1, 6, 0),
      (230, 236, -1, 4, 0),
      (237, 245, -1, 1, 0),
      (246, 252, -1, 3, 0),
      (253, 261, -1, 4, 0),
      (262, 272, -1, 1, 0),
      (273, 281, -1, 3, 0),
      (282, 285, -1, 4, 0),
      (286, 289, -1, 5, 0),
      (290, 295, 35, 4, 0),
      (296, 299, -1, 6, 0),
      (300, 304, -1, 5, 0),
      (305, 308, -1, 4, 0),
      (309, 312, -1, 5, 0),
      (313, 316, -1, 6, 0),
      (317, 322, -1, 4, 0),
      (323, 328, -1, 4, 0),
      (329, 334, -1, 5, 0),
      (335, 340, -1, 6, 0));

   A_3 : constant Among_Array_Type (0 .. 61) := (
      (341, 343, -1, 1, 0),
      (344, 348, -1, 1, 0),
      (349, 353, -1, 1, 0),
      (354, 357, -1, 1, 0),
      (358, 360, -1, 1, 0),
      (361, 363, -1, 1, 0),
      (364, 367, -1, 1, 0),
      (368, 371, -1, 3, 0),
      (372, 374, -1, 1, 0),
      (375, 377, -1, 1, 0),
      (378, 379, -1, 1, 0),
      (380, 382, -1, 1, 0),
      (383, 387, -1, 1, 0),
      (388, 392, -1, 1, 0),
      (393, 396, -1, 3, 0),
      (397, 400, -1, 2, 0),
      (401, 404, -1, 1, 0),
      (405, 407, -1, 1, 0),
      (408, 412, 17, 1, 0),
      (413, 415, -1, 1, 0),
      (416, 419, -1, 1, 0),
      (420, 423, -1, 3, 0),
      (424, 426, -1, 1, 0),
      (427, 429, -1, 1, 0),
      (430, 432, -1, 1, 0),
      (433, 437, -1, 1, 0),
      (438, 442, -1, 1, 0),
      (443, 446, -1, 2, 0),
      (447, 451, -1, 1, 0),
      (452, 454, -1, 1, 0),
      (455, 457, -1, 1, 0),
      (458, 462, 30, 1, 0),
      (463, 465, -1, 1, 0),
      (466, 469, -1, 1, 0),
      (470, 473, -1, 3, 0),
      (474, 476, -1, 1, 0),
      (477, 481, -1, 3, 0),
      (482, 484, -1, 1, 0),
      (485, 489, -1, 1, 0),
      (490, 493, -1, 1, 0),
      (494, 500, -1, 1, 0),
      (501, 504, -1, 1, 0),
      (505, 508, -1, 1, 0),
      (509, 511, -1, 3, 0),
      (512, 515, -1, 1, 0),
      (516, 517, -1, 1, 0),
      (518, 519, -1, 1, 0),
      (520, 521, -1, 1, 0),
      (522, 524, -1, 1, 0),
      (525, 527, -1, 3, 0),
      (528, 529, -1, 1, 0),
      (530, 531, -1, 1, 0),
      (532, 535, -1, 1, 0),
      (536, 541, -1, 1, 0),
      (542, 547, -1, 1, 0),
      (548, 552, -1, 1, 0),
      (553, 556, -1, 1, 0),
      (557, 560, -1, 1, 0),
      (561, 565, -1, 1, 0),
      (566, 570, -1, 3, 0),
      (571, 574, -1, 1, 0),
      (575, 578, -1, 1, 0));

   A_4 : constant Among_Array_Type (0 .. 93) := (
      (579, 580, -1, 1, 0),
      (581, 582, -1, 1, 0),
      (583, 585, -1, 1, 0),
      (586, 589, -1, 1, 0),
      (590, 592, -1, 1, 0),
      (593, 596, -1, 1, 0),
      (597, 599, -1, 1, 0),
      (600, 602, -1, 1, 0),
      (603, 605, -1, 1, 0),
      (606, 609, -1, 1, 0),
      (610, 611, -1, 2, 0),
      (612, 614, 10, 1, 0),
      (615, 618, 10, 2, 0),
      (619, 621, 10, 1, 0),
      (622, 624, 10, 1, 0),
      (625, 628, 10, 1, 0),
      (629, 633, -1, 1, 0),
      (634, 639, -1, 1, 0),
      (640, 642, -1, 1, 0),
      (643, 644, -1, 1, 0),
      (645, 647, 19, 1, 0),
      (648, 650, 19, 1, 0),
      (651, 653, -1, 2, 0),
      (654, 658, -1, 1, 0),
      (659, 664, -1, 1, 0),
      (665, 666, -1, 1, 0),
      (667, 669, -1, 1, 0),
      (670, 673, -1, 1, 0),
      (674, 678, -1, 2, 0),
      (679, 684, 28, 1, 0),
      (685, 691, 28, 2, 0),
      (692, 697, 28, 1, 0),
      (698, 703, 28, 1, 0),
      (704, 710, 28, 1, 0),
      (711, 714, -1, 1, 0),
      (715, 718, -1, 1, 0),
      (719, 723, -1, 1, 0),
      (724, 726, -1, 1, 0),
      (727, 730, -1, 2, 0),
      (731, 735, 38, 1, 0),
      (736, 740, 38, 1, 0),
      (741, 744, -1, 2, 0),
      (745, 748, -1, 2, 0),
      (749, 755, -1, 1, 0),
      (756, 763, -1, 2, 0),
      (764, 772, 44, 1, 0),
      (773, 782, 44, 2, 0),
      (783, 791, 44, 1, 0),
      (792, 800, 44, 1, 0),
      (801, 810, 44, 1, 0),
      (811, 817, -1, 1, 0),
      (818, 824, -1, 1, 0),
      (825, 832, -1, 1, 0),
      (833, 837, -1, 2, 0),
      (838, 839, -1, 1, 0),
      (840, 842, 54, 1, 0),
      (843, 845, 54, 1, 0),
      (846, 847, -1, 2, 0),
      (848, 851, 57, 1, 0),
      (852, 856, 57, 2, 0),
      (857, 860, 57, 1, 0),
      (861, 864, 57, 1, 0),
      (865, 869, 57, 1, 0),
      (870, 871, -1, 2, 0),
      (872, 874, -1, 2, 0),
      (875, 879, 64, 1, 0),
      (880, 885, 64, 2, 0),
      (886, 892, 66, 1, 0),
      (893, 900, 66, 2, 0),
      (901, 907, 66, 1, 0),
      (908, 914, 66, 1, 0),
      (915, 922, 66, 1, 0),
      (923, 927, 64, 1, 0),
      (928, 932, 64, 1, 0),
      (933, 938, 64, 1, 0),
      (939, 941, -1, 2, 0),
      (942, 943, -1, 1, 0),
      (944, 946, 76, 1, 0),
      (947, 949, 76, 1, 0),
      (950, 953, -1, 1, 0),
      (954, 958, -1, 1, 0),
      (959, 960, -1, 1, 0),
      (961, 966, -1, 1, 0),
      (967, 970, -1, 1, 0),
      (971, 975, -1, 2, 0),
      (976, 981, 84, 1, 0),
      (982, 988, 84, 2, 0),
      (989, 994, 84, 1, 0),
      (995, 1000, 84, 1, 0),
      (1001, 1007, 84, 1, 0),
      (1008, 1011, -1, 1, 0),
      (1012, 1015, -1, 1, 0),
      (1016, 1020, -1, 1, 0),
      (1021, 1025, -1, 1, 0));

   A_5 : constant Among_Array_Type (0 .. 4) := (
      (1026, 1026, -1, 1, 0),
      (1027, 1027, -1, 1, 0),
      (1028, 1029, 1, 1, 0),
      (1030, 1030, -1, 1, 0),
      (1031, 1032, -1, 1, 0));


   procedure R_Prelude (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
   begin
      --  (, line 31
      --  repeat, line 32

      <<lab0>>

      loop
         v_1 := Z.C;
         --  goto, line 32
         loop
            v_2 := Z.C;
            --  (, line 32
            In_Grouping (Z, G_V, 97, 259, False, C);
            if C /= 0 then
               goto lab3;
            end if;
            Z.Bra := Z.C;            --  [, line 33

            --  or, line 33
            v_3 := Z.C;
            --  (, line 33
            --  literal, line 33
            C := Eq_S (Z, "u");
            if C = 0 then
               goto lab5;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 33

            In_Grouping (Z, G_V, 97, 259, False, C);
            if C /= 0 then
               goto lab5;
            end if;
            --  <-, line 33
            Slice_From (Z, "U");
            goto lab4;

            <<lab5>>
            Z.C := v_3;
            --  (, line 34
            --  literal, line 34
            C := Eq_S (Z, "i");
            if C = 0 then
               goto lab3;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 34

            In_Grouping (Z, G_V, 97, 259, False, C);
            if C /= 0 then
               goto lab3;
            end if;
            --  <-, line 34
            Slice_From (Z, "I");

            <<lab4>>
            Z.C := v_2;
            exit;

            <<lab3>>
            Z.C := v_2;
            if Z.C >= Z.L then
               goto lab1;
            end if;
            --  goto, line 32
            C := Skip_Utf8 (Z);
            if C < 0 then
               goto lab1;
            end if;
            Z.C := C;
         end loop;
         goto lab0;

         <<lab1>>
         Z.C := v_1;

         exit;
      end loop;

      Result := True;
   end R_Prelude;

   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
   begin
      --  (, line 38
      Z.I_PV := Z.L;
      Z.I_P1 := Z.L;
      Z.I_P2 := Z.L;
      --  do, line 44
      v_1 := Z.C;
      --  (, line 44
      --  or, line 46
      v_2 := Z.C;
      --  (, line 45
      In_Grouping (Z, G_V, 97, 259, False, C);
      if C /= 0 then
         goto lab2;
      end if;
      --  or, line 45
      v_3 := Z.C;
      --  (, line 45
      Out_Grouping (Z, G_V, 97, 259, False, C);
      if C /= 0 then
         goto lab4;
      end if;
            --  gopast, line 45
      --  grouping v, line 45
      Out_Grouping (Z, G_V, 97, 259, True, C);
      if C < 0 then
         goto lab4;
      end if;
      Z.C := Z.C + C;
      goto lab3;

      <<lab4>>
      Z.C := v_3;
      --  (, line 45
      In_Grouping (Z, G_V, 97, 259, False, C);
      if C /= 0 then
         goto lab2;
      end if;
            --  gopast, line 45
      --  non v, line 45
      In_Grouping (Z, G_V, 97, 259, True, C);
      if C < 0 then
         goto lab2;
      end if;
      Z.C := Z.C + C;

      <<lab3>>
      goto lab1;

      <<lab2>>
      Z.C := v_2;
      --  (, line 47
      Out_Grouping (Z, G_V, 97, 259, False, C);
      if C /= 0 then
         goto lab0;
      end if;
      --  or, line 47
      v_4 := Z.C;
      --  (, line 47
      Out_Grouping (Z, G_V, 97, 259, False, C);
      if C /= 0 then
         goto lab8;
      end if;
            --  gopast, line 47
      --  grouping v, line 47
      Out_Grouping (Z, G_V, 97, 259, True, C);
      if C < 0 then
         goto lab8;
      end if;
      Z.C := Z.C + C;
      goto lab7;

      <<lab8>>
      Z.C := v_4;
      --  (, line 47
      In_Grouping (Z, G_V, 97, 259, False, C);
      if C /= 0 then
         goto lab0;
      end if;
      --  next, line 47
      C := Skip_Utf8 (Z);
      if C < 0 then
         goto lab0;
      end if;
      Z.C := C;

      <<lab7>>

      <<lab1>>
      --  setmark pV, line 48
      Z.I_PV := Z.C;

      <<lab0>>
      Z.C := v_1;
      --  do, line 50
      v_5 := Z.C;
      --  (, line 50
            --  gopast, line 51
      --  grouping v, line 51
      Out_Grouping (Z, G_V, 97, 259, True, C);
      if C < 0 then
         goto lab10;
      end if;
      Z.C := Z.C + C;
            --  gopast, line 51
      --  non v, line 51
      In_Grouping (Z, G_V, 97, 259, True, C);
      if C < 0 then
         goto lab10;
      end if;
      Z.C := Z.C + C;
      --  setmark p1, line 51
      Z.I_P1 := Z.C;
            --  gopast, line 52
      --  grouping v, line 52
      Out_Grouping (Z, G_V, 97, 259, True, C);
      if C < 0 then
         goto lab10;
      end if;
      Z.C := Z.C + C;
            --  gopast, line 52
      --  non v, line 52
      In_Grouping (Z, G_V, 97, 259, True, C);
      if C < 0 then
         goto lab10;
      end if;
      Z.C := Z.C + C;
      --  setmark p2, line 52
      Z.I_P2 := Z.C;

      <<lab10>>
      Z.C := v_5;

      Result := True;
   end R_Mark_regions;

   procedure R_Postlude (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
   begin
      --  repeat, line 56

      <<lab0>>

      loop
         v_1 := Z.C;
         --  (, line 56
         Z.Bra := Z.C;         --  [, line 58

         --  substring, line 58
         if Z.C >= Z.L or else (Character'Pos (Z.P (Z.C + 1)) /= 73 and then Character'Pos (Z.P (Z.C + 1)) /= 85) then
            A := 3;
         else            --  substring, line 58
            Find_Among (Z, A_0, Among_String, null, A);
            if A = 0 then
               goto lab1;
            end if;
         end if;
         Z.Ket := Z.C;         --  ], line 58

         --  among, line 58
         case A is
            when 1 =>
               --  (, line 59
               --  <-, line 59
               Slice_From (Z, "i");
            when 2 =>
               --  (, line 60
               --  <-, line 60
               Slice_From (Z, "u");
            when 3 =>
               --  (, line 61
               --  next, line 61
               C := Skip_Utf8 (Z);
               if C < 0 then
                  goto lab1;
               end if;
               Z.C := C;
            when others =>
               null;
         end case;
         goto lab0;

         <<lab1>>
         Z.C := v_1;

         exit;
      end loop;

      Result := True;
   end R_Postlude;

   procedure R_RV (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_PV <= Z.C);
   end R_RV;

   procedure R_R1 (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_P1 <= Z.C);
   end R_R1;

   procedure R_R2 (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_P2 <= Z.C);
   end R_R2;

   procedure R_Step_0 (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
   begin
      --  (, line 72
      Z.Ket := Z.C;      --  [, line 73

      --  substring, line 73
      if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#41222#) then
         Result := False;
         return;
         --  substring, line 73
      end if;
      Find_Among_Backward (Z, A_1, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 73

      --  call R1, line 73
      R_R1 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 73
      case A is
         when 1 =>
            --  (, line 75
            --  delete, line 75
            Slice_Del (Z);
         when 2 =>
            --  (, line 77
            --  <-, line 77
            Slice_From (Z, "a");
         when 3 =>
            --  (, line 79
            --  <-, line 79
            Slice_From (Z, "e");
         when 4 =>
            --  (, line 81
            --  <-, line 81
            Slice_From (Z, "i");
         when 5 =>
            --  (, line 83
            --  not, line 83
            v_1 := Z.L - Z.C;
            --  literal, line 83
            C := Eq_S_Backward (Z, "ab");
            if C = 0 then
               goto lab0;
            end if;
            Z.C := Z.C - C;
            Result := False;
            return;

            <<lab0>>
            Z.C := Z.L - v_1;
            --  <-, line 83
            Slice_From (Z, "i");
         when 6 =>
            --  (, line 85
            --  <-, line 85
            Slice_From (Z, "at");
         when 7 =>
            --  (, line 87
            --  <-, line 87
            Slice_From (Z, "aţi");
         when others =>
            null;
      end case;

      Result := True;
   end R_Step_0;

   procedure R_Combo_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
   begin
      --  test, line 91
      v_1 := Z.L - Z.C;
      --  (, line 91
      Z.Ket := Z.C;      --  [, line 92

      --  substring, line 92
      Find_Among_Backward (Z, A_2, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 92

      --  call R1, line 92
      R_R1 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  (, line 92
      --  among, line 93
      case A is
         when 1 =>
            --  (, line 100
            --  <-, line 101
            Slice_From (Z, "abil");
         when 2 =>
            --  (, line 103
            --  <-, line 104
            Slice_From (Z, "ibil");
         when 3 =>
            --  (, line 106
            --  <-, line 107
            Slice_From (Z, "iv");
         when 4 =>
            --  (, line 112
            --  <-, line 113
            Slice_From (Z, "ic");
         when 5 =>
            --  (, line 117
            --  <-, line 118
            Slice_From (Z, "at");
         when 6 =>
            --  (, line 121
            --  <-, line 122
            Slice_From (Z, "it");
         when others =>
            null;
      end case;
      --  set standard_suffix_removed, line 125
      Z.B_Standard_suffix_removed := True;
      Z.C := Z.L - v_1;

      Result := True;
   end R_Combo_suffix;

   procedure R_Standard_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
   begin
      --  (, line 129
      --  unset standard_suffix_removed, line 130
      Z.B_Standard_suffix_removed := False;
      --  repeat, line 131

      <<lab0>>

      loop
         v_1 := Z.L - Z.C;
         --  call combo_suffix, line 131
         R_Combo_suffix (Z, Result);
         if not Result then
            goto lab1;
         end if;
         goto lab0;

         <<lab1>>
         Z.C := Z.L - v_1;

         exit;
      end loop;
      Z.Ket := Z.C;      --  [, line 132

      --  substring, line 132
      Find_Among_Backward (Z, A_3, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 132

      --  call R2, line 132
      R_R2 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  (, line 132
      --  among, line 133
      case A is
         when 1 =>
            --  (, line 148
            --  delete, line 149
            Slice_Del (Z);
         when 2 =>
            --  (, line 151
            --  literal, line 152
            C := Eq_S_Backward (Z, "ţ");
            if C = 0 then
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 152

            --  <-, line 152
            Slice_From (Z, "t");
         when 3 =>
            --  (, line 155
            --  <-, line 156
            Slice_From (Z, "ist");
         when others =>
            null;
      end case;
      --  set standard_suffix_removed, line 160
      Z.B_Standard_suffix_removed := True;

      Result := True;
   end R_Standard_suffix;

   procedure R_Verb_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_2 : Integer;
      v_3 : Char_Index;
   begin
      if Z.C < Z.I_PV then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_PV;
      --  (, line 164
      Z.Ket := Z.C;      --  [, line 165

      --  substring, line 165
      Find_Among_Backward (Z, A_4, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 165

      --  among, line 165
      case A is
         when 1 =>
            --  (, line 200
            --  or, line 200
            v_3 := Z.L - Z.C;
            Out_Grouping_Backward (Z, G_V, 97, 259, False, C);
            if C /= 0 then
               goto lab1;
            end if;
            goto lab0;

            <<lab1>>
            Z.C := Z.L - v_3;
            --  literal, line 200
            C := Eq_S_Backward (Z, "u");
            if C = 0 then
               Z.Lb := v_2;
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;

            <<lab0>>
            --  delete, line 200
            Slice_Del (Z);
         when 2 =>
            --  (, line 214
            --  delete, line 214
            Slice_Del (Z);
         when others =>
            null;
      end case;
      Z.Lb := v_2;

      Result := True;
   end R_Verb_suffix;

   procedure R_Vowel_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 218
      Z.Ket := Z.C;      --  [, line 219

      --  substring, line 219
      Find_Among_Backward (Z, A_5, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 219

      --  call RV, line 219
      R_RV (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  (, line 220
      --  delete, line 220
      Slice_Del (Z);

      Result := True;
   end R_Vowel_suffix;

   procedure Stem (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
      v_6 : Char_Index;
      v_7 : Char_Index;
      v_8 : Char_Index;
   begin
      --  (, line 225
      --  do, line 226
      v_1 := Z.C;
      --  call prelude, line 226
      R_Prelude (Z, Result);
      Z.C := v_1;
      --  do, line 227
      --  call mark_regions, line 227
      R_Mark_regions (Z, Result);
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 228

      --  (, line 228
      --  do, line 229
      v_3 := Z.L - Z.C;
      --  call step_0, line 229
      R_Step_0 (Z, Result);
      Z.C := Z.L - v_3;
      --  do, line 230
      v_4 := Z.L - Z.C;
      --  call standard_suffix, line 230
      R_Standard_suffix (Z, Result);
      Z.C := Z.L - v_4;
      --  do, line 231
      v_5 := Z.L - Z.C;
      --  (, line 231
      --  or, line 231
      v_6 := Z.L - Z.C;
      --  Boolean test standard_suffix_removed, line 231
      if not Z.B_Standard_suffix_removed then
         goto lab2;
      end if;
      goto lab1;

      <<lab2>>
      Z.C := Z.L - v_6;
      --  call verb_suffix, line 231
      R_Verb_suffix (Z, Result);
      if not Result then
         goto lab0;
      end if;

      <<lab1>>

      <<lab0>>
      Z.C := Z.L - v_5;
      --  do, line 232
      v_7 := Z.L - Z.C;
      --  call vowel_suffix, line 232
      R_Vowel_suffix (Z, Result);
      Z.C := Z.L - v_7;
      Z.C := Z.Lb;
      --  do, line 234
      v_8 := Z.C;
      --  call postlude, line 234
      R_Postlude (Z, Result);
      Z.C := v_8;

      Result := True;
   end Stem;
end Stemmer.Romanian;
