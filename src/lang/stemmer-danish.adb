--  Generated by Snowball 2.0.0 - https://snowballstem.org/

package body Stemmer.Danish is

   pragma Style_Checks ("-mr");
   pragma Warnings (Off, "*variable*is never read and never assigned*");
   pragma Warnings (Off, "*mode could be*instead of*");
   pragma Warnings (Off, "*formal parameter.*is not modified*");
   pragma Warnings (Off, "*this line is too long*");
   pragma Warnings (Off, "*label.*is not referenced*");

   procedure R_Undouble (Z : in out Context_Type; Result : out Boolean);
   procedure R_Other_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Consonant_pair (Z : in out Context_Type; Result : out Boolean);
   procedure R_Main_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean);

   G_C : constant Grouping_Array (0 .. 31) := (
      True, True, True, False, True, True, True, False,
      True, True, True, True, True, False, True, True,
      True, True, True, False, True, True, True, False,
      True, False, False, False, False, False, False, False
   );

   G_V : constant Grouping_Array (0 .. 151) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      True, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, True, True, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, True
   );

   G_S_ending : constant Grouping_Array (0 .. 135) := (
      True, True, True, True, False, True, True, True,
      False, True, True, True, True, True, True, True,
      False, True, False, True, False, True, False, False,
      True, True, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, True, False, False, False
   );
   Among_String : constant String := "hed" & "ethed" & "ered" & "e" & "erede"
      & "ende" & "erende" & "ene" & "erne" & "ere" & "en" & "heden" & "eren" & "er"
      & "heder" & "erer" & "s" & "heds" & "es" & "endes" & "erendes" & "enes" & "ernes"
      & "eres" & "ens" & "hedens" & "erens" & "ers" & "ets" & "erets" & "et" & "eret"
      & "gd" & "dt" & "gt" & "kt" & "ig" & "lig" & "elig" & "els" & "løst";

   A_0 : constant Among_Array_Type (0 .. 31) := (
      (1, 3, -1, 1),
      (4, 8, 0, 1),
      (9, 12, -1, 1),
      (13, 13, -1, 1),
      (14, 18, 3, 1),
      (19, 22, 3, 1),
      (23, 28, 5, 1),
      (29, 31, 3, 1),
      (32, 35, 3, 1),
      (36, 38, 3, 1),
      (39, 40, -1, 1),
      (41, 45, 10, 1),
      (46, 49, 10, 1),
      (50, 51, -1, 1),
      (52, 56, 13, 1),
      (57, 60, 13, 1),
      (61, 61, -1, 2),
      (62, 65, 16, 1),
      (66, 67, 16, 1),
      (68, 72, 18, 1),
      (73, 79, 19, 1),
      (80, 83, 18, 1),
      (84, 88, 18, 1),
      (89, 92, 18, 1),
      (93, 95, 16, 1),
      (96, 101, 24, 1),
      (102, 106, 24, 1),
      (107, 109, 16, 1),
      (110, 112, 16, 1),
      (113, 117, 28, 1),
      (118, 119, -1, 1),
      (120, 123, 30, 1));

   A_1 : constant Among_Array_Type (0 .. 3) := (
      (124, 125, -1, -1),
      (126, 127, -1, -1),
      (128, 129, -1, -1),
      (130, 131, -1, -1));

   A_2 : constant Among_Array_Type (0 .. 4) := (
      (132, 133, -1, 1),
      (134, 136, 0, 1),
      (137, 140, 1, 1),
      (141, 143, -1, 1),
      (144, 148, -1, 2));


   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
   begin
      --  (, line 31
      Z.I_P1 := Z.L;
      --  test, line 35
      v_1 := Z.C;
      --  (, line 35
      C := Skip_Utf8 (Z, 3);      --  hop, line 35

      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      --  setmark x, line 35
      Z.I_X := Z.C;
      Z.C := v_1;
            --  goto, line 36
      Out_Grouping (Z, G_V, 97, 248, True, C);      if C < 0 then
         Result := False;
         return;
      end if;
            --  gopast, line 36
      --  non v, line 36
      In_Grouping (Z, G_V, 97, 248, True, C);
      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C + C;
      --  setmark p1, line 36
      Z.I_P1 := Z.C;
      --  try, line 37
      --  (, line 37
      if not (Z.I_P1 < Z.I_X) then
      goto lab2;
      end if;
      Z.I_P1 := Z.I_X;

      <<lab2>>

      Result := True;
   end R_Mark_regions;

   procedure R_Main_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_2 : Integer;
   begin
      --  (, line 42
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 43
      Z.Ket := Z.C;      --  [, line 43

      --  substring, line 43
      if Z.C <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#1c4030#) then
         Z.Lb := v_2;
         Result := False;
         return;
         --  substring, line 43
      end if;
      Find_Among_Backward (Z, A_0, Among_String, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 43

      Z.Lb := v_2;
      --  among, line 44
      case A is
         when 1 =>
            --  (, line 50
            --  delete, line 50
            Slice_Del (Z);
         when 2 =>
            --  (, line 52
            In_Grouping_Backward (Z, G_S_ending, 97, 229, False, C);
            if C /= 0 then
               Result := False;
               return;
            end if;
            --  delete, line 52
            Slice_Del (Z);
         when others =>
            null;
      end case;

      Result := True;
   end R_Main_suffix;

   procedure R_Consonant_pair (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_3 : Integer;
   begin
      --  (, line 56
      --  test, line 57
      v_1 := Z.L - Z.C;
      --  (, line 57
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_3 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 58
      Z.Ket := Z.C;      --  [, line 58

      --  substring, line 58
      if Z.C - 1 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 100 and then Character'Pos (Z.P (Z.C)) /= 116) then
         Z.Lb := v_3;
         Result := False;
         return;
         --  substring, line 58
      end if;
      Find_Among_Backward (Z, A_1, Among_String, A);
      if A = 0 then
         Z.Lb := v_3;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 58

      Z.Lb := v_3;
      Z.C := Z.L - v_1;
      --  next, line 64
      C := Skip_Utf8_Backward (Z, 1);      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      Z.Bra := Z.C;      --  ], line 64

      --  delete, line 64
      Slice_Del (Z);

      Result := True;
   end R_Consonant_pair;

   procedure R_Other_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_3 : Integer;
      v_4 : Integer;
   begin
      --  (, line 67
      --  do, line 68
      v_1 := Z.L - Z.C;
      --  (, line 68
      Z.Ket := Z.C;      --  [, line 68

      --  literal, line 68
      C := Eq_S_Backward (Z, "st");
      if C = 0 then
         goto lab0;
      end if;
      Z.C := Z.C - C;
      Z.Bra := Z.C;      --  ], line 68

      --  literal, line 68
      C := Eq_S_Backward (Z, "ig");
      if C = 0 then
         goto lab0;
      end if;
      Z.C := Z.C - C;
      --  delete, line 68
      Slice_Del (Z);

      <<lab0>>
      Z.C := Z.L - v_1;
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_3 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 69
      Z.Ket := Z.C;      --  [, line 69

      --  substring, line 69
      if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#180080#) then
         Z.Lb := v_3;
         Result := False;
         return;
         --  substring, line 69
      end if;
      Find_Among_Backward (Z, A_2, Among_String, A);
      if A = 0 then
         Z.Lb := v_3;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 69

      Z.Lb := v_3;
      --  among, line 70
      case A is
         when 1 =>
            --  (, line 72
            --  delete, line 72
            Slice_Del (Z);
            --  do, line 72
            v_4 := Z.L - Z.C;
            --  call consonant_pair, line 72
            R_Consonant_pair (Z, Result);
            Z.C := Z.L - v_4;
         when 2 =>
            --  (, line 74
            --  <-, line 74
            Slice_From (Z, "løs");
         when others =>
            null;
      end case;

      Result := True;
   end R_Other_suffix;

   procedure R_Undouble (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_2 : Integer;
   begin
      --  (, line 77
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 78
      Z.Ket := Z.C;      --  [, line 78

      In_Grouping_Backward (Z, G_C, 98, 122, False, C);
      if C /= 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 78

      --  -> ch, line 78
      Z.S_Ch := Ada.Strings.Unbounded.To_Unbounded_String (Slice_To (Z));
      Z.Lb := v_2;
      --  name ch, line 79
      C := Eq_S_Backward (Z, Ada.Strings.Unbounded.To_String (Z.S_Ch));      if C = 0 then
         Result := False;
         return;
      end if;
      --  delete, line 80
      Slice_Del (Z);

      Result := True;
   end R_Undouble;

   procedure Stem (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
      v_5 : Integer;
   begin
      --  (, line 84
      --  do, line 86
      v_1 := Z.C;
      --  call mark_regions, line 86
      R_Mark_regions (Z, Result);
      Z.C := v_1;
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 87

      --  (, line 87
      --  do, line 88
      v_2 := Z.L - Z.C;
      --  call main_suffix, line 88
      R_Main_suffix (Z, Result);
      Z.C := Z.L - v_2;
      --  do, line 89
      v_3 := Z.L - Z.C;
      --  call consonant_pair, line 89
      R_Consonant_pair (Z, Result);
      Z.C := Z.L - v_3;
      --  do, line 90
      v_4 := Z.L - Z.C;
      --  call other_suffix, line 90
      R_Other_suffix (Z, Result);
      Z.C := Z.L - v_4;
      --  do, line 91
      v_5 := Z.L - Z.C;
      --  call undouble, line 91
      R_Undouble (Z, Result);
      Z.C := Z.L - v_5;
      Z.C := Z.Lb;

      Result := True;
   end Stem;
end Stemmer.Danish;
