--  Generated by Snowball 2.0.0 - https://snowballstem.org/

package body Stemmer.Norwegian is

   pragma Style_Checks ("-mr");
   pragma Warnings (Off, "*variable*is never read and never assigned*");
   pragma Warnings (Off, "*mode could be*instead of*");
   pragma Warnings (Off, "*formal parameter.*is not modified*");
   pragma Warnings (Off, "*this line is too long*");
   pragma Warnings (Off, "*is not referenced*");

   procedure R_Other_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Consonant_pair (Z : in out Context_Type; Result : out Boolean);
   procedure R_Main_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean);

   G_V : constant Grouping_Array (0 .. 151) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      True, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, True, True, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, True
   );

   G_S_ending : constant Grouping_Array (0 .. 31) := (
      True, True, True, False, True, True, True, False,
      True, False, True, True, True, True, True, False,
      True, False, True, False, True, False, False, True,
      True, False, False, False, False, False, False, False
   );
   Among_String : constant String := "a" & "e" & "ede" & "ande" & "ende"
      & "ane" & "ene" & "hetene" & "erte" & "en" & "heten" & "ar" & "er" & "heter"
      & "s" & "as" & "es" & "edes" & "endes" & "enes" & "hetenes" & "ens" & "hetens"
      & "ers" & "ets" & "et" & "het" & "ert" & "ast" & "dt" & "vt" & "leg" & "eleg"
      & "ig" & "eig" & "lig" & "elig" & "els" & "lov" & "elov" & "slov" & "hetslov";

   A_0 : constant Among_Array_Type (0 .. 28) := (
      (1, 1, -1, 1, 0),
      (2, 2, -1, 1, 0),
      (3, 5, 1, 1, 0),
      (6, 9, 1, 1, 0),
      (10, 13, 1, 1, 0),
      (14, 16, 1, 1, 0),
      (17, 19, 1, 1, 0),
      (20, 25, 6, 1, 0),
      (26, 29, 1, 3, 0),
      (30, 31, -1, 1, 0),
      (32, 36, 9, 1, 0),
      (37, 38, -1, 1, 0),
      (39, 40, -1, 1, 0),
      (41, 45, 12, 1, 0),
      (46, 46, -1, 2, 0),
      (47, 48, 14, 1, 0),
      (49, 50, 14, 1, 0),
      (51, 54, 16, 1, 0),
      (55, 59, 16, 1, 0),
      (60, 63, 16, 1, 0),
      (64, 70, 19, 1, 0),
      (71, 73, 14, 1, 0),
      (74, 79, 21, 1, 0),
      (80, 82, 14, 1, 0),
      (83, 85, 14, 1, 0),
      (86, 87, -1, 1, 0),
      (88, 90, 25, 1, 0),
      (91, 93, -1, 3, 0),
      (94, 96, -1, 1, 0));

   A_1 : constant Among_Array_Type (0 .. 1) := (
      (97, 98, -1, -1, 0),
      (99, 100, -1, -1, 0));

   A_2 : constant Among_Array_Type (0 .. 10) := (
      (101, 103, -1, 1, 0),
      (104, 107, 0, 1, 0),
      (108, 109, -1, 1, 0),
      (110, 112, 2, 1, 0),
      (113, 115, 2, 1, 0),
      (116, 119, 4, 1, 0),
      (120, 122, -1, 1, 0),
      (123, 125, -1, 1, 0),
      (126, 129, 7, 1, 0),
      (130, 133, 7, 1, 0),
      (134, 140, 9, 1, 0));


   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
   begin
      --  (, line 26
      Z.I_P1 := Z.L;
      --  test, line 30
      v_1 := Z.C;
      --  (, line 30
      C := Skip_Utf8 (Z, 3);      --  hop, line 30

      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      --  setmark x, line 30
      Z.I_X := Z.C;
      Z.C := v_1;
            --  goto, line 31
      Out_Grouping (Z, G_V, 97, 248, True, C);      if C < 0 then
         Result := False;
         return;
      end if;
            --  gopast, line 31
      --  non v, line 31
      In_Grouping (Z, G_V, 97, 248, True, C);
      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C + C;
      --  setmark p1, line 31
      Z.I_P1 := Z.C;
      --  try, line 32
      --  (, line 32
      if not (Z.I_P1 < Z.I_X) then
         goto lab2;
      end if;
      Z.I_P1 := Z.I_X;

      <<lab2>>

      Result := True;
   end R_Mark_regions;

   procedure R_Main_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_2 : Integer;
      v_3 : Integer;
   begin
      --  (, line 37
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 38
      Z.Ket := Z.C;      --  [, line 38

      --  substring, line 38
      if Z.C <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#1c4022#) then
         Z.Lb := v_2;
         Result := False;
         return;
         --  substring, line 38
      end if;
      Find_Among_Backward (Z, A_0, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 38

      Z.Lb := v_2;
      --  among, line 39
      case A is
         when 1 =>
            --  (, line 44
            --  delete, line 44
            Slice_Del (Z);
         when 2 =>
            --  (, line 46
            --  or, line 46
            v_3 := Z.L - Z.C;
            In_Grouping_Backward (Z, G_S_ending, 98, 122, False, C);
            if C /= 0 then
               goto lab1;
            end if;
            goto lab0;

            <<lab1>>
            Z.C := Z.L - v_3;
            --  (, line 46
            --  literal, line 46
            C := Eq_S_Backward (Z, "k");
            if C = 0 then
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;
            Out_Grouping_Backward (Z, G_V, 97, 248, False, C);
            if C /= 0 then
               Result := False;
               return;
            end if;

            <<lab0>>
            --  delete, line 46
            Slice_Del (Z);
         when 3 =>
            --  (, line 48
            --  <-, line 48
            Slice_From (Z, "er");
         when others =>
            null;
      end case;

      Result := True;
   end R_Main_suffix;

   procedure R_Consonant_pair (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_3 : Integer;
   begin
      --  (, line 52
      --  test, line 53
      v_1 := Z.L - Z.C;
      --  (, line 53
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_3 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 54
      Z.Ket := Z.C;      --  [, line 54

      --  substring, line 54
      if Z.C - 1 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 116 then
         Z.Lb := v_3;
         Result := False;
         return;
         --  substring, line 54
      end if;
      Find_Among_Backward (Z, A_1, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_3;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 54

      Z.Lb := v_3;
      Z.C := Z.L - v_1;
      --  next, line 59
      C := Skip_Utf8_Backward (Z, 1);      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      Z.Bra := Z.C;      --  ], line 59

      --  delete, line 59
      Slice_Del (Z);

      Result := True;
   end R_Consonant_pair;

   procedure R_Other_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_2 : Integer;
   begin
      --  (, line 62
      if Z.C < Z.I_P1 then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_P1;
      --  (, line 63
      Z.Ket := Z.C;      --  [, line 63

      --  substring, line 63
      if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#480080#) then
         Z.Lb := v_2;
         Result := False;
         return;
         --  substring, line 63
      end if;
      Find_Among_Backward (Z, A_2, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 63

      Z.Lb := v_2;
      --  (, line 67
      --  delete, line 67
      Slice_Del (Z);

      Result := True;
   end R_Other_suffix;

   procedure Stem (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
   begin
      --  (, line 72
      --  do, line 74
      v_1 := Z.C;
      --  call mark_regions, line 74
      R_Mark_regions (Z, Result);
      Z.C := v_1;
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 75

      --  (, line 75
      --  do, line 76
      v_2 := Z.L - Z.C;
      --  call main_suffix, line 76
      R_Main_suffix (Z, Result);
      Z.C := Z.L - v_2;
      --  do, line 77
      v_3 := Z.L - Z.C;
      --  call consonant_pair, line 77
      R_Consonant_pair (Z, Result);
      Z.C := Z.L - v_3;
      --  do, line 78
      v_4 := Z.L - Z.C;
      --  call other_suffix, line 78
      R_Other_suffix (Z, Result);
      Z.C := Z.L - v_4;
      Z.C := Z.Lb;

      Result := True;
   end Stem;
end Stemmer.Norwegian;
