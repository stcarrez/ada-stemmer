--  Generated by Snowball 2.0.0 - https://snowballstem.org/

package body Stemmer.Hungarian is

   pragma Style_Checks ("-mr");
   pragma Warnings (Off, "*variable*is never read and never assigned*");
   pragma Warnings (Off, "*mode could be*instead of*");
   pragma Warnings (Off, "*formal parameter.*is not modified*");
   pragma Warnings (Off, "*this line is too long*");
   pragma Warnings (Off, "*is not referenced*");

   procedure R_Double (Z : in out Context_Type; Result : out Boolean);
   procedure R_Undouble (Z : in out Context_Type; Result : out Boolean);
   procedure R_Factive (Z : in out Context_Type; Result : out Boolean);
   procedure R_Instrum (Z : in out Context_Type; Result : out Boolean);
   procedure R_Plur_owner (Z : in out Context_Type; Result : out Boolean);
   procedure R_Sing_owner (Z : in out Context_Type; Result : out Boolean);
   procedure R_Owned (Z : in out Context_Type; Result : out Boolean);
   procedure R_Plural (Z : in out Context_Type; Result : out Boolean);
   procedure R_Case_other (Z : in out Context_Type; Result : out Boolean);
   procedure R_Case_special (Z : in out Context_Type; Result : out Boolean);
   procedure R_Case (Z : in out Context_Type; Result : out Boolean);
   procedure R_V_ending (Z : in out Context_Type; Result : out Boolean);
   procedure R_R1 (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean);

   G_V : constant Grouping_Array (0 .. 279) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      True, False, False, False, False, False, False, False,
      True, False, False, False, True, False, False, False,
      False, False, True, False, False, True, False, False,
      False, True, False, True, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      True, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      True, False, False, False, False, False, False, False
   );
   Among_String : constant String := "cs" & "dzs" & "gy" & "ly" & "ny" & "sz"
      & "ty" & "zs" & "á" & "é" & "bb" & "cc" & "dd" & "ff" & "gg" & "jj" & "kk"
      & "ll" & "mm" & "nn" & "pp" & "rr" & "ccs" & "ss" & "zzs" & "tt" & "vv" & "ggy"
      & "lly" & "nny" & "tty" & "ssz" & "zz" & "al" & "el" & "ba" & "ra" & "be" & "re"
      & "ig" & "nak" & "nek" & "val" & "vel" & "ul" & "ből" & "ről" & "től" & "nál"
      & "nél" & "ból" & "ról" & "tól" & "ül" & "n" & "an" & "ban" & "en" & "ben"
      & "képpen" & "on" & "ön" & "képp" & "kor" & "t" & "at" & "et" & "ként"
      & "anként" & "enként" & "onként" & "ot" & "ért" & "öt" & "hez" & "hoz"
      & "höz" & "vá" & "vé" & "án" & "én" & "ánként" & "stul" & "astul"
      & "ástul" & "stül" & "estül" & "éstül" & "á" & "é" & "k" & "ak" & "ek"
      & "ok" & "ák" & "ék" & "ök" & "éi" & "áéi" & "ééi" & "é" & "ké"
      & "aké" & "eké" & "oké" & "áké" & "éké" & "öké" & "éé" & "a" & "ja"
      & "d" & "ad" & "ed" & "od" & "ád" & "éd" & "öd" & "e" & "je" & "nk" & "unk"
      & "ánk" & "énk" & "ünk" & "uk" & "juk" & "ájuk" & "ük" & "jük" & "éjük"
      & "m" & "am" & "em" & "om" & "ám" & "ém" & "o" & "á" & "é" & "id" & "aid"
      & "jaid" & "eid" & "jeid" & "áid" & "éid" & "i" & "ai" & "jai" & "ei" & "jei"
      & "ái" & "éi" & "itek" & "eitek" & "jeitek" & "éitek" & "ik" & "aik" & "jaik"
      & "eik" & "jeik" & "áik" & "éik" & "ink" & "aink" & "jaink" & "eink" & "jeink"
      & "áink" & "éink" & "aitok" & "jaitok" & "áitok" & "im" & "aim" & "jaim"
      & "eim" & "jeim" & "áim" & "éim";

   A_0 : constant Among_Array_Type (0 .. 7) := (
      (1, 2, -1, -1, 0),
      (3, 5, -1, -1, 0),
      (6, 7, -1, -1, 0),
      (8, 9, -1, -1, 0),
      (10, 11, -1, -1, 0),
      (12, 13, -1, -1, 0),
      (14, 15, -1, -1, 0),
      (16, 17, -1, -1, 0));

   A_1 : constant Among_Array_Type (0 .. 1) := (
      (18, 19, -1, 1, 0),
      (20, 21, -1, 2, 0));

   A_2 : constant Among_Array_Type (0 .. 22) := (
      (22, 23, -1, -1, 0),
      (24, 25, -1, -1, 0),
      (26, 27, -1, -1, 0),
      (28, 29, -1, -1, 0),
      (30, 31, -1, -1, 0),
      (32, 33, -1, -1, 0),
      (34, 35, -1, -1, 0),
      (36, 37, -1, -1, 0),
      (38, 39, -1, -1, 0),
      (40, 41, -1, -1, 0),
      (42, 43, -1, -1, 0),
      (44, 45, -1, -1, 0),
      (46, 48, -1, -1, 0),
      (49, 50, -1, -1, 0),
      (51, 53, -1, -1, 0),
      (54, 55, -1, -1, 0),
      (56, 57, -1, -1, 0),
      (58, 60, -1, -1, 0),
      (61, 63, -1, -1, 0),
      (64, 66, -1, -1, 0),
      (67, 69, -1, -1, 0),
      (70, 72, -1, -1, 0),
      (73, 74, -1, -1, 0));

   A_3 : constant Among_Array_Type (0 .. 1) := (
      (75, 76, -1, 1, 0),
      (77, 78, -1, 1, 0));

   A_4 : constant Among_Array_Type (0 .. 43) := (
      (79, 80, -1, -1, 0),
      (81, 82, -1, -1, 0),
      (83, 84, -1, -1, 0),
      (85, 86, -1, -1, 0),
      (87, 88, -1, -1, 0),
      (89, 91, -1, -1, 0),
      (92, 94, -1, -1, 0),
      (95, 97, -1, -1, 0),
      (98, 100, -1, -1, 0),
      (101, 102, -1, -1, 0),
      (103, 106, -1, -1, 0),
      (107, 110, -1, -1, 0),
      (111, 114, -1, -1, 0),
      (115, 118, -1, -1, 0),
      (119, 122, -1, -1, 0),
      (123, 126, -1, -1, 0),
      (127, 130, -1, -1, 0),
      (131, 134, -1, -1, 0),
      (135, 137, -1, -1, 0),
      (138, 138, -1, -1, 0),
      (139, 140, 19, -1, 0),
      (141, 143, 20, -1, 0),
      (144, 145, 19, -1, 0),
      (146, 148, 22, -1, 0),
      (149, 155, 22, -1, 0),
      (156, 157, 19, -1, 0),
      (158, 160, 19, -1, 0),
      (161, 165, -1, -1, 0),
      (166, 168, -1, -1, 0),
      (169, 169, -1, -1, 0),
      (170, 171, 29, -1, 0),
      (172, 173, 29, -1, 0),
      (174, 178, 29, -1, 0),
      (179, 185, 32, -1, 0),
      (186, 192, 32, -1, 0),
      (193, 199, 32, -1, 0),
      (200, 201, 29, -1, 0),
      (202, 205, 29, -1, 0),
      (206, 208, 29, -1, 0),
      (209, 211, -1, -1, 0),
      (212, 214, -1, -1, 0),
      (215, 218, -1, -1, 0),
      (219, 221, -1, -1, 0),
      (222, 224, -1, -1, 0));

   A_5 : constant Among_Array_Type (0 .. 2) := (
      (225, 227, -1, 2, 0),
      (228, 230, -1, 1, 0),
      (231, 238, -1, 2, 0));

   A_6 : constant Among_Array_Type (0 .. 5) := (
      (239, 242, -1, 1, 0),
      (243, 247, 0, 1, 0),
      (248, 253, 0, 2, 0),
      (254, 258, -1, 1, 0),
      (259, 264, 3, 1, 0),
      (265, 271, 3, 3, 0));

   A_7 : constant Among_Array_Type (0 .. 1) := (
      (272, 273, -1, 1, 0),
      (274, 275, -1, 1, 0));

   A_8 : constant Among_Array_Type (0 .. 6) := (
      (276, 276, -1, 3, 0),
      (277, 278, 0, 3, 0),
      (279, 280, 0, 3, 0),
      (281, 282, 0, 3, 0),
      (283, 285, 0, 1, 0),
      (286, 288, 0, 2, 0),
      (289, 291, 0, 3, 0));

   A_9 : constant Among_Array_Type (0 .. 11) := (
      (292, 294, -1, 1, 0),
      (295, 299, 0, 3, 0),
      (300, 304, 0, 2, 0),
      (305, 306, -1, 1, 0),
      (307, 309, 3, 1, 0),
      (310, 313, 4, 1, 0),
      (314, 317, 4, 1, 0),
      (318, 321, 4, 1, 0),
      (322, 326, 4, 3, 0),
      (327, 331, 4, 2, 0),
      (332, 336, 4, 1, 0),
      (337, 340, 3, 2, 0));

   A_10 : constant Among_Array_Type (0 .. 30) := (
      (341, 341, -1, 1, 0),
      (342, 343, 0, 1, 0),
      (344, 344, -1, 1, 0),
      (345, 346, 2, 1, 0),
      (347, 348, 2, 1, 0),
      (349, 350, 2, 1, 0),
      (351, 353, 2, 2, 0),
      (354, 356, 2, 3, 0),
      (357, 359, 2, 1, 0),
      (360, 360, -1, 1, 0),
      (361, 362, 9, 1, 0),
      (363, 364, -1, 1, 0),
      (365, 367, 11, 1, 0),
      (368, 371, 11, 2, 0),
      (372, 375, 11, 3, 0),
      (376, 379, 11, 1, 0),
      (380, 381, -1, 1, 0),
      (382, 384, 16, 1, 0),
      (385, 389, 17, 2, 0),
      (390, 392, -1, 1, 0),
      (393, 396, 19, 1, 0),
      (397, 402, 20, 3, 0),
      (403, 403, -1, 1, 0),
      (404, 405, 22, 1, 0),
      (406, 407, 22, 1, 0),
      (408, 409, 22, 1, 0),
      (410, 412, 22, 2, 0),
      (413, 415, 22, 3, 0),
      (416, 416, -1, 1, 0),
      (417, 418, -1, 2, 0),
      (419, 420, -1, 3, 0));

   A_11 : constant Among_Array_Type (0 .. 41) := (
      (421, 422, -1, 1, 0),
      (423, 425, 0, 1, 0),
      (426, 429, 1, 1, 0),
      (430, 432, 0, 1, 0),
      (433, 436, 3, 1, 0),
      (437, 440, 0, 2, 0),
      (441, 444, 0, 3, 0),
      (445, 445, -1, 1, 0),
      (446, 447, 7, 1, 0),
      (448, 450, 8, 1, 0),
      (451, 452, 7, 1, 0),
      (453, 455, 10, 1, 0),
      (456, 458, 7, 2, 0),
      (459, 461, 7, 3, 0),
      (462, 465, -1, 1, 0),
      (466, 470, 14, 1, 0),
      (471, 476, 15, 1, 0),
      (477, 482, 14, 3, 0),
      (483, 484, -1, 1, 0),
      (485, 487, 18, 1, 0),
      (488, 491, 19, 1, 0),
      (492, 494, 18, 1, 0),
      (495, 498, 21, 1, 0),
      (499, 502, 18, 2, 0),
      (503, 506, 18, 3, 0),
      (507, 509, -1, 1, 0),
      (510, 513, 25, 1, 0),
      (514, 518, 26, 1, 0),
      (519, 522, 25, 1, 0),
      (523, 527, 28, 1, 0),
      (528, 532, 25, 2, 0),
      (533, 537, 25, 3, 0),
      (538, 542, -1, 1, 0),
      (543, 548, 32, 1, 0),
      (549, 554, -1, 2, 0),
      (555, 556, -1, 1, 0),
      (557, 559, 35, 1, 0),
      (560, 563, 36, 1, 0),
      (564, 566, 35, 1, 0),
      (567, 570, 38, 1, 0),
      (571, 574, 35, 2, 0),
      (575, 578, 35, 3, 0));


   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
   begin
      --  (, line 44
      Z.I_P1 := Z.L;
      --  or, line 51
      v_1 := Z.C;
      --  (, line 48
      In_Grouping (Z, G_V, 97, 369, False, C);
      if C /= 0 then
         goto lab1;
      end if;
            --  goto, line 48
      In_Grouping (Z, G_V, 97, 369, True, C);      if C < 0 then
         goto lab1;
      end if;
      --  or, line 49
      v_2 := Z.C;
      --  among, line 49
      if Z.C + 1 >= Z.L or else Check_Among (Z, Z.C + 1, 3, 16#6080000#) then
         goto lab4;
         --  among, line 49
      end if;
      Find_Among (Z, A_0, Among_String, null, A);
      if A = 0 then
         goto lab4;
      end if;
      goto lab3;

      <<lab4>>
      Z.C := v_2;
      --  next, line 49
      C := Skip_Utf8 (Z);
      if C < 0 then
         goto lab1;
      end if;
      Z.C := C;

      <<lab3>>
      --  setmark p1, line 50
      Z.I_P1 := Z.C;
      goto lab0;

      <<lab1>>
      Z.C := v_1;
      --  (, line 53
      Out_Grouping (Z, G_V, 97, 369, False, C);
      if C /= 0 then
         Result := False;
         return;
      end if;
            --  gopast, line 53
      --  grouping v, line 53
      Out_Grouping (Z, G_V, 97, 369, True, C);
      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C + C;
      --  setmark p1, line 53
      Z.I_P1 := Z.C;

      <<lab0>>

      Result := True;
   end R_Mark_regions;

   procedure R_R1 (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_P1 <= Z.C);
   end R_R1;

   procedure R_V_ending (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 60
      Z.Ket := Z.C;      --  [, line 61

      --  substring, line 61
      if Z.C - 1 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 161 and then Character'Pos (Z.P (Z.C)) /= 169) then
         Result := False;
         return;
         --  substring, line 61
      end if;
      Find_Among_Backward (Z, A_1, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 61

      --  call R1, line 61
      R_R1 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 61
      case A is
         when 1 =>
            --  (, line 62
            --  <-, line 62
            Slice_From (Z, "a");
         when 2 =>
            --  (, line 63
            --  <-, line 63
            Slice_From (Z, "e");
         when others =>
            null;
      end case;

      Result := True;
   end R_V_ending;

   procedure R_Double (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
   begin
      --  (, line 67
      --  test, line 68
      v_1 := Z.L - Z.C;
      --  among, line 68
      if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#65d7cdc#) then
         Result := False;
         return;
         --  among, line 68
      end if;
      Find_Among_Backward (Z, A_2, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.L - v_1;

      Result := True;
   end R_Double;

   procedure R_Undouble (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 72
      --  next, line 73
      C := Skip_Utf8_Backward (Z);
      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      Z.Ket := Z.C;      --  [, line 73

      C := Skip_Utf8_Backward (Z, 1);      --  hop, line 73

      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      Z.Bra := Z.C;      --  ], line 73

      --  delete, line 73
      Slice_Del (Z);

      Result := True;
   end R_Undouble;

   procedure R_Instrum (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 76
      Z.Ket := Z.C;      --  [, line 77

      --  substring, line 77
      if Z.C - 1 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 108 then
         Result := False;
         return;
         --  substring, line 77
      end if;
      Find_Among_Backward (Z, A_3, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 77

      --  call R1, line 77
      R_R1 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  (, line 78
      --  call double, line 78
      R_Double (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  delete, line 81
      Slice_Del (Z);
      --  call undouble, line 82
      R_Undouble (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Instrum;

   procedure R_Case (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 86
      Z.Ket := Z.C;      --  [, line 87

      --  substring, line 87
      Find_Among_Backward (Z, A_4, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 87

      --  call R1, line 87
      R_R1 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  delete, line 111
      Slice_Del (Z);
      --  call v_ending, line 112
      R_V_ending (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Case;

   procedure R_Case_special (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 115
      Z.Ket := Z.C;      --  [, line 116

      --  substring, line 116
      if Z.C - 2 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 110 and then Character'Pos (Z.P (Z.C)) /= 116) then
         Result := False;
         return;
         --  substring, line 116
      end if;
      Find_Among_Backward (Z, A_5, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 116

      --  call R1, line 116
      R_R1 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 116
      case A is
         when 1 =>
            --  (, line 117
            --  <-, line 117
            Slice_From (Z, "e");
         when 2 =>
            --  (, line 118
            --  <-, line 118
            Slice_From (Z, "a");
         when others =>
            null;
      end case;

      Result := True;
   end R_Case_special;

   procedure R_Case_other (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 123
      Z.Ket := Z.C;      --  [, line 124

      --  substring, line 124
      if Z.C - 3 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 108 then
         Result := False;
         return;
         --  substring, line 124
      end if;
      Find_Among_Backward (Z, A_6, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 124

      --  call R1, line 124
      R_R1 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 124
      case A is
         when 1 =>
            --  (, line 125
            --  delete, line 125
            Slice_Del (Z);
         when 2 =>
            --  (, line 127
            --  <-, line 127
            Slice_From (Z, "a");
         when 3 =>
            --  (, line 128
            --  <-, line 128
            Slice_From (Z, "e");
         when others =>
            null;
      end case;

      Result := True;
   end R_Case_other;

   procedure R_Factive (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 132
      Z.Ket := Z.C;      --  [, line 133

      --  substring, line 133
      if Z.C - 1 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 161 and then Character'Pos (Z.P (Z.C)) /= 169) then
         Result := False;
         return;
         --  substring, line 133
      end if;
      Find_Among_Backward (Z, A_7, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 133

      --  call R1, line 133
      R_R1 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  (, line 134
      --  call double, line 134
      R_Double (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  delete, line 137
      Slice_Del (Z);
      --  call undouble, line 138
      R_Undouble (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;

      Result := True;
   end R_Factive;

   procedure R_Plural (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 141
      Z.Ket := Z.C;      --  [, line 142

      --  substring, line 142
      if Z.C <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 107 then
         Result := False;
         return;
         --  substring, line 142
      end if;
      Find_Among_Backward (Z, A_8, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 142

      --  call R1, line 142
      R_R1 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 142
      case A is
         when 1 =>
            --  (, line 143
            --  <-, line 143
            Slice_From (Z, "a");
         when 2 =>
            --  (, line 144
            --  <-, line 144
            Slice_From (Z, "e");
         when 3 =>
            --  (, line 145
            --  delete, line 145
            Slice_Del (Z);
         when others =>
            null;
      end case;

      Result := True;
   end R_Plural;

   procedure R_Owned (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 153
      Z.Ket := Z.C;      --  [, line 154

      --  substring, line 154
      if Z.C - 1 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 105 and then Character'Pos (Z.P (Z.C)) /= 169) then
         Result := False;
         return;
         --  substring, line 154
      end if;
      Find_Among_Backward (Z, A_9, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 154

      --  call R1, line 154
      R_R1 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 154
      case A is
         when 1 =>
            --  (, line 155
            --  delete, line 155
            Slice_Del (Z);
         when 2 =>
            --  (, line 156
            --  <-, line 156
            Slice_From (Z, "e");
         when 3 =>
            --  (, line 157
            --  <-, line 157
            Slice_From (Z, "a");
         when others =>
            null;
      end case;

      Result := True;
   end R_Owned;

   procedure R_Sing_owner (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 167
      Z.Ket := Z.C;      --  [, line 168

      --  substring, line 168
      Find_Among_Backward (Z, A_10, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 168

      --  call R1, line 168
      R_R1 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 168
      case A is
         when 1 =>
            --  (, line 169
            --  delete, line 169
            Slice_Del (Z);
         when 2 =>
            --  (, line 170
            --  <-, line 170
            Slice_From (Z, "a");
         when 3 =>
            --  (, line 171
            --  <-, line 171
            Slice_From (Z, "e");
         when others =>
            null;
      end case;

      Result := True;
   end R_Sing_owner;

   procedure R_Plur_owner (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 192
      Z.Ket := Z.C;      --  [, line 193

      --  substring, line 193
      if Z.C <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#2a10#) then
         Result := False;
         return;
         --  substring, line 193
      end if;
      Find_Among_Backward (Z, A_11, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 193

      --  call R1, line 193
      R_R1 (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 193
      case A is
         when 1 =>
            --  (, line 194
            --  delete, line 194
            Slice_Del (Z);
         when 2 =>
            --  (, line 195
            --  <-, line 195
            Slice_From (Z, "a");
         when 3 =>
            --  (, line 196
            --  <-, line 196
            Slice_From (Z, "e");
         when others =>
            null;
      end case;

      Result := True;
   end R_Plur_owner;

   procedure Stem (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
      v_6 : Char_Index;
      v_7 : Char_Index;
      v_8 : Char_Index;
      v_9 : Char_Index;
      v_10 : Char_Index;
   begin
      --  (, line 228
      --  do, line 229
      v_1 := Z.C;
      --  call mark_regions, line 229
      R_Mark_regions (Z, Result);
      Z.C := v_1;
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 230

      --  (, line 230
      --  do, line 231
      v_2 := Z.L - Z.C;
      --  call instrum, line 231
      R_Instrum (Z, Result);
      Z.C := Z.L - v_2;
      --  do, line 232
      v_3 := Z.L - Z.C;
      --  call case, line 232
      R_Case (Z, Result);
      Z.C := Z.L - v_3;
      --  do, line 233
      v_4 := Z.L - Z.C;
      --  call case_special, line 233
      R_Case_special (Z, Result);
      Z.C := Z.L - v_4;
      --  do, line 234
      v_5 := Z.L - Z.C;
      --  call case_other, line 234
      R_Case_other (Z, Result);
      Z.C := Z.L - v_5;
      --  do, line 235
      v_6 := Z.L - Z.C;
      --  call factive, line 235
      R_Factive (Z, Result);
      Z.C := Z.L - v_6;
      --  do, line 236
      v_7 := Z.L - Z.C;
      --  call owned, line 236
      R_Owned (Z, Result);
      Z.C := Z.L - v_7;
      --  do, line 237
      v_8 := Z.L - Z.C;
      --  call sing_owner, line 237
      R_Sing_owner (Z, Result);
      Z.C := Z.L - v_8;
      --  do, line 238
      v_9 := Z.L - Z.C;
      --  call plur_owner, line 238
      R_Plur_owner (Z, Result);
      Z.C := Z.L - v_9;
      --  do, line 239
      v_10 := Z.L - Z.C;
      --  call plural, line 239
      R_Plural (Z, Result);
      Z.C := Z.L - v_10;
      Z.C := Z.Lb;

      Result := True;
   end Stem;
end Stemmer.Hungarian;
