--  Generated by Snowball 2.0.0 - https://snowballstem.org/

package body Stemmer.Italian is
   procedure R_Vowel_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Verb_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Standard_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Attached_pronoun (Z : in out Context_Type; Result : out Boolean);
   procedure R_R2 (Z : in out Context_Type; Result : out Boolean);
   procedure R_R1 (Z : in out Context_Type; Result : out Boolean);
   procedure R_RV (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean);
   procedure R_Postlude (Z : in out Context_Type; Result : out Boolean);
   procedure R_Prelude (Z : in out Context_Type; Result : out Boolean);

   G_V : constant Grouping_Array (0 .. 159) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, True,
      False, False, False, False, False, False, False, True,
      False, False, False, True, False, False, False, False,
      False, True, False, False, False, False, False, False,
      True, False, False, False, False, False, False, False
   );

   G_AEIO : constant Grouping_Array (0 .. 151) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, True,
      False, False, False, False, False, False, False, True,
      False, False, False, True, False, False, False, False,
      False, True, False, False, False, False, False, False
   );

   G_CG : constant Grouping_Array (0 .. 7) := (
      True, False, False, False, True, False, False, False
   );
   Among_String : constant String := "" & "qu" & "á" & "é" & "í" & "ó"
      & "ú" & "" & "I" & "U" & "la" & "cela" & "gliela" & "mela" & "tela" & "vela"
      & "le" & "cele" & "gliele" & "mele" & "tele" & "vele" & "ne" & "cene" & "gliene"
      & "mene" & "sene" & "tene" & "vene" & "ci" & "li" & "celi" & "glieli" & "meli"
      & "teli" & "veli" & "gli" & "mi" & "si" & "ti" & "vi" & "lo" & "celo" & "glielo"
      & "melo" & "telo" & "velo" & "ando" & "endo" & "ar" & "er" & "ir" & "ic" & "abil"
      & "os" & "iv" & "ic" & "abil" & "iv" & "ica" & "logia" & "osa" & "ista" & "iva"
      & "anza" & "enza" & "ice" & "atrice" & "iche" & "logie" & "abile" & "ibile"
      & "usione" & "azione" & "uzione" & "atore" & "ose" & "ante" & "mente" & "amente"
      & "iste" & "ive" & "anze" & "enze" & "ici" & "atrici" & "ichi" & "abili"
      & "ibili" & "ismi" & "usioni" & "azioni" & "uzioni" & "atori" & "osi" & "anti"
      & "amenti" & "imenti" & "isti" & "ivi" & "ico" & "ismo" & "oso" & "amento"
      & "imento" & "ivo" & "ità" & "istà" & "istè" & "istì" & "isca" & "enda"
      & "ata" & "ita" & "uta" & "ava" & "eva" & "iva" & "erebbe" & "irebbe" & "isce"
      & "ende" & "are" & "ere" & "ire" & "asse" & "ate" & "avate" & "evate" & "ivate"
      & "ete" & "erete" & "irete" & "ite" & "ereste" & "ireste" & "ute" & "erai"
      & "irai" & "isci" & "endi" & "erei" & "irei" & "assi" & "ati" & "iti" & "eresti"
      & "iresti" & "uti" & "avi" & "evi" & "ivi" & "isco" & "ando" & "endo" & "Yamo"
      & "iamo" & "avamo" & "evamo" & "ivamo" & "eremo" & "iremo" & "assimo" & "ammo"
      & "emmo" & "eremmo" & "iremmo" & "immo" & "ano" & "iscano" & "avano" & "evano"
      & "ivano" & "eranno" & "iranno" & "ono" & "iscono" & "arono" & "erono" & "irono"
      & "erebbero" & "irebbero" & "assero" & "essero" & "issero" & "ato" & "ito"
      & "uto" & "avo" & "evo" & "ivo" & "ar" & "ir" & "erà" & "irà" & "erò" & "irò";

   A_0 : constant Among_Array_Type (0 .. 6) := (
      (1, 0, -1, 7),
      (1, 2, 0, 6),
      (3, 4, 0, 1),
      (5, 6, 0, 2),
      (7, 8, 0, 3),
      (9, 10, 0, 4),
      (11, 12, 0, 5));

   A_1 : constant Among_Array_Type (0 .. 2) := (
      (13, 12, -1, 3),
      (13, 13, 0, 1),
      (14, 14, 0, 2));

   A_2 : constant Among_Array_Type (0 .. 36) := (
      (15, 16, -1, -1),
      (17, 20, 0, -1),
      (21, 26, 0, -1),
      (27, 30, 0, -1),
      (31, 34, 0, -1),
      (35, 38, 0, -1),
      (39, 40, -1, -1),
      (41, 44, 6, -1),
      (45, 50, 6, -1),
      (51, 54, 6, -1),
      (55, 58, 6, -1),
      (59, 62, 6, -1),
      (63, 64, -1, -1),
      (65, 68, 12, -1),
      (69, 74, 12, -1),
      (75, 78, 12, -1),
      (79, 82, 12, -1),
      (83, 86, 12, -1),
      (87, 90, 12, -1),
      (91, 92, -1, -1),
      (93, 94, -1, -1),
      (95, 98, 20, -1),
      (99, 104, 20, -1),
      (105, 108, 20, -1),
      (109, 112, 20, -1),
      (113, 116, 20, -1),
      (117, 119, 20, -1),
      (120, 121, -1, -1),
      (122, 123, -1, -1),
      (124, 125, -1, -1),
      (126, 127, -1, -1),
      (128, 129, -1, -1),
      (130, 133, 31, -1),
      (134, 139, 31, -1),
      (140, 143, 31, -1),
      (144, 147, 31, -1),
      (148, 151, 31, -1));

   A_3 : constant Among_Array_Type (0 .. 4) := (
      (152, 155, -1, 1),
      (156, 159, -1, 1),
      (160, 161, -1, 2),
      (162, 163, -1, 2),
      (164, 165, -1, 2));

   A_4 : constant Among_Array_Type (0 .. 3) := (
      (166, 167, -1, -1),
      (168, 171, -1, -1),
      (172, 173, -1, -1),
      (174, 175, -1, 1));

   A_5 : constant Among_Array_Type (0 .. 2) := (
      (176, 177, -1, 1),
      (178, 181, -1, 1),
      (182, 183, -1, 1));

   A_6 : constant Among_Array_Type (0 .. 50) := (
      (184, 186, -1, 1),
      (187, 191, -1, 3),
      (192, 194, -1, 1),
      (195, 198, -1, 1),
      (199, 201, -1, 9),
      (202, 205, -1, 1),
      (206, 209, -1, 5),
      (210, 212, -1, 1),
      (213, 218, 7, 1),
      (219, 222, -1, 1),
      (223, 227, -1, 3),
      (228, 232, -1, 1),
      (233, 237, -1, 1),
      (238, 243, -1, 4),
      (244, 249, -1, 2),
      (250, 255, -1, 4),
      (256, 260, -1, 2),
      (261, 263, -1, 1),
      (264, 267, -1, 1),
      (268, 272, -1, 1),
      (273, 278, 19, 7),
      (279, 282, -1, 1),
      (283, 285, -1, 9),
      (286, 289, -1, 1),
      (290, 293, -1, 5),
      (294, 296, -1, 1),
      (297, 302, 25, 1),
      (303, 306, -1, 1),
      (307, 311, -1, 1),
      (312, 316, -1, 1),
      (317, 320, -1, 1),
      (321, 326, -1, 4),
      (327, 332, -1, 2),
      (333, 338, -1, 4),
      (339, 343, -1, 2),
      (344, 346, -1, 1),
      (347, 350, -1, 1),
      (351, 356, -1, 6),
      (357, 362, -1, 6),
      (363, 366, -1, 1),
      (367, 369, -1, 9),
      (370, 372, -1, 1),
      (373, 376, -1, 1),
      (377, 379, -1, 1),
      (380, 385, -1, 6),
      (386, 391, -1, 6),
      (392, 394, -1, 9),
      (395, 398, -1, 8),
      (399, 403, -1, 1),
      (404, 408, -1, 1),
      (409, 413, -1, 1));

   A_7 : constant Among_Array_Type (0 .. 86) := (
      (414, 417, -1, 1),
      (418, 421, -1, 1),
      (422, 424, -1, 1),
      (425, 427, -1, 1),
      (428, 430, -1, 1),
      (431, 433, -1, 1),
      (434, 436, -1, 1),
      (437, 439, -1, 1),
      (440, 445, -1, 1),
      (446, 451, -1, 1),
      (452, 455, -1, 1),
      (456, 459, -1, 1),
      (460, 462, -1, 1),
      (463, 465, -1, 1),
      (466, 468, -1, 1),
      (469, 472, -1, 1),
      (473, 475, -1, 1),
      (476, 480, 16, 1),
      (481, 485, 16, 1),
      (486, 490, 16, 1),
      (491, 493, -1, 1),
      (494, 498, 20, 1),
      (499, 503, 20, 1),
      (504, 506, -1, 1),
      (507, 512, -1, 1),
      (513, 518, -1, 1),
      (519, 521, -1, 1),
      (522, 525, -1, 1),
      (526, 529, -1, 1),
      (530, 533, -1, 1),
      (534, 537, -1, 1),
      (538, 541, -1, 1),
      (542, 545, -1, 1),
      (546, 549, -1, 1),
      (550, 552, -1, 1),
      (553, 555, -1, 1),
      (556, 561, -1, 1),
      (562, 567, -1, 1),
      (568, 570, -1, 1),
      (571, 573, -1, 1),
      (574, 576, -1, 1),
      (577, 579, -1, 1),
      (580, 583, -1, 1),
      (584, 587, -1, 1),
      (588, 591, -1, 1),
      (592, 595, -1, 1),
      (596, 599, -1, 1),
      (600, 604, -1, 1),
      (605, 609, -1, 1),
      (610, 614, -1, 1),
      (615, 619, -1, 1),
      (620, 624, -1, 1),
      (625, 630, -1, 1),
      (631, 634, -1, 1),
      (635, 638, -1, 1),
      (639, 644, 54, 1),
      (645, 650, 54, 1),
      (651, 654, -1, 1),
      (655, 657, -1, 1),
      (658, 663, 58, 1),
      (664, 668, 58, 1),
      (669, 673, 58, 1),
      (674, 678, 58, 1),
      (679, 684, -1, 1),
      (685, 690, -1, 1),
      (691, 693, -1, 1),
      (694, 699, 65, 1),
      (700, 704, 65, 1),
      (705, 709, 65, 1),
      (710, 714, 65, 1),
      (715, 722, -1, 1),
      (723, 730, -1, 1),
      (731, 736, -1, 1),
      (737, 742, -1, 1),
      (743, 748, -1, 1),
      (749, 751, -1, 1),
      (752, 754, -1, 1),
      (755, 757, -1, 1),
      (758, 760, -1, 1),
      (761, 763, -1, 1),
      (764, 766, -1, 1),
      (767, 768, -1, 1),
      (769, 770, -1, 1),
      (771, 774, -1, 1),
      (775, 778, -1, 1),
      (779, 782, -1, 1),
      (783, 786, -1, 1));


   procedure R_Prelude (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
      v_5 : Integer;
   begin
      --  (, line 34
      --  test, line 35
      v_1 := Z.C;
      --  repeat, line 35

      <<lab0>>

      loop
         v_2 := Z.C;
         --  (, line 35
         Z.Bra := Z.C;         --  [, line 36

         --  substring, line 36
         Find_Among (Z, A_0, Among_String, A);
         if A = 0 then
            goto lab1;
         end if;
         Z.Ket := Z.C;         --  ], line 36

         --  among, line 36
         case A is
            when 1 =>
               --  (, line 37
               --  <-, line 37
               Slice_From (Z, "à");
            when 2 =>
               --  (, line 38
               --  <-, line 38
               Slice_From (Z, "è");
            when 3 =>
               --  (, line 39
               --  <-, line 39
               Slice_From (Z, "ì");
            when 4 =>
               --  (, line 40
               --  <-, line 40
               Slice_From (Z, "ò");
            when 5 =>
               --  (, line 41
               --  <-, line 41
               Slice_From (Z, "ù");
            when 6 =>
               --  (, line 42
               --  <-, line 42
               Slice_From (Z, "qU");
            when 7 =>
               --  (, line 43
               --  next, line 43
               C := Skip_Utf8 (Z, 1);
               if C < 0 then
                  goto lab1;
               end if;
               Z.C := C;
            when others =>
               null;
         end case;
         goto lab0;

         <<lab1>>
         Z.C := v_2;

         exit;
      end loop;
      Z.C := v_1;
      --  repeat, line 46

      <<lab2>>

      loop
         v_3 := Z.C;
         --  goto, line 46
         loop
            v_4 := Z.C;
            --  (, line 46
            In_Grouping (Z, G_V, 97, 249, False, C);
            if C /= 0 then
               goto lab5;
            end if;
            Z.Bra := Z.C;            --  [, line 47

            --  or, line 47
            v_5 := Z.C;
            --  (, line 47
            --  literal, line 47
            C := Eq_S (Z, "u");
            if C = 0 then
               goto lab7;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 47

            In_Grouping (Z, G_V, 97, 249, False, C);
            if C /= 0 then
               goto lab7;
            end if;
            --  <-, line 47
            Slice_From (Z, "U");
            goto lab6;

            <<lab7>>
            Z.C := v_5;
            --  (, line 48
            --  literal, line 48
            C := Eq_S (Z, "i");
            if C = 0 then
               goto lab5;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 48

            In_Grouping (Z, G_V, 97, 249, False, C);
            if C /= 0 then
               goto lab5;
            end if;
            --  <-, line 48
            Slice_From (Z, "I");

            <<lab6>>
            Z.C := v_4;
            exit;

            <<lab5>>
            Z.C := v_4;
            if Z.C >= Z.L then
               goto lab3;
            end if;
            Z.C := Z.C + 1;
         end loop;
         goto lab2;

         <<lab3>>
         Z.C := v_3;

         exit;
      end loop;

      Result := True;
   end R_Prelude;

   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
      v_5 : Integer;
   begin
      --  (, line 52
      Z.I_PV := Z.L;
      Z.I_P1 := Z.L;
      Z.I_P2 := Z.L;
      --  do, line 58
      v_1 := Z.C;
      --  (, line 58
      --  or, line 60
      v_2 := Z.C;
      --  (, line 59
      In_Grouping (Z, G_V, 97, 249, False, C);
      if C /= 0 then
         goto lab2;
      end if;
      --  or, line 59
      v_3 := Z.C;
      --  (, line 59
      Out_Grouping (Z, G_V, 97, 249, False, C);
      if C /= 0 then
         goto lab4;
      end if;
            --  gopast, line 59
      --  grouping v, line 59
      Out_Grouping (Z, G_V, 97, 249, True, C);
      if C < 0 then
         goto lab4;
      end if;
      Z.C := Z.C + C;
      goto lab3;

      <<lab4>>
      Z.C := v_3;
      --  (, line 59
      In_Grouping (Z, G_V, 97, 249, False, C);
      if C /= 0 then
         goto lab2;
      end if;
            --  gopast, line 59
      --  non v, line 59
      In_Grouping (Z, G_V, 97, 249, True, C);
      if C < 0 then
         goto lab2;
      end if;
      Z.C := Z.C + C;

      <<lab3>>
      goto lab1;

      <<lab2>>
      Z.C := v_2;
      --  (, line 61
      Out_Grouping (Z, G_V, 97, 249, False, C);
      if C /= 0 then
         goto lab0;
      end if;
      --  or, line 61
      v_4 := Z.C;
      --  (, line 61
      Out_Grouping (Z, G_V, 97, 249, False, C);
      if C /= 0 then
         goto lab8;
      end if;
            --  gopast, line 61
      --  grouping v, line 61
      Out_Grouping (Z, G_V, 97, 249, True, C);
      if C < 0 then
         goto lab8;
      end if;
      Z.C := Z.C + C;
      goto lab7;

      <<lab8>>
      Z.C := v_4;
      --  (, line 61
      In_Grouping (Z, G_V, 97, 249, False, C);
      if C /= 0 then
         goto lab0;
      end if;
      --  next, line 61
      C := Skip_Utf8 (Z, 1);
      if C < 0 then
         goto lab0;
      end if;
      Z.C := C;

      <<lab7>>

      <<lab1>>
      --  setmark pV, line 62
      Z.I_PV := Z.C;

      <<lab0>>
      Z.C := v_1;
      --  do, line 64
      v_5 := Z.C;
      --  (, line 64
            --  gopast, line 65
      --  grouping v, line 65
      Out_Grouping (Z, G_V, 97, 249, True, C);
      if C < 0 then
         goto lab10;
      end if;
      Z.C := Z.C + C;
            --  gopast, line 65
      --  non v, line 65
      In_Grouping (Z, G_V, 97, 249, True, C);
      if C < 0 then
         goto lab10;
      end if;
      Z.C := Z.C + C;
      --  setmark p1, line 65
      Z.I_P1 := Z.C;
            --  gopast, line 66
      --  grouping v, line 66
      Out_Grouping (Z, G_V, 97, 249, True, C);
      if C < 0 then
         goto lab10;
      end if;
      Z.C := Z.C + C;
            --  gopast, line 66
      --  non v, line 66
      In_Grouping (Z, G_V, 97, 249, True, C);
      if C < 0 then
         goto lab10;
      end if;
      Z.C := Z.C + C;
      --  setmark p2, line 66
      Z.I_P2 := Z.C;

      <<lab10>>
      Z.C := v_5;

      Result := True;
   end R_Mark_regions;

   procedure R_Postlude (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
   begin
      --  repeat, line 70

      <<lab0>>

      loop
         v_1 := Z.C;
         --  (, line 70
         Z.Bra := Z.C;         --  [, line 72

         --  substring, line 72
         if Z.C >= Z.L or else (Character'Pos (Z.P (Z.C)) /= 73 and then Character'Pos (Z.P (Z.C)) /= 85) then
            A := 3;
         else            --  substring, line 72
            Find_Among (Z, A_1, Among_String, A);
            if A = 0 then
               goto lab1;
            end if;
         end if;
         Z.Ket := Z.C;         --  ], line 72

         --  among, line 72
         case A is
            when 1 =>
               --  (, line 73
               --  <-, line 73
               Slice_From (Z, "i");
            when 2 =>
               --  (, line 74
               --  <-, line 74
               Slice_From (Z, "u");
            when 3 =>
               --  (, line 75
               --  next, line 75
               C := Skip_Utf8 (Z, 1);
               if C < 0 then
                  goto lab1;
               end if;
               Z.C := C;
            when others =>
               null;
         end case;
         goto lab0;

         <<lab1>>
         Z.C := v_1;

         exit;
      end loop;

      Result := True;
   end R_Postlude;

   procedure R_RV (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_PV <= Z.C);
   end R_RV;

   procedure R_R1 (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_P1 <= Z.C);
   end R_R1;

   procedure R_R2 (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_P2 <= Z.C);
   end R_R2;

   procedure R_Attached_pronoun (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
   begin
      --  (, line 86
      Z.Ket := Z.C;      --  [, line 87

      --  substring, line 87
      if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#8222#) then
         Result := False;
         return;
         --  substring, line 87
      end if;
      Find_Among_Backward (Z, A_2, Among_String, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 87

      --  among, line 97
      if Z.C - 1 <= Z.Lb or else (Character'Pos (Z.P (Z.C - 1)) /= 111 and then Character'Pos (Z.P (Z.C - 1)) /= 114) then
         Result := False;
         return;
         --  among, line 97
      end if;
      Find_Among_Backward (Z, A_3, Among_String, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      --  (, line 97
      --  call RV, line 97
      R_RV (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  among, line 97
      case A is
         when 1 =>
            --  (, line 98
            --  delete, line 98
            Slice_Del (Z);
         when 2 =>
            --  (, line 99
            --  <-, line 99
            Slice_From (Z, "e");
         when others =>
            null;
      end case;

      Result := True;
   end R_Attached_pronoun;

   procedure R_Standard_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
      v_3 : Integer;
      v_4 : Integer;
   begin
      --  (, line 103
      Z.Ket := Z.C;      --  [, line 104

      --  substring, line 104
      Find_Among_Backward (Z, A_6, Among_String, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 104

      --  among, line 104
      case A is
         when 1 =>
            --  (, line 111
            --  call R2, line 111
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 111
            Slice_Del (Z);
         when 2 =>
            --  (, line 113
            --  call R2, line 113
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 113
            Slice_Del (Z);
            --  try, line 114
            v_1 := Z.L - Z.C;
            --  (, line 114
            Z.Ket := Z.C;            --  [, line 114

            --  literal, line 114
            C := Eq_S_Backward (Z, "ic");
            if C = 0 then
               Z.C := Z.L - v_1;
               goto lab0;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 114

            --  call R2, line 114
            R_R2 (Z, Result);
            if not Result then
               Z.C := Z.L - v_1;
               goto lab0;
            end if;
            --  delete, line 114
            Slice_Del (Z);

            <<lab0>>
         when 3 =>
            --  (, line 117
            --  call R2, line 117
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  <-, line 117
            Slice_From (Z, "log");
         when 4 =>
            --  (, line 119
            --  call R2, line 119
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  <-, line 119
            Slice_From (Z, "u");
         when 5 =>
            --  (, line 121
            --  call R2, line 121
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  <-, line 121
            Slice_From (Z, "ente");
         when 6 =>
            --  (, line 123
            --  call RV, line 123
            R_RV (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 123
            Slice_Del (Z);
         when 7 =>
            --  (, line 124
            --  call R1, line 125
            R_R1 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 125
            Slice_Del (Z);
            --  try, line 126
            v_2 := Z.L - Z.C;
            --  (, line 126
            Z.Ket := Z.C;            --  [, line 127

            --  substring, line 127
            if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#481008#) then
               Z.C := Z.L - v_2;
               goto lab1;
               --  substring, line 127
            end if;
            Find_Among_Backward (Z, A_4, Among_String, A);
            if A = 0 then
               Z.C := Z.L - v_2;
               goto lab1;
            end if;
            Z.Bra := Z.C;            --  ], line 127

            --  call R2, line 127
            R_R2 (Z, Result);
            if not Result then
               Z.C := Z.L - v_2;
               goto lab1;
            end if;
            --  delete, line 127
            Slice_Del (Z);
            --  among, line 127
            case A is
               when 1 =>
                  --  (, line 128
                  Z.Ket := Z.C;                  --  [, line 128

                  --  literal, line 128
                  C := Eq_S_Backward (Z, "at");
                  if C = 0 then
                     Z.C := Z.L - v_2;
                     goto lab1;
                  end if;
                  Z.C := Z.C - C;
                  Z.Bra := Z.C;                  --  ], line 128

                  --  call R2, line 128
                  R_R2 (Z, Result);
                  if not Result then
                     Z.C := Z.L - v_2;
                     goto lab1;
                  end if;
                  --  delete, line 128
                  Slice_Del (Z);
               when others =>
                  null;
            end case;

            <<lab1>>
         when 8 =>
            --  (, line 133
            --  call R2, line 134
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 134
            Slice_Del (Z);
            --  try, line 135
            v_3 := Z.L - Z.C;
            --  (, line 135
            Z.Ket := Z.C;            --  [, line 136

            --  substring, line 136
            if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#401008#) then
               Z.C := Z.L - v_3;
               goto lab2;
               --  substring, line 136
            end if;
            Find_Among_Backward (Z, A_5, Among_String, A);
            if A = 0 then
               Z.C := Z.L - v_3;
               goto lab2;
            end if;
            Z.Bra := Z.C;            --  ], line 136

            --  (, line 137
            --  call R2, line 137
            R_R2 (Z, Result);
            if not Result then
               Z.C := Z.L - v_3;
               goto lab2;
            end if;
            --  delete, line 137
            Slice_Del (Z);

            <<lab2>>
         when 9 =>
            --  (, line 141
            --  call R2, line 142
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 142
            Slice_Del (Z);
            --  try, line 143
            v_4 := Z.L - Z.C;
            --  (, line 143
            Z.Ket := Z.C;            --  [, line 143

            --  literal, line 143
            C := Eq_S_Backward (Z, "at");
            if C = 0 then
               Z.C := Z.L - v_4;
               goto lab3;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 143

            --  call R2, line 143
            R_R2 (Z, Result);
            if not Result then
               Z.C := Z.L - v_4;
               goto lab3;
            end if;
            --  delete, line 143
            Slice_Del (Z);
            Z.Ket := Z.C;            --  [, line 143

            --  literal, line 143
            C := Eq_S_Backward (Z, "ic");
            if C = 0 then
               Z.C := Z.L - v_4;
               goto lab3;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 143

            --  call R2, line 143
            R_R2 (Z, Result);
            if not Result then
               Z.C := Z.L - v_4;
               goto lab3;
            end if;
            --  delete, line 143
            Slice_Del (Z);

            <<lab3>>
         when others =>
            null;
      end case;

      Result := True;
   end R_Standard_suffix;

   procedure R_Verb_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_2 : Integer;
   begin
      if Z.C < Z.I_PV then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_PV;
      --  (, line 148
      Z.Ket := Z.C;      --  [, line 149

      --  substring, line 149
      Find_Among_Backward (Z, A_7, Among_String, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 149

      --  (, line 163
      --  delete, line 163
      Slice_Del (Z);
      Z.Lb := v_2;

      Result := True;
   end R_Verb_suffix;

   procedure R_Vowel_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_2 : Integer;
   begin
      --  (, line 170
      --  try, line 171
      v_1 := Z.L - Z.C;
      --  (, line 171
      Z.Ket := Z.C;      --  [, line 172

      In_Grouping_Backward (Z, G_AEIO, 97, 242, False, C);
      if C /= 0 then
         Z.C := Z.L - v_1;
         goto lab0;
      end if;
      Z.Bra := Z.C;      --  ], line 172

      --  call RV, line 172
      R_RV (Z, Result);
      if not Result then
         Z.C := Z.L - v_1;
         goto lab0;
      end if;
      --  delete, line 172
      Slice_Del (Z);
      Z.Ket := Z.C;      --  [, line 173

      --  literal, line 173
      C := Eq_S_Backward (Z, "i");
      if C = 0 then
         Z.C := Z.L - v_1;
         goto lab0;
      end if;
      Z.C := Z.C - C;
      Z.Bra := Z.C;      --  ], line 173

      --  call RV, line 173
      R_RV (Z, Result);
      if not Result then
         Z.C := Z.L - v_1;
         goto lab0;
      end if;
      --  delete, line 173
      Slice_Del (Z);

      <<lab0>>
      --  try, line 175
      v_2 := Z.L - Z.C;
      --  (, line 175
      Z.Ket := Z.C;      --  [, line 176

      --  literal, line 176
      C := Eq_S_Backward (Z, "h");
      if C = 0 then
         Z.C := Z.L - v_2;
         goto lab1;
      end if;
      Z.C := Z.C - C;
      Z.Bra := Z.C;      --  ], line 176

      In_Grouping_Backward (Z, G_CG, 99, 103, False, C);
      if C /= 0 then
         Z.C := Z.L - v_2;
         goto lab1;
      end if;
      --  call RV, line 176
      R_RV (Z, Result);
      if not Result then
         Z.C := Z.L - v_2;
         goto lab1;
      end if;
      --  delete, line 176
      Slice_Del (Z);

      <<lab1>>

      Result := True;
   end R_Vowel_suffix;

   procedure Stem (Z : in out Context_Type; Result : out Boolean) is
      C : Integer;
      A : Integer;
      v_1 : Integer;
      v_3 : Integer;
      v_4 : Integer;
      v_5 : Integer;
      v_6 : Integer;
      v_7 : Integer;
   begin
      --  (, line 181
      --  do, line 182
      v_1 := Z.C;
      --  call prelude, line 182
      R_Prelude (Z, Result);
      Z.C := v_1;
      --  do, line 183
      --  call mark_regions, line 183
      R_Mark_regions (Z, Result);
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 184

      --  (, line 184
      --  do, line 185
      v_3 := Z.L - Z.C;
      --  call attached_pronoun, line 185
      R_Attached_pronoun (Z, Result);
      Z.C := Z.L - v_3;
      --  do, line 186
      v_4 := Z.L - Z.C;
      --  (, line 186
      --  or, line 186
      v_5 := Z.L - Z.C;
      --  call standard_suffix, line 186
      R_Standard_suffix (Z, Result);
      if not Result then
         goto lab2;
      end if;
      goto lab1;

      <<lab2>>
      Z.C := Z.L - v_5;
      --  call verb_suffix, line 186
      R_Verb_suffix (Z, Result);
      if not Result then
         goto lab0;
      end if;

      <<lab1>>

      <<lab0>>
      Z.C := Z.L - v_4;
      --  do, line 187
      v_6 := Z.L - Z.C;
      --  call vowel_suffix, line 187
      R_Vowel_suffix (Z, Result);
      Z.C := Z.L - v_6;
      Z.C := Z.Lb;
      --  do, line 189
      v_7 := Z.C;
      --  call postlude, line 189
      R_Postlude (Z, Result);
      Z.C := v_7;

      Result := True;
   end Stem;
end Stemmer.Italian;
