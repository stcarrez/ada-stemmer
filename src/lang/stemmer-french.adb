--  Generated by Snowball 2.0.0 - https://snowballstem.org/

package body Stemmer.French is

   pragma Style_Checks ("-mr");
   pragma Warnings (Off, "*variable*is never read and never assigned*");
   pragma Warnings (Off, "*mode could be*instead of*");
   pragma Warnings (Off, "*formal parameter.*is not modified*");
   pragma Warnings (Off, "*this line is too long*");
   pragma Warnings (Off, "*is not referenced*");

   procedure R_Un_accent (Z : in out Context_Type; Result : out Boolean);
   procedure R_Un_double (Z : in out Context_Type; Result : out Boolean);
   procedure R_Residual_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Verb_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_I_verb_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Standard_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_R2 (Z : in out Context_Type; Result : out Boolean);
   procedure R_R1 (Z : in out Context_Type; Result : out Boolean);
   procedure R_RV (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean);
   procedure R_Postlude (Z : in out Context_Type; Result : out Boolean);
   procedure R_Prelude (Z : in out Context_Type; Result : out Boolean);

   G_V : constant Grouping_Array (0 .. 159) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      True, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, True,
      False, True, False, False, False, False, False, True,
      True, True, True, False, False, True, True, False,
      False, False, False, True, False, False, False, False,
      True, False, True, False, False, False, False, False
   );

   G_Keep_with_s : constant Grouping_Array (0 .. 135) := (
      True, False, False, False, False, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, True, False, True, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, True
   );
   Among_String : constant String := "col" & "par" & "tap" & "" & "H" & "He" & "Hi" & "I" & "U" & "Y" & "iqU" & "abl"
      & "Ièr" & "ièr" & "eus" & "iv" & "ic" & "abil" & "iv" & "iqUe" & "atrice"
      & "ance" & "ence" & "logie" & "able" & "isme" & "euse" & "iste" & "ive" & "if"
      & "usion" & "ation" & "ution" & "ateur" & "iqUes" & "atrices" & "ances" & "ences"
      & "logies" & "ables" & "ismes" & "euses" & "istes" & "ives" & "ifs" & "usions"
      & "ations" & "utions" & "ateurs" & "ments" & "ements" & "issements" & "ités"
      & "ment" & "ement" & "issement" & "amment" & "emment" & "aux" & "eaux" & "eux"
      & "ité" & "ira" & "ie" & "isse" & "issante" & "i" & "irai" & "ir" & "iras"
      & "ies" & "îmes" & "isses" & "issantes" & "îtes" & "is" & "irais" & "issais"
      & "irions" & "issions" & "irons" & "issons" & "issants" & "it" & "irait"
      & "issait" & "issant" & "iraIent" & "issaIent" & "irent" & "issent" & "iront"
      & "ît" & "iriez" & "issiez" & "irez" & "issez" & "a" & "era" & "asse" & "ante"
      & "ée" & "ai" & "erai" & "er" & "as" & "eras" & "âmes" & "asses" & "antes"
      & "âtes" & "ées" & "ais" & "erais" & "ions" & "erions" & "assions" & "erons"
      & "ants" & "és" & "ait" & "erait" & "ant" & "aIent" & "eraIent" & "èrent"
      & "assent" & "eront" & "ât" & "ez" & "iez" & "eriez" & "assiez" & "erez" & "é"
      & "e" & "Ière" & "ière" & "ion" & "Ier" & "ier" & "ell" & "eill" & "enn"
      & "onn" & "ett";

   A_0 : constant Among_Array_Type (0 .. 2) := (
      (1, 3, -1, -1, 0),
      (4, 6, -1, -1, 0),
      (7, 9, -1, -1, 0));

   A_1 : constant Among_Array_Type (0 .. 6) := (
      (10, 9, -1, 7, 0),
      (10, 10, 0, 6, 0),
      (11, 12, 1, 4, 0),
      (13, 14, 1, 5, 0),
      (15, 15, 0, 1, 0),
      (16, 16, 0, 2, 0),
      (17, 17, 0, 3, 0));

   A_2 : constant Among_Array_Type (0 .. 5) := (
      (18, 20, -1, 3, 0),
      (21, 23, -1, 3, 0),
      (24, 27, -1, 4, 0),
      (28, 31, -1, 4, 0),
      (32, 34, -1, 2, 0),
      (35, 36, -1, 1, 0));

   A_3 : constant Among_Array_Type (0 .. 2) := (
      (37, 38, -1, 2, 0),
      (39, 42, -1, 1, 0),
      (43, 44, -1, 3, 0));

   A_4 : constant Among_Array_Type (0 .. 42) := (
      (45, 48, -1, 1, 0),
      (49, 54, -1, 2, 0),
      (55, 58, -1, 1, 0),
      (59, 62, -1, 5, 0),
      (63, 67, -1, 3, 0),
      (68, 71, -1, 1, 0),
      (72, 75, -1, 1, 0),
      (76, 79, -1, 11, 0),
      (80, 83, -1, 1, 0),
      (84, 86, -1, 8, 0),
      (87, 88, -1, 8, 0),
      (89, 93, -1, 4, 0),
      (94, 98, -1, 2, 0),
      (99, 103, -1, 4, 0),
      (104, 108, -1, 2, 0),
      (109, 113, -1, 1, 0),
      (114, 120, -1, 2, 0),
      (121, 125, -1, 1, 0),
      (126, 130, -1, 5, 0),
      (131, 136, -1, 3, 0),
      (137, 141, -1, 1, 0),
      (142, 146, -1, 1, 0),
      (147, 151, -1, 11, 0),
      (152, 156, -1, 1, 0),
      (157, 160, -1, 8, 0),
      (161, 163, -1, 8, 0),
      (164, 169, -1, 4, 0),
      (170, 175, -1, 2, 0),
      (176, 181, -1, 4, 0),
      (182, 187, -1, 2, 0),
      (188, 192, -1, 15, 0),
      (193, 198, 30, 6, 0),
      (199, 207, 31, 12, 0),
      (208, 212, -1, 7, 0),
      (213, 216, -1, 15, 0),
      (217, 221, 34, 6, 0),
      (222, 229, 35, 12, 0),
      (230, 235, 34, 13, 0),
      (236, 241, 34, 14, 0),
      (242, 244, -1, 10, 0),
      (245, 248, 39, 9, 0),
      (249, 251, -1, 1, 0),
      (252, 255, -1, 7, 0));

   A_5 : constant Among_Array_Type (0 .. 34) := (
      (256, 258, -1, 1, 0),
      (259, 260, -1, 1, 0),
      (261, 264, -1, 1, 0),
      (265, 271, -1, 1, 0),
      (272, 272, -1, 1, 0),
      (273, 276, 4, 1, 0),
      (277, 278, -1, 1, 0),
      (279, 282, -1, 1, 0),
      (283, 285, -1, 1, 0),
      (286, 290, -1, 1, 0),
      (291, 295, -1, 1, 0),
      (296, 303, -1, 1, 0),
      (304, 308, -1, 1, 0),
      (309, 310, -1, 1, 0),
      (311, 315, 13, 1, 0),
      (316, 321, 13, 1, 0),
      (322, 327, -1, 1, 0),
      (328, 334, -1, 1, 0),
      (335, 339, -1, 1, 0),
      (340, 345, -1, 1, 0),
      (346, 352, -1, 1, 0),
      (353, 354, -1, 1, 0),
      (355, 359, 21, 1, 0),
      (360, 365, 21, 1, 0),
      (366, 371, -1, 1, 0),
      (372, 378, -1, 1, 0),
      (379, 386, -1, 1, 0),
      (387, 391, -1, 1, 0),
      (392, 397, -1, 1, 0),
      (398, 402, -1, 1, 0),
      (403, 405, -1, 1, 0),
      (406, 410, -1, 1, 0),
      (411, 416, -1, 1, 0),
      (417, 420, -1, 1, 0),
      (421, 425, -1, 1, 0));

   A_6 : constant Among_Array_Type (0 .. 37) := (
      (426, 426, -1, 3, 0),
      (427, 429, 0, 2, 0),
      (430, 433, -1, 3, 0),
      (434, 437, -1, 3, 0),
      (438, 440, -1, 2, 0),
      (441, 442, -1, 3, 0),
      (443, 446, 5, 2, 0),
      (447, 448, -1, 2, 0),
      (449, 450, -1, 3, 0),
      (451, 454, 8, 2, 0),
      (455, 459, -1, 3, 0),
      (460, 464, -1, 3, 0),
      (465, 469, -1, 3, 0),
      (470, 474, -1, 3, 0),
      (475, 478, -1, 2, 0),
      (479, 481, -1, 3, 0),
      (482, 486, 15, 2, 0),
      (487, 490, -1, 1, 0),
      (491, 496, 17, 2, 0),
      (497, 503, 17, 3, 0),
      (504, 508, -1, 2, 0),
      (509, 512, -1, 3, 0),
      (513, 515, -1, 2, 0),
      (516, 518, -1, 3, 0),
      (519, 523, 23, 2, 0),
      (524, 526, -1, 3, 0),
      (527, 531, -1, 3, 0),
      (532, 538, 26, 2, 0),
      (539, 544, -1, 2, 0),
      (545, 550, -1, 3, 0),
      (551, 555, -1, 2, 0),
      (556, 558, -1, 3, 0),
      (559, 560, -1, 2, 0),
      (561, 563, 32, 2, 0),
      (564, 568, 33, 2, 0),
      (569, 574, 33, 3, 0),
      (575, 578, 32, 2, 0),
      (579, 580, -1, 2, 0));

   A_7 : constant Among_Array_Type (0 .. 5) := (
      (581, 581, -1, 3, 0),
      (582, 586, 0, 2, 0),
      (587, 591, 0, 2, 0),
      (592, 594, -1, 1, 0),
      (595, 597, -1, 2, 0),
      (598, 600, -1, 2, 0));

   A_8 : constant Among_Array_Type (0 .. 4) := (
      (601, 603, -1, -1, 0),
      (604, 607, -1, -1, 0),
      (608, 610, -1, -1, 0),
      (611, 613, -1, -1, 0),
      (614, 616, -1, -1, 0));


   procedure R_Prelude (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
   begin
      --  repeat, line 38

      <<lab0>>

      loop
         v_1 := Z.C;
         --  goto, line 38
         loop
            v_2 := Z.C;
            --  (, line 38
            --  or, line 44
            v_3 := Z.C;
            --  (, line 40
            In_Grouping (Z, G_V, 97, 251, False, C);
            if C /= 0 then
               goto lab5;
            end if;
            Z.Bra := Z.C;            --  [, line 40

            --  or, line 40
            v_4 := Z.C;
            --  (, line 40
            --  literal, line 40
            C := Eq_S (Z, "u");
            if C = 0 then
               goto lab7;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 40

            In_Grouping (Z, G_V, 97, 251, False, C);
            if C /= 0 then
               goto lab7;
            end if;
            --  <-, line 40
            Slice_From (Z, "U");
            goto lab6;

            <<lab7>>
            Z.C := v_4;
            --  (, line 41
            --  literal, line 41
            C := Eq_S (Z, "i");
            if C = 0 then
               goto lab8;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 41

            In_Grouping (Z, G_V, 97, 251, False, C);
            if C /= 0 then
               goto lab8;
            end if;
            --  <-, line 41
            Slice_From (Z, "I");
            goto lab6;

            <<lab8>>
            Z.C := v_4;
            --  (, line 42
            --  literal, line 42
            C := Eq_S (Z, "y");
            if C = 0 then
               goto lab5;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 42

            --  <-, line 42
            Slice_From (Z, "Y");

            <<lab6>>
            goto lab4;

            <<lab5>>
            Z.C := v_3;
            --  (, line 45
            Z.Bra := Z.C;            --  [, line 45

            --  literal, line 45
            C := Eq_S (Z, "ë");
            if C = 0 then
               goto lab9;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 45

            --  <-, line 45
            Slice_From (Z, "He");
            goto lab4;

            <<lab9>>
            Z.C := v_3;
            --  (, line 47
            Z.Bra := Z.C;            --  [, line 47

            --  literal, line 47
            C := Eq_S (Z, "ï");
            if C = 0 then
               goto lab10;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 47

            --  <-, line 47
            Slice_From (Z, "Hi");
            goto lab4;

            <<lab10>>
            Z.C := v_3;
            --  (, line 49
            Z.Bra := Z.C;            --  [, line 49

            --  literal, line 49
            C := Eq_S (Z, "y");
            if C = 0 then
               goto lab11;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 49

            In_Grouping (Z, G_V, 97, 251, False, C);
            if C /= 0 then
               goto lab11;
            end if;
            --  <-, line 49
            Slice_From (Z, "Y");
            goto lab4;

            <<lab11>>
            Z.C := v_3;
            --  (, line 51
            --  literal, line 51
            C := Eq_S (Z, "q");
            if C = 0 then
               goto lab3;
            end if;
            Z.C := Z.C + C;
            Z.Bra := Z.C;            --  [, line 51

            --  literal, line 51
            C := Eq_S (Z, "u");
            if C = 0 then
               goto lab3;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 51

            --  <-, line 51
            Slice_From (Z, "U");

            <<lab4>>
            Z.C := v_2;
            exit;

            <<lab3>>
            Z.C := v_2;
            if Z.C >= Z.L then
               goto lab1;
            end if;
            --  goto, line 38
            C := Skip_Utf8 (Z);
            if C < 0 then
               goto lab1;
            end if;
            Z.C := C;
         end loop;
         goto lab0;

         <<lab1>>
         Z.C := v_1;

         exit;
      end loop;

      Result := True;
   end R_Prelude;

   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
   begin
      --  (, line 54
      Z.I_PV := Z.L;
      Z.I_P1 := Z.L;
      Z.I_P2 := Z.L;
      --  do, line 60
      v_1 := Z.C;
      --  (, line 60
      --  or, line 62
      v_2 := Z.C;
      --  (, line 61
      In_Grouping (Z, G_V, 97, 251, False, C);
      if C /= 0 then
         goto lab2;
      end if;
      In_Grouping (Z, G_V, 97, 251, False, C);
      if C /= 0 then
         goto lab2;
      end if;
      --  next, line 61
      C := Skip_Utf8 (Z);
      if C < 0 then
         goto lab2;
      end if;
      Z.C := C;
      goto lab1;

      <<lab2>>
      Z.C := v_2;
      --  among, line 63
      if Z.C + 2 >= Z.L or else Check_Among (Z, Z.C + 2, 3, 16#51000#) then
         goto lab3;
         --  among, line 63
      end if;
      Find_Among (Z, A_0, Among_String, null, A);
      if A = 0 then
         goto lab3;
      end if;
      goto lab1;

      <<lab3>>
      Z.C := v_2;
      --  (, line 70
      --  next, line 70
      C := Skip_Utf8 (Z);
      if C < 0 then
         goto lab0;
      end if;
      Z.C := C;
            --  gopast, line 70
      --  grouping v, line 70
      Out_Grouping (Z, G_V, 97, 251, True, C);
      if C < 0 then
         goto lab0;
      end if;
      Z.C := Z.C + C;

      <<lab1>>
      --  setmark pV, line 71
      Z.I_PV := Z.C;

      <<lab0>>
      Z.C := v_1;
      --  do, line 73
      v_3 := Z.C;
      --  (, line 73
            --  gopast, line 74
      --  grouping v, line 74
      Out_Grouping (Z, G_V, 97, 251, True, C);
      if C < 0 then
         goto lab5;
      end if;
      Z.C := Z.C + C;
            --  gopast, line 74
      --  non v, line 74
      In_Grouping (Z, G_V, 97, 251, True, C);
      if C < 0 then
         goto lab5;
      end if;
      Z.C := Z.C + C;
      --  setmark p1, line 74
      Z.I_P1 := Z.C;
            --  gopast, line 75
      --  grouping v, line 75
      Out_Grouping (Z, G_V, 97, 251, True, C);
      if C < 0 then
         goto lab5;
      end if;
      Z.C := Z.C + C;
            --  gopast, line 75
      --  non v, line 75
      In_Grouping (Z, G_V, 97, 251, True, C);
      if C < 0 then
         goto lab5;
      end if;
      Z.C := Z.C + C;
      --  setmark p2, line 75
      Z.I_P2 := Z.C;

      <<lab5>>
      Z.C := v_3;

      Result := True;
   end R_Mark_regions;

   procedure R_Postlude (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
   begin
      --  repeat, line 79

      <<lab0>>

      loop
         v_1 := Z.C;
         --  (, line 79
         Z.Bra := Z.C;         --  [, line 81

         --  substring, line 81
         if Z.C >= Z.L or else Check_Among (Z, Z.C, 2, 16#2200300#) then
            A := 7;
         else            --  substring, line 81
            Find_Among (Z, A_1, Among_String, null, A);
            if A = 0 then
               goto lab1;
            end if;
         end if;
         Z.Ket := Z.C;         --  ], line 81

         --  among, line 81
         case A is
            when 1 =>
               --  (, line 82
               --  <-, line 82
               Slice_From (Z, "i");
            when 2 =>
               --  (, line 83
               --  <-, line 83
               Slice_From (Z, "u");
            when 3 =>
               --  (, line 84
               --  <-, line 84
               Slice_From (Z, "y");
            when 4 =>
               --  (, line 85
               --  <-, line 85
               Slice_From (Z, "ë");
            when 5 =>
               --  (, line 86
               --  <-, line 86
               Slice_From (Z, "ï");
            when 6 =>
               --  (, line 87
               --  delete, line 87
               Slice_Del (Z);
            when 7 =>
               --  (, line 88
               --  next, line 88
               C := Skip_Utf8 (Z);
               if C < 0 then
                  goto lab1;
               end if;
               Z.C := C;
            when others =>
               null;
         end case;
         goto lab0;

         <<lab1>>
         Z.C := v_1;

         exit;
      end loop;

      Result := True;
   end R_Postlude;

   procedure R_RV (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_PV <= Z.C);
   end R_RV;

   procedure R_R1 (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_P1 <= Z.C);
   end R_R1;

   procedure R_R2 (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_P2 <= Z.C);
   end R_R2;

   procedure R_Standard_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
      v_6 : Char_Index;
      v_7 : Char_Index;
      v_8 : Char_Index;
      v_9 : Char_Index;
      v_10 : Char_Index;
      v_11 : Char_Index;
   begin
      --  (, line 98
      Z.Ket := Z.C;      --  [, line 99

      --  substring, line 99
      Find_Among_Backward (Z, A_4, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 99

      --  among, line 99
      case A is
         when 1 =>
            --  (, line 103
            --  call R2, line 103
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 103
            Slice_Del (Z);
         when 2 =>
            --  (, line 106
            --  call R2, line 106
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 106
            Slice_Del (Z);
            --  try, line 107
            v_1 := Z.L - Z.C;
            --  (, line 107
            Z.Ket := Z.C;            --  [, line 107

            --  literal, line 107
            C := Eq_S_Backward (Z, "ic");
            if C = 0 then
               Z.C := Z.L - v_1;
               goto lab0;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 107

            --  or, line 107
            v_2 := Z.L - Z.C;
            --  (, line 107
            --  call R2, line 107
            R_R2 (Z, Result);
            if not Result then
               goto lab2;
            end if;
            --  delete, line 107
            Slice_Del (Z);
            goto lab1;

            <<lab2>>
            Z.C := Z.L - v_2;
            --  <-, line 107
            Slice_From (Z, "iqU");

            <<lab1>>

            <<lab0>>
         when 3 =>
            --  (, line 111
            --  call R2, line 111
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  <-, line 111
            Slice_From (Z, "log");
         when 4 =>
            --  (, line 114
            --  call R2, line 114
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  <-, line 114
            Slice_From (Z, "u");
         when 5 =>
            --  (, line 117
            --  call R2, line 117
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  <-, line 117
            Slice_From (Z, "ent");
         when 6 =>
            --  (, line 120
            --  call RV, line 121
            R_RV (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 121
            Slice_Del (Z);
            --  try, line 122
            v_3 := Z.L - Z.C;
            --  (, line 122
            Z.Ket := Z.C;            --  [, line 123

            --  substring, line 123
            Find_Among_Backward (Z, A_2, Among_String, null, A);
            if A = 0 then
               Z.C := Z.L - v_3;
               goto lab3;
            end if;
            Z.Bra := Z.C;            --  ], line 123

            --  among, line 123
            case A is
               when 1 =>
                  --  (, line 124
                  --  call R2, line 124
                  R_R2 (Z, Result);
                  if not Result then
                     Z.C := Z.L - v_3;
                     goto lab3;
                  end if;
                  --  delete, line 124
                  Slice_Del (Z);
                  Z.Ket := Z.C;                  --  [, line 124

                  --  literal, line 124
                  C := Eq_S_Backward (Z, "at");
                  if C = 0 then
                     Z.C := Z.L - v_3;
                     goto lab3;
                  end if;
                  Z.C := Z.C - C;
                  Z.Bra := Z.C;                  --  ], line 124

                  --  call R2, line 124
                  R_R2 (Z, Result);
                  if not Result then
                     Z.C := Z.L - v_3;
                     goto lab3;
                  end if;
                  --  delete, line 124
                  Slice_Del (Z);
               when 2 =>
                  --  (, line 125
                  --  or, line 125
                  v_4 := Z.L - Z.C;
                  --  (, line 125
                  --  call R2, line 125
                  R_R2 (Z, Result);
                  if not Result then
                     goto lab5;
                  end if;
                  --  delete, line 125
                  Slice_Del (Z);
                  goto lab4;

                  <<lab5>>
                  Z.C := Z.L - v_4;
                  --  (, line 125
                  --  call R1, line 125
                  R_R1 (Z, Result);
                  if not Result then
                     Z.C := Z.L - v_3;
                     goto lab3;
                  end if;
                  --  <-, line 125
                  Slice_From (Z, "eux");

                  <<lab4>>
               when 3 =>
                  --  (, line 127
                  --  call R2, line 127
                  R_R2 (Z, Result);
                  if not Result then
                     Z.C := Z.L - v_3;
                     goto lab3;
                  end if;
                  --  delete, line 127
                  Slice_Del (Z);
               when 4 =>
                  --  (, line 129
                  --  call RV, line 129
                  R_RV (Z, Result);
                  if not Result then
                     Z.C := Z.L - v_3;
                     goto lab3;
                  end if;
                  --  <-, line 129
                  Slice_From (Z, "i");
               when others =>
                  null;
            end case;

            <<lab3>>
         when 7 =>
            --  (, line 135
            --  call R2, line 136
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 136
            Slice_Del (Z);
            --  try, line 137
            v_5 := Z.L - Z.C;
            --  (, line 137
            Z.Ket := Z.C;            --  [, line 138

            --  substring, line 138
            if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#401008#) then
               Z.C := Z.L - v_5;
               goto lab6;
               --  substring, line 138
            end if;
            Find_Among_Backward (Z, A_3, Among_String, null, A);
            if A = 0 then
               Z.C := Z.L - v_5;
               goto lab6;
            end if;
            Z.Bra := Z.C;            --  ], line 138

            --  among, line 138
            case A is
               when 1 =>
                  --  (, line 139
                  --  or, line 139
                  v_6 := Z.L - Z.C;
                  --  (, line 139
                  --  call R2, line 139
                  R_R2 (Z, Result);
                  if not Result then
                     goto lab8;
                  end if;
                  --  delete, line 139
                  Slice_Del (Z);
                  goto lab7;

                  <<lab8>>
                  Z.C := Z.L - v_6;
                  --  <-, line 139
                  Slice_From (Z, "abl");

                  <<lab7>>
               when 2 =>
                  --  (, line 140
                  --  or, line 140
                  v_7 := Z.L - Z.C;
                  --  (, line 140
                  --  call R2, line 140
                  R_R2 (Z, Result);
                  if not Result then
                     goto lab10;
                  end if;
                  --  delete, line 140
                  Slice_Del (Z);
                  goto lab9;

                  <<lab10>>
                  Z.C := Z.L - v_7;
                  --  <-, line 140
                  Slice_From (Z, "iqU");

                  <<lab9>>
               when 3 =>
                  --  (, line 141
                  --  call R2, line 141
                  R_R2 (Z, Result);
                  if not Result then
                     Z.C := Z.L - v_5;
                     goto lab6;
                  end if;
                  --  delete, line 141
                  Slice_Del (Z);
               when others =>
                  null;
            end case;

            <<lab6>>
         when 8 =>
            --  (, line 147
            --  call R2, line 148
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 148
            Slice_Del (Z);
            --  try, line 149
            v_8 := Z.L - Z.C;
            --  (, line 149
            Z.Ket := Z.C;            --  [, line 149

            --  literal, line 149
            C := Eq_S_Backward (Z, "at");
            if C = 0 then
               Z.C := Z.L - v_8;
               goto lab11;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 149

            --  call R2, line 149
            R_R2 (Z, Result);
            if not Result then
               Z.C := Z.L - v_8;
               goto lab11;
            end if;
            --  delete, line 149
            Slice_Del (Z);
            Z.Ket := Z.C;            --  [, line 149

            --  literal, line 149
            C := Eq_S_Backward (Z, "ic");
            if C = 0 then
               Z.C := Z.L - v_8;
               goto lab11;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 149

            --  or, line 149
            v_9 := Z.L - Z.C;
            --  (, line 149
            --  call R2, line 149
            R_R2 (Z, Result);
            if not Result then
               goto lab13;
            end if;
            --  delete, line 149
            Slice_Del (Z);
            goto lab12;

            <<lab13>>
            Z.C := Z.L - v_9;
            --  <-, line 149
            Slice_From (Z, "iqU");

            <<lab12>>

            <<lab11>>
         when 9 =>
            --  (, line 151
            --  <-, line 151
            Slice_From (Z, "eau");
         when 10 =>
            --  (, line 152
            --  call R1, line 152
            R_R1 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  <-, line 152
            Slice_From (Z, "al");
         when 11 =>
            --  (, line 154
            --  or, line 154
            v_10 := Z.L - Z.C;
            --  (, line 154
            --  call R2, line 154
            R_R2 (Z, Result);
            if not Result then
               goto lab15;
            end if;
            --  delete, line 154
            Slice_Del (Z);
            goto lab14;

            <<lab15>>
            Z.C := Z.L - v_10;
            --  (, line 154
            --  call R1, line 154
            R_R1 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  <-, line 154
            Slice_From (Z, "eux");

            <<lab14>>
         when 12 =>
            --  (, line 157
            --  call R1, line 157
            R_R1 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            Out_Grouping_Backward (Z, G_V, 97, 251, False, C);
            if C /= 0 then
               Result := False;
               return;
            end if;
            --  delete, line 157
            Slice_Del (Z);
         when 13 =>
            --  (, line 162
            --  call RV, line 162
            R_RV (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  fail, line 162
            --  (, line 162
            --  <-, line 162
            Slice_From (Z, "ant");
            Result := False;
            return;
         when 14 =>
            --  (, line 163
            --  call RV, line 163
            R_RV (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  fail, line 163
            --  (, line 163
            --  <-, line 163
            Slice_From (Z, "ent");
            Result := False;
            return;
         when 15 =>
            --  (, line 165
            --  test, line 165
            v_11 := Z.L - Z.C;
            --  (, line 165
            In_Grouping_Backward (Z, G_V, 97, 251, False, C);
            if C /= 0 then
               Result := False;
               return;
            end if;
            --  call RV, line 165
            R_RV (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            Z.C := Z.L - v_11;
            --  fail, line 165
            --  (, line 165
            --  delete, line 165
            Slice_Del (Z);
            Result := False;
            return;
         when others =>
            null;
      end case;

      Result := True;
   end R_Standard_suffix;

   procedure R_I_verb_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_2 : Integer;
      v_3 : Char_Index;
   begin
      if Z.C < Z.I_PV then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_PV;
      --  (, line 170
      Z.Ket := Z.C;      --  [, line 171

      --  substring, line 171
      if Z.C <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#41c0222#) then
         Z.Lb := v_2;
         Result := False;
         return;
         --  substring, line 171
      end if;
      Find_Among_Backward (Z, A_5, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 171

      --  (, line 177
      --  not, line 177
      v_3 := Z.L - Z.C;
      --  literal, line 177
      C := Eq_S_Backward (Z, "H");
      if C = 0 then
         goto lab0;
      end if;
      Z.C := Z.C - C;
      Z.Lb := v_2;
      Result := False;
      return;

      <<lab0>>
      Z.C := Z.L - v_3;
      Out_Grouping_Backward (Z, G_V, 97, 251, False, C);
      if C /= 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      --  delete, line 177
      Slice_Del (Z);
      Z.Lb := v_2;

      Result := True;
   end R_I_verb_suffix;

   procedure R_Verb_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_2 : Integer;
      v_3 : Char_Index;
   begin
      if Z.C < Z.I_PV then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_PV;
      --  (, line 181
      Z.Ket := Z.C;      --  [, line 182

      --  substring, line 182
      Find_Among_Backward (Z, A_6, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 182

      --  among, line 182
      case A is
         when 1 =>
            --  (, line 184
            --  call R2, line 184
            R_R2 (Z, Result);
            if not Result then
               Z.Lb := v_2;
               Result := False;
               return;
            end if;
            --  delete, line 184
            Slice_Del (Z);
         when 2 =>
            --  (, line 192
            --  delete, line 192
            Slice_Del (Z);
         when 3 =>
            --  (, line 197
            --  delete, line 197
            Slice_Del (Z);
            --  try, line 198
            v_3 := Z.L - Z.C;
            --  (, line 198
            Z.Ket := Z.C;            --  [, line 198

            --  literal, line 198
            C := Eq_S_Backward (Z, "e");
            if C = 0 then
               Z.C := Z.L - v_3;
               goto lab0;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 198

            --  delete, line 198
            Slice_Del (Z);

            <<lab0>>
         when others =>
            null;
      end case;
      Z.Lb := v_2;

      Result := True;
   end R_Verb_suffix;

   procedure R_Residual_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
      v_5 : Integer;
      v_6 : Char_Index;
   begin
      --  (, line 205
      --  try, line 206
      v_1 := Z.L - Z.C;
      --  (, line 206
      Z.Ket := Z.C;      --  [, line 206

      --  literal, line 206
      C := Eq_S_Backward (Z, "s");
      if C = 0 then
         Z.C := Z.L - v_1;
         goto lab0;
      end if;
      Z.C := Z.C - C;
      Z.Bra := Z.C;      --  ], line 206

      --  test, line 206
      v_2 := Z.L - Z.C;
      --  (, line 206
      --  or, line 206
      v_3 := Z.L - Z.C;
      --  literal, line 206
      C := Eq_S_Backward (Z, "Hi");
      if C = 0 then
         goto lab2;
      end if;
      Z.C := Z.C - C;
      goto lab1;

      <<lab2>>
      Z.C := Z.L - v_3;
      Out_Grouping_Backward (Z, G_Keep_with_s, 97, 232, False, C);
      if C /= 0 then
         Z.C := Z.L - v_1;
         goto lab0;
      end if;

      <<lab1>>
      Z.C := Z.L - v_2;
      --  delete, line 206
      Slice_Del (Z);

      <<lab0>>
      if Z.C < Z.I_PV then
         Result := False;
         return;
      end if;
      v_5 := Z.Lb; Z.Lb := Z.I_PV;
      --  (, line 207
      Z.Ket := Z.C;      --  [, line 208

      --  substring, line 208
      if Z.C <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#44020#) then
         Z.Lb := v_5;
         Result := False;
         return;
         --  substring, line 208
      end if;
      Find_Among_Backward (Z, A_7, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_5;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 208

      --  among, line 208
      case A is
         when 1 =>
            --  (, line 209
            --  call R2, line 209
            R_R2 (Z, Result);
            if not Result then
               Z.Lb := v_5;
               Result := False;
               return;
            end if;
            --  or, line 209
            v_6 := Z.L - Z.C;
            --  literal, line 209
            C := Eq_S_Backward (Z, "s");
            if C = 0 then
               goto lab4;
            end if;
            Z.C := Z.C - C;
            goto lab3;

            <<lab4>>
            Z.C := Z.L - v_6;
            --  literal, line 209
            C := Eq_S_Backward (Z, "t");
            if C = 0 then
               Z.Lb := v_5;
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;

            <<lab3>>
            --  delete, line 209
            Slice_Del (Z);
         when 2 =>
            --  (, line 211
            --  <-, line 211
            Slice_From (Z, "i");
         when 3 =>
            --  (, line 212
            --  delete, line 212
            Slice_Del (Z);
         when others =>
            null;
      end case;
      Z.Lb := v_5;

      Result := True;
   end R_Residual_suffix;

   procedure R_Un_double (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
   begin
      --  (, line 217
      --  test, line 218
      v_1 := Z.L - Z.C;
      --  among, line 218
      if Z.C - 2 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#105000#) then
         Result := False;
         return;
         --  among, line 218
      end if;
      Find_Among_Backward (Z, A_8, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.L - v_1;
      Z.Ket := Z.C;      --  [, line 218

      --  next, line 218
      C := Skip_Utf8_Backward (Z);
      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      Z.Bra := Z.C;      --  ], line 218

      --  delete, line 218
      Slice_Del (Z);

      Result := True;
   end R_Un_double;

   procedure R_Un_accent (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Integer;
      v_3 : Char_Index;
   begin
      --  (, line 221
      --  atleast, line 222
      begin
         v_1 := 1;

         <<lab0>>

         loop
            Out_Grouping_Backward (Z, G_V, 97, 251, False, C);
            if C /= 0 then
               goto lab1;
            end if;
            v_1 := v_1 - 1;
            goto lab0;

            <<lab1>>

            exit;
         end loop;
         if v_1 > 0 then
            Result := False;
            return;
         end if;
      end;
      Z.Ket := Z.C;      --  [, line 223

      --  or, line 223
      v_3 := Z.L - Z.C;
      --  literal, line 223
      C := Eq_S_Backward (Z, "é");
      if C = 0 then
         goto lab3;
      end if;
      Z.C := Z.C - C;
      goto lab2;

      <<lab3>>
      Z.C := Z.L - v_3;
      --  literal, line 223
      C := Eq_S_Backward (Z, "è");
      if C = 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C - C;

      <<lab2>>
      Z.Bra := Z.C;      --  ], line 223

      --  <-, line 223
      Slice_From (Z, "e");

      Result := True;
   end R_Un_accent;

   procedure Stem (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
      v_6 : Char_Index;
      v_7 : Char_Index;
      v_8 : Char_Index;
      v_9 : Char_Index;
      v_10 : Char_Index;
      v_11 : Char_Index;
   begin
      --  (, line 227
      --  do, line 229
      v_1 := Z.C;
      --  call prelude, line 229
      R_Prelude (Z, Result);
      Z.C := v_1;
      --  do, line 230
      --  call mark_regions, line 230
      R_Mark_regions (Z, Result);
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 231

      --  (, line 231
      --  do, line 233
      v_3 := Z.L - Z.C;
      --  (, line 233
      --  or, line 243
      v_4 := Z.L - Z.C;
      --  (, line 234
      --  and, line 239
      v_5 := Z.L - Z.C;
      --  (, line 235
      --  or, line 235
      v_6 := Z.L - Z.C;
      --  call standard_suffix, line 235
      R_Standard_suffix (Z, Result);
      if not Result then
         goto lab4;
      end if;
      goto lab3;

      <<lab4>>
      Z.C := Z.L - v_6;
      --  call i_verb_suffix, line 236
      R_I_verb_suffix (Z, Result);
      if not Result then
         goto lab5;
      end if;
      goto lab3;

      <<lab5>>
      Z.C := Z.L - v_6;
      --  call verb_suffix, line 237
      R_Verb_suffix (Z, Result);
      if not Result then
         goto lab2;
      end if;

      <<lab3>>
      Z.C := Z.L - v_5;
      --  try, line 240
      v_7 := Z.L - Z.C;
      --  (, line 240
      Z.Ket := Z.C;      --  [, line 240

      --  or, line 240
      v_8 := Z.L - Z.C;
      --  (, line 240
      --  literal, line 240
      C := Eq_S_Backward (Z, "Y");
      if C = 0 then
         goto lab8;
      end if;
      Z.C := Z.C - C;
      Z.Bra := Z.C;      --  ], line 240

      --  <-, line 240
      Slice_From (Z, "i");
      goto lab7;

      <<lab8>>
      Z.C := Z.L - v_8;
      --  (, line 241
      --  literal, line 241
      C := Eq_S_Backward (Z, "ç");
      if C = 0 then
         Z.C := Z.L - v_7;
         goto lab6;
      end if;
      Z.C := Z.C - C;
      Z.Bra := Z.C;      --  ], line 241

      --  <-, line 241
      Slice_From (Z, "c");

      <<lab7>>

      <<lab6>>
      goto lab1;

      <<lab2>>
      Z.C := Z.L - v_4;
      --  call residual_suffix, line 244
      R_Residual_suffix (Z, Result);
      if not Result then
         goto lab0;
      end if;

      <<lab1>>

      <<lab0>>
      Z.C := Z.L - v_3;
      --  do, line 249
      v_9 := Z.L - Z.C;
      --  call un_double, line 249
      R_Un_double (Z, Result);
      Z.C := Z.L - v_9;
      --  do, line 250
      v_10 := Z.L - Z.C;
      --  call un_accent, line 250
      R_Un_accent (Z, Result);
      Z.C := Z.L - v_10;
      Z.C := Z.Lb;
      --  do, line 252
      v_11 := Z.C;
      --  call postlude, line 252
      R_Postlude (Z, Result);
      Z.C := v_11;

      Result := True;
   end Stem;
end Stemmer.French;
