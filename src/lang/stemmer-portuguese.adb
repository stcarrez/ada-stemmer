--  Generated by Snowball 2.2.0 - https://snowballstem.org/

package body Stemmer.Portuguese is

   pragma Style_Checks ("-mr");
   pragma Warnings (Off, "*variable*is never read and never assigned*");
   pragma Warnings (Off, "*mode could be*instead of*");
   pragma Warnings (Off, "*formal parameter.*is not modified*");
   pragma Warnings (Off, "*this line is too long*");
   pragma Warnings (Off, "*is not referenced*");

   procedure R_Residual_form (Z : in out Context_Type; Result : out Boolean);
   procedure R_Residual_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Verb_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_Standard_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_R2 (Z : in out Context_Type; Result : out Boolean);
   procedure R_R1 (Z : in out Context_Type; Result : out Boolean);
   procedure R_RV (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean);
   procedure R_Postlude (Z : in out Context_Type; Result : out Boolean);
   procedure R_Prelude (Z : in out Context_Type; Result : out Boolean);

   G_V : constant Grouping_Array (0 .. 159) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      True, True, False, False, False, False, False, False,
      True, True, False, False, True, False, False, False,
      False, False, True, True, False, False, False, False,
      False, True, False, False, False, False, False, False
   );
   Among_String : constant String := "" & "ã" & "õ" & "" & "a~" & "o~" & "ic" & "ad" & "os" & "iv" & "ante" & "avel"
      & "ível" & "ic" & "abil" & "iv" & "ica" & "ância" & "ência" & "logia" & "ira"
      & "adora" & "osa" & "ista" & "iva" & "eza" & "idade" & "ante" & "mente"
      & "amente" & "ável" & "ível" & "ico" & "ismo" & "oso" & "amento" & "imento"
      & "ivo" & "aça~o" & "uça~o" & "ador" & "icas" & "ências" & "logias" & "iras"
      & "adoras" & "osas" & "istas" & "ivas" & "ezas" & "idades" & "adores" & "antes"
      & "aço~es" & "uço~es" & "icos" & "ismos" & "osos" & "amentos" & "imentos"
      & "ivos" & "ada" & "ida" & "ia" & "aria" & "eria" & "iria" & "ara" & "era"
      & "ira" & "ava" & "asse" & "esse" & "isse" & "aste" & "este" & "iste" & "ei"
      & "arei" & "erei" & "irei" & "am" & "iam" & "ariam" & "eriam" & "iriam" & "aram"
      & "eram" & "iram" & "avam" & "em" & "arem" & "erem" & "irem" & "assem" & "essem"
      & "issem" & "ado" & "ido" & "ando" & "endo" & "indo" & "ara~o" & "era~o"
      & "ira~o" & "ar" & "er" & "ir" & "as" & "adas" & "idas" & "ias" & "arias"
      & "erias" & "irias" & "aras" & "eras" & "iras" & "avas" & "es" & "ardes"
      & "erdes" & "irdes" & "ares" & "eres" & "ires" & "asses" & "esses" & "isses"
      & "astes" & "estes" & "istes" & "is" & "ais" & "eis" & "areis" & "ereis"
      & "ireis" & "áreis" & "éreis" & "íreis" & "ásseis" & "ésseis" & "ísseis"
      & "áveis" & "íeis" & "aríeis" & "eríeis" & "iríeis" & "ados" & "idos"
      & "amos" & "áramos" & "éramos" & "íramos" & "ávamos" & "íamos" & "aríamos"
      & "eríamos" & "iríamos" & "emos" & "aremos" & "eremos" & "iremos" & "ássemos"
      & "êssemos" & "íssemos" & "imos" & "armos" & "ermos" & "irmos" & "ámos"
      & "arás" & "erás" & "irás" & "eu" & "iu" & "ou" & "ará" & "erá" & "irá"
      & "a" & "i" & "o" & "os" & "á" & "í" & "ó" & "e" & "ç" & "é" & "ê";

   A_0 : constant Among_Array_Type (0 .. 2) := (
      (1, 0, -1, 3, 0),
      (1, 2, 0, 1, 0),
      (3, 4, 0, 2, 0));

   A_1 : constant Among_Array_Type (0 .. 2) := (
      (5, 4, -1, 3, 0),
      (5, 6, 0, 1, 0),
      (7, 8, 0, 2, 0));

   A_2 : constant Among_Array_Type (0 .. 3) := (
      (9, 10, -1, -1, 0),
      (11, 12, -1, -1, 0),
      (13, 14, -1, -1, 0),
      (15, 16, -1, 1, 0));

   A_3 : constant Among_Array_Type (0 .. 2) := (
      (17, 20, -1, 1, 0),
      (21, 24, -1, 1, 0),
      (25, 29, -1, 1, 0));

   A_4 : constant Among_Array_Type (0 .. 2) := (
      (30, 31, -1, 1, 0),
      (32, 35, -1, 1, 0),
      (36, 37, -1, 1, 0));

   A_5 : constant Among_Array_Type (0 .. 44) := (
      (38, 40, -1, 1, 0),
      (41, 46, -1, 1, 0),
      (47, 52, -1, 4, 0),
      (53, 57, -1, 2, 0),
      (58, 60, -1, 9, 0),
      (61, 65, -1, 1, 0),
      (66, 68, -1, 1, 0),
      (69, 72, -1, 1, 0),
      (73, 75, -1, 8, 0),
      (76, 78, -1, 1, 0),
      (79, 83, -1, 7, 0),
      (84, 87, -1, 1, 0),
      (88, 92, -1, 6, 0),
      (93, 98, 12, 5, 0),
      (99, 103, -1, 1, 0),
      (104, 108, -1, 1, 0),
      (109, 111, -1, 1, 0),
      (112, 115, -1, 1, 0),
      (116, 118, -1, 1, 0),
      (119, 124, -1, 1, 0),
      (125, 130, -1, 1, 0),
      (131, 133, -1, 8, 0),
      (134, 139, -1, 1, 0),
      (140, 145, -1, 3, 0),
      (146, 149, -1, 1, 0),
      (150, 153, -1, 1, 0),
      (154, 160, -1, 4, 0),
      (161, 166, -1, 2, 0),
      (167, 170, -1, 9, 0),
      (171, 176, -1, 1, 0),
      (177, 180, -1, 1, 0),
      (181, 185, -1, 1, 0),
      (186, 189, -1, 8, 0),
      (190, 193, -1, 1, 0),
      (194, 199, -1, 7, 0),
      (200, 205, -1, 1, 0),
      (206, 210, -1, 1, 0),
      (211, 217, -1, 1, 0),
      (218, 224, -1, 3, 0),
      (225, 228, -1, 1, 0),
      (229, 233, -1, 1, 0),
      (234, 237, -1, 1, 0),
      (238, 244, -1, 1, 0),
      (245, 251, -1, 1, 0),
      (252, 255, -1, 8, 0));

   A_6 : constant Among_Array_Type (0 .. 119) := (
      (256, 258, -1, 1, 0),
      (259, 261, -1, 1, 0),
      (262, 263, -1, 1, 0),
      (264, 267, 2, 1, 0),
      (268, 271, 2, 1, 0),
      (272, 275, 2, 1, 0),
      (276, 278, -1, 1, 0),
      (279, 281, -1, 1, 0),
      (282, 284, -1, 1, 0),
      (285, 287, -1, 1, 0),
      (288, 291, -1, 1, 0),
      (292, 295, -1, 1, 0),
      (296, 299, -1, 1, 0),
      (300, 303, -1, 1, 0),
      (304, 307, -1, 1, 0),
      (308, 311, -1, 1, 0),
      (312, 313, -1, 1, 0),
      (314, 317, 16, 1, 0),
      (318, 321, 16, 1, 0),
      (322, 325, 16, 1, 0),
      (326, 327, -1, 1, 0),
      (328, 330, 20, 1, 0),
      (331, 335, 21, 1, 0),
      (336, 340, 21, 1, 0),
      (341, 345, 21, 1, 0),
      (346, 349, 20, 1, 0),
      (350, 353, 20, 1, 0),
      (354, 357, 20, 1, 0),
      (358, 361, 20, 1, 0),
      (362, 363, -1, 1, 0),
      (364, 367, 29, 1, 0),
      (368, 371, 29, 1, 0),
      (372, 375, 29, 1, 0),
      (376, 380, 29, 1, 0),
      (381, 385, 29, 1, 0),
      (386, 390, 29, 1, 0),
      (391, 393, -1, 1, 0),
      (394, 396, -1, 1, 0),
      (397, 400, -1, 1, 0),
      (401, 404, -1, 1, 0),
      (405, 408, -1, 1, 0),
      (409, 413, -1, 1, 0),
      (414, 418, -1, 1, 0),
      (419, 423, -1, 1, 0),
      (424, 425, -1, 1, 0),
      (426, 427, -1, 1, 0),
      (428, 429, -1, 1, 0),
      (430, 431, -1, 1, 0),
      (432, 435, 47, 1, 0),
      (436, 439, 47, 1, 0),
      (440, 442, 47, 1, 0),
      (443, 447, 50, 1, 0),
      (448, 452, 50, 1, 0),
      (453, 457, 50, 1, 0),
      (458, 461, 47, 1, 0),
      (462, 465, 47, 1, 0),
      (466, 469, 47, 1, 0),
      (470, 473, 47, 1, 0),
      (474, 475, -1, 1, 0),
      (476, 480, 58, 1, 0),
      (481, 485, 58, 1, 0),
      (486, 490, 58, 1, 0),
      (491, 494, 58, 1, 0),
      (495, 498, 58, 1, 0),
      (499, 502, 58, 1, 0),
      (503, 507, 58, 1, 0),
      (508, 512, 58, 1, 0),
      (513, 517, 58, 1, 0),
      (518, 522, 58, 1, 0),
      (523, 527, 58, 1, 0),
      (528, 532, 58, 1, 0),
      (533, 534, -1, 1, 0),
      (535, 537, 71, 1, 0),
      (538, 540, 71, 1, 0),
      (541, 545, 73, 1, 0),
      (546, 550, 73, 1, 0),
      (551, 555, 73, 1, 0),
      (556, 561, 73, 1, 0),
      (562, 567, 73, 1, 0),
      (568, 573, 73, 1, 0),
      (574, 580, 73, 1, 0),
      (581, 587, 73, 1, 0),
      (588, 594, 73, 1, 0),
      (595, 600, 73, 1, 0),
      (601, 605, 73, 1, 0),
      (606, 612, 84, 1, 0),
      (613, 619, 84, 1, 0),
      (620, 626, 84, 1, 0),
      (627, 630, -1, 1, 0),
      (631, 634, -1, 1, 0),
      (635, 638, -1, 1, 0),
      (639, 645, 90, 1, 0),
      (646, 652, 90, 1, 0),
      (653, 659, 90, 1, 0),
      (660, 666, 90, 1, 0),
      (667, 672, 90, 1, 0),
      (673, 680, 95, 1, 0),
      (681, 688, 95, 1, 0),
      (689, 696, 95, 1, 0),
      (697, 700, -1, 1, 0),
      (701, 706, 99, 1, 0),
      (707, 712, 99, 1, 0),
      (713, 718, 99, 1, 0),
      (719, 726, 99, 1, 0),
      (727, 734, 99, 1, 0),
      (735, 742, 99, 1, 0),
      (743, 746, -1, 1, 0),
      (747, 751, -1, 1, 0),
      (752, 756, -1, 1, 0),
      (757, 761, -1, 1, 0),
      (762, 766, -1, 1, 0),
      (767, 771, -1, 1, 0),
      (772, 776, -1, 1, 0),
      (777, 781, -1, 1, 0),
      (782, 783, -1, 1, 0),
      (784, 785, -1, 1, 0),
      (786, 787, -1, 1, 0),
      (788, 791, -1, 1, 0),
      (792, 795, -1, 1, 0),
      (796, 799, -1, 1, 0));

   A_7 : constant Among_Array_Type (0 .. 6) := (
      (800, 800, -1, 1, 0),
      (801, 801, -1, 1, 0),
      (802, 802, -1, 1, 0),
      (803, 804, -1, 1, 0),
      (805, 806, -1, 1, 0),
      (807, 808, -1, 1, 0),
      (809, 810, -1, 1, 0));

   A_8 : constant Among_Array_Type (0 .. 3) := (
      (811, 811, -1, 1, 0),
      (812, 813, -1, 2, 0),
      (814, 815, -1, 1, 0),
      (816, 817, -1, 1, 0));


   procedure R_Prelude (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
   begin
      --  repeat, line 36

      <<lab0>>

      loop
         v_1 := Z.C;
         --  (, line 36
         Z.Bra := Z.C;         --  [, line 37

         --  substring, line 37
         if Z.C + 1 >= Z.L or else (Character'Pos (Z.P (Z.C + 1 + 1)) /= 163 and then Character'Pos (Z.P (Z.C + 1 + 1)) /= 181) then
            A := 3;
         else            --  substring, line 37
            Find_Among (Z, A_0, Among_String, null, A);
            if A = 0 then
               goto lab1;
            end if;
         end if;
         Z.Ket := Z.C;         --  ], line 37

         --  among, line 37
         case A is
            when 1 =>
               --  (, line 38
               --  <-, line 38
               Slice_From (Z, "a~");
            when 2 =>
               --  (, line 39
               --  <-, line 39
               Slice_From (Z, "o~");
            when 3 =>
               --  (, line 40
               --  next, line 40
               C := Skip_Utf8 (Z);
               if C < 0 then
                  goto lab1;
               end if;
               Z.C := C;
            when others =>
               null;
         end case;
         goto lab0;

         <<lab1>>
         Z.C := v_1;

         exit;
      end loop;

      Result := True;
   end R_Prelude;

   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
   begin
      --  (, line 44
      Z.I_PV := Z.L;
      Z.I_P1 := Z.L;
      Z.I_P2 := Z.L;
      --  do, line 50
      v_1 := Z.C;
      --  (, line 50
      --  or, line 52
      v_2 := Z.C;
      --  (, line 51
      In_Grouping (Z, G_V, 97, 250, False, C);
      if C /= 0 then
         goto lab2;
      end if;
      --  or, line 51
      v_3 := Z.C;
      --  (, line 51
      Out_Grouping (Z, G_V, 97, 250, False, C);
      if C /= 0 then
         goto lab4;
      end if;
            --  gopast, line 51
      --  grouping v, line 51
      Out_Grouping (Z, G_V, 97, 250, True, C);
      if C < 0 then
         goto lab4;
      end if;
      Z.C := Z.C + C;
      goto lab3;

      <<lab4>>
      Z.C := v_3;
      --  (, line 51
      In_Grouping (Z, G_V, 97, 250, False, C);
      if C /= 0 then
         goto lab2;
      end if;
            --  gopast, line 51
      --  non v, line 51
      In_Grouping (Z, G_V, 97, 250, True, C);
      if C < 0 then
         goto lab2;
      end if;
      Z.C := Z.C + C;

      <<lab3>>
      goto lab1;

      <<lab2>>
      Z.C := v_2;
      --  (, line 53
      Out_Grouping (Z, G_V, 97, 250, False, C);
      if C /= 0 then
         goto lab0;
      end if;
      --  or, line 53
      v_4 := Z.C;
      --  (, line 53
      Out_Grouping (Z, G_V, 97, 250, False, C);
      if C /= 0 then
         goto lab8;
      end if;
            --  gopast, line 53
      --  grouping v, line 53
      Out_Grouping (Z, G_V, 97, 250, True, C);
      if C < 0 then
         goto lab8;
      end if;
      Z.C := Z.C + C;
      goto lab7;

      <<lab8>>
      Z.C := v_4;
      --  (, line 53
      In_Grouping (Z, G_V, 97, 250, False, C);
      if C /= 0 then
         goto lab0;
      end if;
      --  next, line 53
      C := Skip_Utf8 (Z);
      if C < 0 then
         goto lab0;
      end if;
      Z.C := C;

      <<lab7>>

      <<lab1>>
      --  setmark pV, line 54
      Z.I_PV := Z.C;

      <<lab0>>
      Z.C := v_1;
      --  do, line 56
      v_5 := Z.C;
      --  (, line 56
            --  gopast, line 57
      --  grouping v, line 57
      Out_Grouping (Z, G_V, 97, 250, True, C);
      if C < 0 then
         goto lab10;
      end if;
      Z.C := Z.C + C;
            --  gopast, line 57
      --  non v, line 57
      In_Grouping (Z, G_V, 97, 250, True, C);
      if C < 0 then
         goto lab10;
      end if;
      Z.C := Z.C + C;
      --  setmark p1, line 57
      Z.I_P1 := Z.C;
            --  gopast, line 58
      --  grouping v, line 58
      Out_Grouping (Z, G_V, 97, 250, True, C);
      if C < 0 then
         goto lab10;
      end if;
      Z.C := Z.C + C;
            --  gopast, line 58
      --  non v, line 58
      In_Grouping (Z, G_V, 97, 250, True, C);
      if C < 0 then
         goto lab10;
      end if;
      Z.C := Z.C + C;
      --  setmark p2, line 58
      Z.I_P2 := Z.C;

      <<lab10>>
      Z.C := v_5;

      Result := True;
   end R_Mark_regions;

   procedure R_Postlude (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
   begin
      --  repeat, line 62

      <<lab0>>

      loop
         v_1 := Z.C;
         --  (, line 62
         Z.Bra := Z.C;         --  [, line 63

         --  substring, line 63
         if Z.C + 1 >= Z.L or else Character'Pos (Z.P (Z.C + 1 + 1)) /= 126 then
            A := 3;
         else            --  substring, line 63
            Find_Among (Z, A_1, Among_String, null, A);
            if A = 0 then
               goto lab1;
            end if;
         end if;
         Z.Ket := Z.C;         --  ], line 63

         --  among, line 63
         case A is
            when 1 =>
               --  (, line 64
               --  <-, line 64
               Slice_From (Z, "ã");
            when 2 =>
               --  (, line 65
               --  <-, line 65
               Slice_From (Z, "õ");
            when 3 =>
               --  (, line 66
               --  next, line 66
               C := Skip_Utf8 (Z);
               if C < 0 then
                  goto lab1;
               end if;
               Z.C := C;
            when others =>
               null;
         end case;
         goto lab0;

         <<lab1>>
         Z.C := v_1;

         exit;
      end loop;

      Result := True;
   end R_Postlude;

   procedure R_RV (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_PV <= Z.C);
   end R_RV;

   procedure R_R1 (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_P1 <= Z.C);
   end R_R1;

   procedure R_R2 (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_P2 <= Z.C);
   end R_R2;

   procedure R_Standard_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
   begin
      --  (, line 76
      Z.Ket := Z.C;      --  [, line 77

      --  substring, line 77
      if Z.C - 2 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#c9022#) then
         Result := False;
         return;
         --  substring, line 77
      end if;
      Find_Among_Backward (Z, A_5, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 77

      --  among, line 77
      case A is
         when 1 =>
            --  (, line 92
            --  call R2, line 93
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 93
            Slice_Del (Z);
         when 2 =>
            --  (, line 97
            --  call R2, line 98
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  <-, line 98
            Slice_From (Z, "log");
         when 3 =>
            --  (, line 101
            --  call R2, line 102
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  <-, line 102
            Slice_From (Z, "u");
         when 4 =>
            --  (, line 105
            --  call R2, line 106
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  <-, line 106
            Slice_From (Z, "ente");
         when 5 =>
            --  (, line 109
            --  call R1, line 110
            R_R1 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 110
            Slice_Del (Z);
            --  try, line 111
            v_1 := Z.L - Z.C;
            --  (, line 111
            Z.Ket := Z.C;            --  [, line 112

            --  substring, line 112
            if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#480018#) then
               Z.C := Z.L - v_1;
               goto lab0;
               --  substring, line 112
            end if;
            Find_Among_Backward (Z, A_2, Among_String, null, A);
            if A = 0 then
               Z.C := Z.L - v_1;
               goto lab0;
            end if;
            Z.Bra := Z.C;            --  ], line 112

            --  call R2, line 112
            R_R2 (Z, Result);
            if not Result then
               Z.C := Z.L - v_1;
               goto lab0;
            end if;
            --  delete, line 112
            Slice_Del (Z);
            --  among, line 112
            case A is
               when 1 =>
                  --  (, line 113
                  Z.Ket := Z.C;                  --  [, line 113

                  --  literal, line 113
                  C := Eq_S_Backward (Z, "at");
                  if C = 0 then
                     Z.C := Z.L - v_1;
                     goto lab0;
                  end if;
                  Z.C := Z.C - C;
                  Z.Bra := Z.C;                  --  ], line 113

                  --  call R2, line 113
                  R_R2 (Z, Result);
                  if not Result then
                     Z.C := Z.L - v_1;
                     goto lab0;
                  end if;
                  --  delete, line 113
                  Slice_Del (Z);
               when others =>
                  null;
            end case;

            <<lab0>>
         when 6 =>
            --  (, line 121
            --  call R2, line 122
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 122
            Slice_Del (Z);
            --  try, line 123
            v_2 := Z.L - Z.C;
            --  (, line 123
            Z.Ket := Z.C;            --  [, line 124

            --  substring, line 124
            if Z.C - 3 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 101 and then Character'Pos (Z.P (Z.C)) /= 108) then
               Z.C := Z.L - v_2;
               goto lab1;
               --  substring, line 124
            end if;
            Find_Among_Backward (Z, A_3, Among_String, null, A);
            if A = 0 then
               Z.C := Z.L - v_2;
               goto lab1;
            end if;
            Z.Bra := Z.C;            --  ], line 124

            --  (, line 127
            --  call R2, line 127
            R_R2 (Z, Result);
            if not Result then
               Z.C := Z.L - v_2;
               goto lab1;
            end if;
            --  delete, line 127
            Slice_Del (Z);

            <<lab1>>
         when 7 =>
            --  (, line 133
            --  call R2, line 134
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 134
            Slice_Del (Z);
            --  try, line 135
            v_3 := Z.L - Z.C;
            --  (, line 135
            Z.Ket := Z.C;            --  [, line 136

            --  substring, line 136
            if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#401008#) then
               Z.C := Z.L - v_3;
               goto lab2;
               --  substring, line 136
            end if;
            Find_Among_Backward (Z, A_4, Among_String, null, A);
            if A = 0 then
               Z.C := Z.L - v_3;
               goto lab2;
            end if;
            Z.Bra := Z.C;            --  ], line 136

            --  (, line 139
            --  call R2, line 139
            R_R2 (Z, Result);
            if not Result then
               Z.C := Z.L - v_3;
               goto lab2;
            end if;
            --  delete, line 139
            Slice_Del (Z);

            <<lab2>>
         when 8 =>
            --  (, line 145
            --  call R2, line 146
            R_R2 (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 146
            Slice_Del (Z);
            --  try, line 147
            v_4 := Z.L - Z.C;
            --  (, line 147
            Z.Ket := Z.C;            --  [, line 148

            --  literal, line 148
            C := Eq_S_Backward (Z, "at");
            if C = 0 then
               Z.C := Z.L - v_4;
               goto lab3;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 148

            --  call R2, line 148
            R_R2 (Z, Result);
            if not Result then
               Z.C := Z.L - v_4;
               goto lab3;
            end if;
            --  delete, line 148
            Slice_Del (Z);

            <<lab3>>
         when 9 =>
            --  (, line 152
            --  call RV, line 153
            R_RV (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  literal, line 153
            C := Eq_S_Backward (Z, "e");
            if C = 0 then
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;
            --  <-, line 154
            Slice_From (Z, "ir");
         when others =>
            null;
      end case;

      Result := True;
   end R_Standard_suffix;

   procedure R_Verb_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_2 : Integer;
   begin
      if Z.C < Z.I_PV then
         Result := False;
         return;
      end if;
      v_2 := Z.Lb; Z.Lb := Z.I_PV;
      --  (, line 159
      Z.Ket := Z.C;      --  [, line 160

      --  substring, line 160
      Find_Among_Backward (Z, A_6, Among_String, null, A);
      if A = 0 then
         Z.Lb := v_2;
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 160

      --  (, line 179
      --  delete, line 179
      Slice_Del (Z);
      Z.Lb := v_2;

      Result := True;
   end R_Verb_suffix;

   procedure R_Residual_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 183
      Z.Ket := Z.C;      --  [, line 184

      --  substring, line 184
      Find_Among_Backward (Z, A_7, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 184

      --  (, line 187
      --  call RV, line 187
      R_RV (Z, Result);
      if not Result then
         Result := False;
         return;
      end if;
      --  delete, line 187
      Slice_Del (Z);

      Result := True;
   end R_Residual_suffix;

   procedure R_Residual_form (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
   begin
      --  (, line 191
      Z.Ket := Z.C;      --  [, line 192

      --  substring, line 192
      Find_Among_Backward (Z, A_8, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 192

      --  among, line 192
      case A is
         when 1 =>
            --  (, line 194
            --  call RV, line 194
            R_RV (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 194
            Slice_Del (Z);
            Z.Ket := Z.C;            --  [, line 194

            --  or, line 194
            v_1 := Z.L - Z.C;
            --  (, line 194
            --  literal, line 194
            C := Eq_S_Backward (Z, "u");
            if C = 0 then
               goto lab1;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 194

            --  test, line 194
            v_2 := Z.L - Z.C;
            --  literal, line 194
            C := Eq_S_Backward (Z, "g");
            if C = 0 then
               goto lab1;
            end if;
            Z.C := Z.C - C;
            Z.C := Z.L - v_2;
            goto lab0;

            <<lab1>>
            Z.C := Z.L - v_1;
            --  (, line 195
            --  literal, line 195
            C := Eq_S_Backward (Z, "i");
            if C = 0 then
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 195

            --  test, line 195
            v_3 := Z.L - Z.C;
            --  literal, line 195
            C := Eq_S_Backward (Z, "c");
            if C = 0 then
               Result := False;
               return;
            end if;
            Z.C := Z.C - C;
            Z.C := Z.L - v_3;

            <<lab0>>
            --  call RV, line 195
            R_RV (Z, Result);
            if not Result then
               Result := False;
               return;
            end if;
            --  delete, line 195
            Slice_Del (Z);
         when 2 =>
            --  (, line 196
            --  <-, line 196
            Slice_From (Z, "c");
         when others =>
            null;
      end case;

      Result := True;
   end R_Residual_form;

   procedure Stem (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
      v_6 : Char_Index;
      v_7 : Char_Index;
      v_8 : Char_Index;
      v_9 : Char_Index;
      v_10 : Char_Index;
   begin
      --  (, line 201
      --  do, line 202
      v_1 := Z.C;
      --  call prelude, line 202
      R_Prelude (Z, Result);
      Z.C := v_1;
      --  do, line 203
      --  call mark_regions, line 203
      R_Mark_regions (Z, Result);
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 204

      --  (, line 204
      --  do, line 205
      v_3 := Z.L - Z.C;
      --  or, line 209
      v_4 := Z.L - Z.C;
      --  and, line 207
      v_5 := Z.L - Z.C;
      --  or, line 206
      v_6 := Z.L - Z.C;
      --  call standard_suffix, line 206
      R_Standard_suffix (Z, Result);
      if not Result then
         goto lab4;
      end if;
      goto lab3;

      <<lab4>>
      Z.C := Z.L - v_6;
      --  call verb_suffix, line 206
      R_Verb_suffix (Z, Result);
      if not Result then
         goto lab2;
      end if;

      <<lab3>>
      Z.C := Z.L - v_5;
      --  do, line 207
      v_7 := Z.L - Z.C;
      --  (, line 207
      Z.Ket := Z.C;      --  [, line 207

      --  literal, line 207
      C := Eq_S_Backward (Z, "i");
      if C = 0 then
         goto lab5;
      end if;
      Z.C := Z.C - C;
      Z.Bra := Z.C;      --  ], line 207

      --  test, line 207
      v_8 := Z.L - Z.C;
      --  literal, line 207
      C := Eq_S_Backward (Z, "c");
      if C = 0 then
         goto lab5;
      end if;
      Z.C := Z.C - C;
      Z.C := Z.L - v_8;
      --  call RV, line 207
      R_RV (Z, Result);
      if not Result then
         goto lab5;
      end if;
      --  delete, line 207
      Slice_Del (Z);

      <<lab5>>
      Z.C := Z.L - v_7;
      goto lab1;

      <<lab2>>
      Z.C := Z.L - v_4;
      --  call residual_suffix, line 209
      R_Residual_suffix (Z, Result);
      if not Result then
         goto lab0;
      end if;

      <<lab1>>

      <<lab0>>
      Z.C := Z.L - v_3;
      --  do, line 211
      v_9 := Z.L - Z.C;
      --  call residual_form, line 211
      R_Residual_form (Z, Result);
      Z.C := Z.L - v_9;
      Z.C := Z.Lb;
      --  do, line 213
      v_10 := Z.C;
      --  call postlude, line 213
      R_Postlude (Z, Result);
      Z.C := v_10;

      Result := True;
   end Stem;
end Stemmer.Portuguese;
