--  Generated by Snowball 2.2.0 - https://snowballstem.org/

package body Stemmer.Arabic is

   pragma Style_Checks ("-mr");
   pragma Warnings (Off, "*variable*is never read and never assigned*");
   pragma Warnings (Off, "*mode could be*instead of*");
   pragma Warnings (Off, "*formal parameter.*is not modified*");
   pragma Warnings (Off, "*this line is too long*");
   pragma Warnings (Off, "*is not referenced*");

   procedure R_Checks1 (Z : in out Context_Type; Result : out Boolean);
   procedure R_Normalize_pre (Z : in out Context_Type; Result : out Boolean);
   procedure R_Normalize_post (Z : in out Context_Type; Result : out Boolean);
   procedure R_Suffix_Verb_Step2c (Z : in out Context_Type; Result : out Boolean);
   procedure R_Suffix_Verb_Step2b (Z : in out Context_Type; Result : out Boolean);
   procedure R_Suffix_Verb_Step2a (Z : in out Context_Type; Result : out Boolean);
   procedure R_Suffix_Verb_Step1 (Z : in out Context_Type; Result : out Boolean);
   procedure R_Suffix_Noun_Step3 (Z : in out Context_Type; Result : out Boolean);
   procedure R_Suffix_Noun_Step2c2 (Z : in out Context_Type; Result : out Boolean);
   procedure R_Suffix_Noun_Step2c1 (Z : in out Context_Type; Result : out Boolean);
   procedure R_Suffix_Noun_Step2b (Z : in out Context_Type; Result : out Boolean);
   procedure R_Suffix_Noun_Step2a (Z : in out Context_Type; Result : out Boolean);
   procedure R_Suffix_Noun_Step1b (Z : in out Context_Type; Result : out Boolean);
   procedure R_Suffix_Noun_Step1a (Z : in out Context_Type; Result : out Boolean);
   procedure R_Suffix_All_alef_maqsura (Z : in out Context_Type; Result : out Boolean);
   procedure R_Prefix_Step4_Verb (Z : in out Context_Type; Result : out Boolean);
   procedure R_Prefix_Step3_Verb (Z : in out Context_Type; Result : out Boolean);
   procedure R_Prefix_Step3b_Noun (Z : in out Context_Type; Result : out Boolean);
   procedure R_Prefix_Step3a_Noun (Z : in out Context_Type; Result : out Boolean);
   procedure R_Prefix_Step2 (Z : in out Context_Type; Result : out Boolean);
   procedure R_Prefix_Step1 (Z : in out Context_Type; Result : out Boolean);
   Among_String : constant String := "ـ" & "ً" & "ٌ" & "ٍ" & "َ" & "ُ"
      & "ِ" & "ّ" & "ْ" & "٠" & "١" & "٢" & "٣" & "٤" & "٥" & "٦" & "٧"
      & "٨" & "٩" & "ﺀ" & "ﺁ" & "ﺂ" & "ﺃ" & "ﺄ" & "ﺅ" & "ﺆ" & "ﺇ"
      & "ﺈ" & "ﺉ" & "ﺊ" & "ﺋ" & "ﺌ" & "ﺍ" & "ﺎ" & "ﺏ" & "ﺐ" & "ﺑ"
      & "ﺒ" & "ﺓ" & "ﺔ" & "ﺕ" & "ﺖ" & "ﺗ" & "ﺘ" & "ﺙ" & "ﺚ" & "ﺛ"
      & "ﺜ" & "ﺝ" & "ﺞ" & "ﺟ" & "ﺠ" & "ﺡ" & "ﺢ" & "ﺣ" & "ﺤ" & "ﺥ"
      & "ﺦ" & "ﺧ" & "ﺨ" & "ﺩ" & "ﺪ" & "ﺫ" & "ﺬ" & "ﺭ" & "ﺮ" & "ﺯ"
      & "ﺰ" & "ﺱ" & "ﺲ" & "ﺳ" & "ﺴ" & "ﺵ" & "ﺶ" & "ﺷ" & "ﺸ" & "ﺹ"
      & "ﺺ" & "ﺻ" & "ﺼ" & "ﺽ" & "ﺾ" & "ﺿ" & "ﻀ" & "ﻁ" & "ﻂ" & "ﻃ"
      & "ﻄ" & "ﻅ" & "ﻆ" & "ﻇ" & "ﻈ" & "ﻉ" & "ﻊ" & "ﻋ" & "ﻌ" & "ﻍ"
      & "ﻎ" & "ﻏ" & "ﻐ" & "ﻑ" & "ﻒ" & "ﻓ" & "ﻔ" & "ﻕ" & "ﻖ" & "ﻗ"
      & "ﻘ" & "ﻙ" & "ﻚ" & "ﻛ" & "ﻜ" & "ﻝ" & "ﻞ" & "ﻟ" & "ﻠ" & "ﻡ"
      & "ﻢ" & "ﻣ" & "ﻤ" & "ﻥ" & "ﻦ" & "ﻧ" & "ﻨ" & "ﻩ" & "ﻪ" & "ﻫ"
      & "ﻬ" & "ﻭ" & "ﻮ" & "ﻯ" & "ﻰ" & "ﻱ" & "ﻲ" & "ﻳ" & "ﻴ" & "ﻵ"
      & "ﻶ" & "ﻷ" & "ﻸ" & "ﻹ" & "ﻺ" & "ﻻ" & "ﻼ" & "آ" & "أ" & "ؤ"
      & "إ" & "ئ" & "آ" & "أ" & "ؤ" & "إ" & "ئ" & "ال" & "بال" & "كال"
      & "لل" & "أآ" & "أأ" & "أؤ" & "أإ" & "أا" & "ف" & "و" & "ال"
      & "بال" & "كال" & "لل" & "ب" & "با" & "بب" & "كك" & "سأ"
      & "ست" & "سن" & "سي" & "تست" & "نست" & "يست" & "ك" & "كم"
      & "هم" & "هن" & "ه" & "ي" & "كما" & "هما" & "نا" & "ها" & "ن"
      & "و" & "ي" & "ا" & "ات" & "ت" & "ة" & "ي" & "ك" & "كم" & "هم"
      & "كن" & "هن" & "ه" & "كمو" & "ني" & "كما" & "هما" & "نا"
      & "ها" & "ن" & "ون" & "ين" & "ان" & "تن" & "ي" & "ا" & "تما"
      & "نا" & "تا" & "ت" & "تم" & "وا" & "و" & "تمو" & "ى";

   A_0 : constant Among_Array_Type (0 .. 143) := (
      (1, 2, -1, 1, 0),
      (3, 4, -1, 1, 0),
      (5, 6, -1, 1, 0),
      (7, 8, -1, 1, 0),
      (9, 10, -1, 1, 0),
      (11, 12, -1, 1, 0),
      (13, 14, -1, 1, 0),
      (15, 16, -1, 1, 0),
      (17, 18, -1, 1, 0),
      (19, 20, -1, 2, 0),
      (21, 22, -1, 3, 0),
      (23, 24, -1, 4, 0),
      (25, 26, -1, 5, 0),
      (27, 28, -1, 6, 0),
      (29, 30, -1, 7, 0),
      (31, 32, -1, 8, 0),
      (33, 34, -1, 9, 0),
      (35, 36, -1, 10, 0),
      (37, 38, -1, 11, 0),
      (39, 41, -1, 12, 0),
      (42, 44, -1, 16, 0),
      (45, 47, -1, 16, 0),
      (48, 50, -1, 13, 0),
      (51, 53, -1, 13, 0),
      (54, 56, -1, 17, 0),
      (57, 59, -1, 17, 0),
      (60, 62, -1, 14, 0),
      (63, 65, -1, 14, 0),
      (66, 68, -1, 15, 0),
      (69, 71, -1, 15, 0),
      (72, 74, -1, 15, 0),
      (75, 77, -1, 15, 0),
      (78, 80, -1, 18, 0),
      (81, 83, -1, 18, 0),
      (84, 86, -1, 19, 0),
      (87, 89, -1, 19, 0),
      (90, 92, -1, 19, 0),
      (93, 95, -1, 19, 0),
      (96, 98, -1, 20, 0),
      (99, 101, -1, 20, 0),
      (102, 104, -1, 21, 0),
      (105, 107, -1, 21, 0),
      (108, 110, -1, 21, 0),
      (111, 113, -1, 21, 0),
      (114, 116, -1, 22, 0),
      (117, 119, -1, 22, 0),
      (120, 122, -1, 22, 0),
      (123, 125, -1, 22, 0),
      (126, 128, -1, 23, 0),
      (129, 131, -1, 23, 0),
      (132, 134, -1, 23, 0),
      (135, 137, -1, 23, 0),
      (138, 140, -1, 24, 0),
      (141, 143, -1, 24, 0),
      (144, 146, -1, 24, 0),
      (147, 149, -1, 24, 0),
      (150, 152, -1, 25, 0),
      (153, 155, -1, 25, 0),
      (156, 158, -1, 25, 0),
      (159, 161, -1, 25, 0),
      (162, 164, -1, 26, 0),
      (165, 167, -1, 26, 0),
      (168, 170, -1, 27, 0),
      (171, 173, -1, 27, 0),
      (174, 176, -1, 28, 0),
      (177, 179, -1, 28, 0),
      (180, 182, -1, 29, 0),
      (183, 185, -1, 29, 0),
      (186, 188, -1, 30, 0),
      (189, 191, -1, 30, 0),
      (192, 194, -1, 30, 0),
      (195, 197, -1, 30, 0),
      (198, 200, -1, 31, 0),
      (201, 203, -1, 31, 0),
      (204, 206, -1, 31, 0),
      (207, 209, -1, 31, 0),
      (210, 212, -1, 32, 0),
      (213, 215, -1, 32, 0),
      (216, 218, -1, 32, 0),
      (219, 221, -1, 32, 0),
      (222, 224, -1, 33, 0),
      (225, 227, -1, 33, 0),
      (228, 230, -1, 33, 0),
      (231, 233, -1, 33, 0),
      (234, 236, -1, 34, 0),
      (237, 239, -1, 34, 0),
      (240, 242, -1, 34, 0),
      (243, 245, -1, 34, 0),
      (246, 248, -1, 35, 0),
      (249, 251, -1, 35, 0),
      (252, 254, -1, 35, 0),
      (255, 257, -1, 35, 0),
      (258, 260, -1, 36, 0),
      (261, 263, -1, 36, 0),
      (264, 266, -1, 36, 0),
      (267, 269, -1, 36, 0),
      (270, 272, -1, 37, 0),
      (273, 275, -1, 37, 0),
      (276, 278, -1, 37, 0),
      (279, 281, -1, 37, 0),
      (282, 284, -1, 38, 0),
      (285, 287, -1, 38, 0),
      (288, 290, -1, 38, 0),
      (291, 293, -1, 38, 0),
      (294, 296, -1, 39, 0),
      (297, 299, -1, 39, 0),
      (300, 302, -1, 39, 0),
      (303, 305, -1, 39, 0),
      (306, 308, -1, 40, 0),
      (309, 311, -1, 40, 0),
      (312, 314, -1, 40, 0),
      (315, 317, -1, 40, 0),
      (318, 320, -1, 41, 0),
      (321, 323, -1, 41, 0),
      (324, 326, -1, 41, 0),
      (327, 329, -1, 41, 0),
      (330, 332, -1, 42, 0),
      (333, 335, -1, 42, 0),
      (336, 338, -1, 42, 0),
      (339, 341, -1, 42, 0),
      (342, 344, -1, 43, 0),
      (345, 347, -1, 43, 0),
      (348, 350, -1, 43, 0),
      (351, 353, -1, 43, 0),
      (354, 356, -1, 44, 0),
      (357, 359, -1, 44, 0),
      (360, 362, -1, 44, 0),
      (363, 365, -1, 44, 0),
      (366, 368, -1, 45, 0),
      (369, 371, -1, 45, 0),
      (372, 374, -1, 46, 0),
      (375, 377, -1, 46, 0),
      (378, 380, -1, 47, 0),
      (381, 383, -1, 47, 0),
      (384, 386, -1, 47, 0),
      (387, 389, -1, 47, 0),
      (390, 392, -1, 51, 0),
      (393, 395, -1, 51, 0),
      (396, 398, -1, 49, 0),
      (399, 401, -1, 49, 0),
      (402, 404, -1, 50, 0),
      (405, 407, -1, 50, 0),
      (408, 410, -1, 48, 0),
      (411, 413, -1, 48, 0));

   A_1 : constant Among_Array_Type (0 .. 4) := (
      (414, 415, -1, 1, 0),
      (416, 417, -1, 1, 0),
      (418, 419, -1, 1, 0),
      (420, 421, -1, 1, 0),
      (422, 423, -1, 1, 0));

   A_2 : constant Among_Array_Type (0 .. 4) := (
      (424, 425, -1, 1, 0),
      (426, 427, -1, 1, 0),
      (428, 429, -1, 2, 0),
      (430, 431, -1, 1, 0),
      (432, 433, -1, 3, 0));

   A_3 : constant Among_Array_Type (0 .. 3) := (
      (434, 437, -1, 2, 0),
      (438, 443, -1, 1, 0),
      (444, 449, -1, 1, 0),
      (450, 453, -1, 2, 0));

   A_4 : constant Among_Array_Type (0 .. 4) := (
      (454, 457, -1, 2, 0),
      (458, 461, -1, 1, 0),
      (462, 465, -1, 1, 0),
      (466, 469, -1, 4, 0),
      (470, 473, -1, 3, 0));

   A_5 : constant Among_Array_Type (0 .. 1) := (
      (474, 475, -1, 1, 0),
      (476, 477, -1, 1, 0));

   A_6 : constant Among_Array_Type (0 .. 3) := (
      (478, 481, -1, 2, 0),
      (482, 487, -1, 1, 0),
      (488, 493, -1, 1, 0),
      (494, 497, -1, 2, 0));

   A_7 : constant Among_Array_Type (0 .. 3) := (
      (498, 499, -1, 1, 0),
      (500, 503, 0, -1, 0),
      (504, 507, 0, 2, 0),
      (508, 511, -1, 3, 0));

   A_8 : constant Among_Array_Type (0 .. 3) := (
      (512, 515, -1, 4, 0),
      (516, 519, -1, 2, 0),
      (520, 523, -1, 3, 0),
      (524, 527, -1, 1, 0));

   A_9 : constant Among_Array_Type (0 .. 2) := (
      (528, 533, -1, 1, 0),
      (534, 539, -1, 1, 0),
      (540, 545, -1, 1, 0));

   A_10 : constant Among_Array_Type (0 .. 9) := (
      (546, 547, -1, 1, 0),
      (548, 551, -1, 2, 0),
      (552, 555, -1, 2, 0),
      (556, 559, -1, 2, 0),
      (560, 561, -1, 1, 0),
      (562, 563, -1, 1, 0),
      (564, 569, -1, 3, 0),
      (570, 575, -1, 3, 0),
      (576, 579, -1, 2, 0),
      (580, 583, -1, 2, 0));

   A_11 : constant Among_Array_Type (0 .. 0) := (
      others => (584, 585, -1, 1, 0));

   A_12 : constant Among_Array_Type (0 .. 2) := (
      (586, 587, -1, 1, 0),
      (588, 589, -1, 1, 0),
      (590, 591, -1, 1, 0));

   A_13 : constant Among_Array_Type (0 .. 0) := (
      others => (592, 595, -1, 1, 0));

   A_14 : constant Among_Array_Type (0 .. 0) := (
      others => (596, 597, -1, 1, 0));

   A_15 : constant Among_Array_Type (0 .. 0) := (
      others => (598, 599, -1, 1, 0));

   A_16 : constant Among_Array_Type (0 .. 0) := (
      others => (600, 601, -1, 1, 0));

   A_17 : constant Among_Array_Type (0 .. 11) := (
      (602, 603, -1, 1, 0),
      (604, 607, -1, 2, 0),
      (608, 611, -1, 2, 0),
      (612, 615, -1, 2, 0),
      (616, 619, -1, 2, 0),
      (620, 621, -1, 1, 0),
      (622, 627, -1, 3, 0),
      (628, 631, -1, 2, 0),
      (632, 637, -1, 3, 0),
      (638, 643, -1, 3, 0),
      (644, 647, -1, 2, 0),
      (648, 651, -1, 2, 0));

   A_18 : constant Among_Array_Type (0 .. 10) := (
      (652, 653, -1, 1, 0),
      (654, 657, 0, 3, 0),
      (658, 661, 0, 3, 0),
      (662, 665, 0, 3, 0),
      (666, 669, 0, 2, 0),
      (670, 671, -1, 1, 0),
      (672, 673, -1, 1, 0),
      (674, 679, 6, 4, 0),
      (680, 683, 6, 2, 0),
      (684, 687, 6, 2, 0),
      (688, 689, -1, 1, 0));

   A_19 : constant Among_Array_Type (0 .. 1) := (
      (690, 693, -1, 1, 0),
      (694, 697, -1, 1, 0));

   A_20 : constant Among_Array_Type (0 .. 1) := (
      (698, 699, -1, 1, 0),
      (700, 705, 0, 2, 0));

   A_21 : constant Among_Array_Type (0 .. 0) := (
      others => (706, 707, -1, 1, 0));


   procedure R_Normalize_pre (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
   begin
      --  do, line 247
      v_1 := Z.C;
      --  repeat, line 247

      <<lab1>>

      loop
         v_2 := Z.C;
         --  or, line 311
         v_3 := Z.C;
         --  (, line 248
         Z.Bra := Z.C;         --  [, line 249

         --  substring, line 249
         Find_Among (Z, A_0, Among_String, null, A);
         if A = 0 then
            goto lab4;
         end if;
         Z.Ket := Z.C;         --  ], line 249

         --  among, line 249
         case A is
            when 1 =>
               --  (, line 250
               --  delete, line 250
               Slice_Del (Z);
            when 2 =>
               --  (, line 254
               --  <-, line 254
               Slice_From (Z, "0");
            when 3 =>
               --  (, line 255
               --  <-, line 255
               Slice_From (Z, "1");
            when 4 =>
               --  (, line 256
               --  <-, line 256
               Slice_From (Z, "2");
            when 5 =>
               --  (, line 257
               --  <-, line 257
               Slice_From (Z, "3");
            when 6 =>
               --  (, line 258
               --  <-, line 258
               Slice_From (Z, "4");
            when 7 =>
               --  (, line 259
               --  <-, line 259
               Slice_From (Z, "5");
            when 8 =>
               --  (, line 260
               --  <-, line 260
               Slice_From (Z, "6");
            when 9 =>
               --  (, line 261
               --  <-, line 261
               Slice_From (Z, "7");
            when 10 =>
               --  (, line 262
               --  <-, line 262
               Slice_From (Z, "8");
            when 11 =>
               --  (, line 263
               --  <-, line 263
               Slice_From (Z, "9");
            when 12 =>
               --  (, line 266
               --  <-, line 266
               Slice_From (Z, "ء");
            when 13 =>
               --  (, line 267
               --  <-, line 267
               Slice_From (Z, "أ");
            when 14 =>
               --  (, line 268
               --  <-, line 268
               Slice_From (Z, "إ");
            when 15 =>
               --  (, line 269
               --  <-, line 269
               Slice_From (Z, "ئ");
            when 16 =>
               --  (, line 270
               --  <-, line 270
               Slice_From (Z, "آ");
            when 17 =>
               --  (, line 271
               --  <-, line 271
               Slice_From (Z, "ؤ");
            when 18 =>
               --  (, line 272
               --  <-, line 272
               Slice_From (Z, "ا");
            when 19 =>
               --  (, line 273
               --  <-, line 273
               Slice_From (Z, "ب");
            when 20 =>
               --  (, line 274
               --  <-, line 274
               Slice_From (Z, "ة");
            when 21 =>
               --  (, line 275
               --  <-, line 275
               Slice_From (Z, "ت");
            when 22 =>
               --  (, line 276
               --  <-, line 276
               Slice_From (Z, "ث");
            when 23 =>
               --  (, line 277
               --  <-, line 277
               Slice_From (Z, "ج");
            when 24 =>
               --  (, line 278
               --  <-, line 278
               Slice_From (Z, "ح");
            when 25 =>
               --  (, line 279
               --  <-, line 279
               Slice_From (Z, "خ");
            when 26 =>
               --  (, line 280
               --  <-, line 280
               Slice_From (Z, "د");
            when 27 =>
               --  (, line 281
               --  <-, line 281
               Slice_From (Z, "ذ");
            when 28 =>
               --  (, line 282
               --  <-, line 282
               Slice_From (Z, "ر");
            when 29 =>
               --  (, line 283
               --  <-, line 283
               Slice_From (Z, "ز");
            when 30 =>
               --  (, line 284
               --  <-, line 284
               Slice_From (Z, "س");
            when 31 =>
               --  (, line 285
               --  <-, line 285
               Slice_From (Z, "ش");
            when 32 =>
               --  (, line 286
               --  <-, line 286
               Slice_From (Z, "ص");
            when 33 =>
               --  (, line 287
               --  <-, line 287
               Slice_From (Z, "ض");
            when 34 =>
               --  (, line 288
               --  <-, line 288
               Slice_From (Z, "ط");
            when 35 =>
               --  (, line 289
               --  <-, line 289
               Slice_From (Z, "ظ");
            when 36 =>
               --  (, line 290
               --  <-, line 290
               Slice_From (Z, "ع");
            when 37 =>
               --  (, line 291
               --  <-, line 291
               Slice_From (Z, "غ");
            when 38 =>
               --  (, line 292
               --  <-, line 292
               Slice_From (Z, "ف");
            when 39 =>
               --  (, line 293
               --  <-, line 293
               Slice_From (Z, "ق");
            when 40 =>
               --  (, line 294
               --  <-, line 294
               Slice_From (Z, "ك");
            when 41 =>
               --  (, line 295
               --  <-, line 295
               Slice_From (Z, "ل");
            when 42 =>
               --  (, line 296
               --  <-, line 296
               Slice_From (Z, "م");
            when 43 =>
               --  (, line 297
               --  <-, line 297
               Slice_From (Z, "ن");
            when 44 =>
               --  (, line 298
               --  <-, line 298
               Slice_From (Z, "ه");
            when 45 =>
               --  (, line 299
               --  <-, line 299
               Slice_From (Z, "و");
            when 46 =>
               --  (, line 300
               --  <-, line 300
               Slice_From (Z, "ى");
            when 47 =>
               --  (, line 301
               --  <-, line 301
               Slice_From (Z, "ي");
            when 48 =>
               --  (, line 304
               --  <-, line 304
               Slice_From (Z, "لا");
            when 49 =>
               --  (, line 305
               --  <-, line 305
               Slice_From (Z, "لأ");
            when 50 =>
               --  (, line 306
               --  <-, line 306
               Slice_From (Z, "لإ");
            when 51 =>
               --  (, line 307
               --  <-, line 307
               Slice_From (Z, "لآ");
            when others =>
               null;
         end case;
         goto lab3;

         <<lab4>>
         Z.C := v_3;
         --  next, line 312
         C := Skip_Utf8 (Z);
         if C < 0 then
            goto lab2;
         end if;
         Z.C := C;

         <<lab3>>
         goto lab1;

         <<lab2>>
         Z.C := v_2;

         exit;
      end loop;

      <<lab0>>
      Z.C := v_1;

      Result := True;
   end R_Normalize_pre;

   procedure R_Normalize_post (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
   begin
      --  (, line 316
      --  do, line 318
      v_1 := Z.C;
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 320

      --  (, line 320
      Z.Ket := Z.C;      --  [, line 321

      --  substring, line 321
      if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 5, 16#7c#) then
         goto lab0;
         --  substring, line 321
      end if;
      Find_Among_Backward (Z, A_1, Among_String, null, A);
      if A = 0 then
         goto lab0;
      end if;
      Z.Bra := Z.C;      --  ], line 321

      --  (, line 322
      --  <-, line 322
      Slice_From (Z, "ء");
      Z.C := Z.Lb;

      <<lab0>>
      Z.C := v_1;
      --  do, line 329
      v_2 := Z.C;
      --  repeat, line 329

      <<lab2>>

      loop
         v_3 := Z.C;
         --  or, line 338
         v_4 := Z.C;
         --  (, line 330
         Z.Bra := Z.C;         --  [, line 332

         --  substring, line 332
         if Z.C + 1 >= Z.L or else Check_Among (Z, Z.C + 1, 5, 16#7c#) then
            goto lab5;
            --  substring, line 332
         end if;
         Find_Among (Z, A_2, Among_String, null, A);
         if A = 0 then
            goto lab5;
         end if;
         Z.Ket := Z.C;         --  ], line 332

         --  among, line 332
         case A is
            when 1 =>
               --  (, line 333
               --  <-, line 333
               Slice_From (Z, "ا");
            when 2 =>
               --  (, line 334
               --  <-, line 334
               Slice_From (Z, "و");
            when 3 =>
               --  (, line 335
               --  <-, line 335
               Slice_From (Z, "ي");
            when others =>
               null;
         end case;
         goto lab4;

         <<lab5>>
         Z.C := v_4;
         --  next, line 339
         C := Skip_Utf8 (Z);
         if C < 0 then
            goto lab3;
         end if;
         Z.C := C;

         <<lab4>>
         goto lab2;

         <<lab3>>
         Z.C := v_3;

         exit;
      end loop;

      <<lab1>>
      Z.C := v_2;

      Result := True;
   end R_Normalize_post;

   procedure R_Checks1 (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 344
      Z.Bra := Z.C;      --  [, line 345

      --  substring, line 345
      if Z.C + 3 >= Z.L or else (Character'Pos (Z.P (Z.C + 3 + 1)) /= 132 and then Character'Pos (Z.P (Z.C + 3 + 1)) /= 167) then
         Result := False;
         return;
         --  substring, line 345
      end if;
      Find_Among (Z, A_3, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Ket := Z.C;      --  ], line 345

      --  among, line 345
      case A is
         when 1 =>
            --  (, line 346
            if not (Length_Utf8 (Z) > 4) then
               Result := False;
               return;
            end if;
            --  set is_noun, line 346
            Z.B_Is_noun := True;
            --  unset is_verb, line 346
            Z.B_Is_verb := False;
            --  set is_defined, line 346
            Z.B_Is_defined := True;
         when 2 =>
            --  (, line 347
            if not (Length_Utf8 (Z) > 3) then
               Result := False;
               return;
            end if;
            --  set is_noun, line 347
            Z.B_Is_noun := True;
            --  unset is_verb, line 347
            Z.B_Is_verb := False;
            --  set is_defined, line 347
            Z.B_Is_defined := True;
         when others =>
            null;
      end case;

      Result := True;
   end R_Checks1;

   procedure R_Prefix_Step1 (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 353
      Z.Bra := Z.C;      --  [, line 354

      --  substring, line 354
      if Z.C + 3 >= Z.L or else Check_Among (Z, Z.C + 3, 5, 16#bc#) then
         Result := False;
         return;
         --  substring, line 354
      end if;
      Find_Among (Z, A_4, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Ket := Z.C;      --  ], line 354

      --  among, line 354
      case A is
         when 1 =>
            --  (, line 355
            if not (Length_Utf8 (Z) > 3) then
               Result := False;
               return;
            end if;
            --  <-, line 355
            Slice_From (Z, "أ");
         when 2 =>
            --  (, line 356
            if not (Length_Utf8 (Z) > 3) then
               Result := False;
               return;
            end if;
            --  <-, line 356
            Slice_From (Z, "آ");
         when 3 =>
            --  (, line 358
            if not (Length_Utf8 (Z) > 3) then
               Result := False;
               return;
            end if;
            --  <-, line 358
            Slice_From (Z, "ا");
         when 4 =>
            --  (, line 359
            if not (Length_Utf8 (Z) > 3) then
               Result := False;
               return;
            end if;
            --  <-, line 359
            Slice_From (Z, "إ");
         when others =>
            null;
      end case;

      Result := True;
   end R_Prefix_Step1;

   procedure R_Prefix_Step2 (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
   begin
      --  (, line 364
      Z.Bra := Z.C;      --  [, line 365

      --  substring, line 365
      if Z.C + 1 >= Z.L or else (Character'Pos (Z.P (Z.C + 1 + 1)) /= 129 and then Character'Pos (Z.P (Z.C + 1 + 1)) /= 136) then
         Result := False;
         return;
         --  substring, line 365
      end if;
      Find_Among (Z, A_5, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Ket := Z.C;      --  ], line 365

      --  (, line 366
      if not (Length_Utf8 (Z) > 3) then
         Result := False;
         return;
      end if;
      --  not, line 366
      v_1 := Z.C;
      --  literal, line 366
      C := Eq_S (Z, "ا");
      if C = 0 then
         goto lab0;
      end if;
      Z.C := Z.C + C;
      Result := False;
      return;

      <<lab0>>
      Z.C := v_1;
      --  delete, line 366
      Slice_Del (Z);

      Result := True;
   end R_Prefix_Step2;

   procedure R_Prefix_Step3a_Noun (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 370
      Z.Bra := Z.C;      --  [, line 371

      --  substring, line 371
      if Z.C + 3 >= Z.L or else (Character'Pos (Z.P (Z.C + 3 + 1)) /= 132 and then Character'Pos (Z.P (Z.C + 3 + 1)) /= 167) then
         Result := False;
         return;
         --  substring, line 371
      end if;
      Find_Among (Z, A_6, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Ket := Z.C;      --  ], line 371

      --  among, line 371
      case A is
         when 1 =>
            --  (, line 372
            if not (Length_Utf8 (Z) > 5) then
               Result := False;
               return;
            end if;
            --  delete, line 372
            Slice_Del (Z);
         when 2 =>
            --  (, line 373
            if not (Length_Utf8 (Z) > 4) then
               Result := False;
               return;
            end if;
            --  delete, line 373
            Slice_Del (Z);
         when others =>
            null;
      end case;

      Result := True;
   end R_Prefix_Step3a_Noun;

   procedure R_Prefix_Step3b_Noun (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 377
      Z.Bra := Z.C;      --  [, line 378

      --  substring, line 378
      if Z.C + 1 >= Z.L or else (Character'Pos (Z.P (Z.C + 1 + 1)) /= 168 and then Character'Pos (Z.P (Z.C + 1 + 1)) /= 131) then
         Result := False;
         return;
         --  substring, line 378
      end if;
      Find_Among (Z, A_7, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Ket := Z.C;      --  ], line 378

      --  among, line 378
      case A is
         when 1 =>
            --  (, line 380
            if not (Length_Utf8 (Z) > 3) then
               Result := False;
               return;
            end if;
            --  delete, line 380
            Slice_Del (Z);
         when 2 =>
            --  (, line 382
            if not (Length_Utf8 (Z) > 3) then
               Result := False;
               return;
            end if;
            --  <-, line 382
            Slice_From (Z, "ب");
         when 3 =>
            --  (, line 383
            if not (Length_Utf8 (Z) > 3) then
               Result := False;
               return;
            end if;
            --  <-, line 383
            Slice_From (Z, "ك");
         when others =>
            null;
      end case;

      Result := True;
   end R_Prefix_Step3b_Noun;

   procedure R_Prefix_Step3_Verb (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 388
      Z.Bra := Z.C;      --  [, line 389

      --  substring, line 389
      Find_Among (Z, A_8, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Ket := Z.C;      --  ], line 389

      --  among, line 389
      case A is
         when 1 =>
            --  (, line 391
            if not (Length_Utf8 (Z) > 4) then
               Result := False;
               return;
            end if;
            --  <-, line 391
            Slice_From (Z, "ي");
         when 2 =>
            --  (, line 392
            if not (Length_Utf8 (Z) > 4) then
               Result := False;
               return;
            end if;
            --  <-, line 392
            Slice_From (Z, "ت");
         when 3 =>
            --  (, line 393
            if not (Length_Utf8 (Z) > 4) then
               Result := False;
               return;
            end if;
            --  <-, line 393
            Slice_From (Z, "ن");
         when 4 =>
            --  (, line 394
            if not (Length_Utf8 (Z) > 4) then
               Result := False;
               return;
            end if;
            --  <-, line 394
            Slice_From (Z, "أ");
         when others =>
            null;
      end case;

      Result := True;
   end R_Prefix_Step3_Verb;

   procedure R_Prefix_Step4_Verb (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 398
      Z.Bra := Z.C;      --  [, line 399

      --  substring, line 399
      if Z.C + 5 >= Z.L or else Character'Pos (Z.P (Z.C + 5 + 1)) /= 170 then
         Result := False;
         return;
         --  substring, line 399
      end if;
      Find_Among (Z, A_9, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Ket := Z.C;      --  ], line 399

      --  (, line 400
      if not (Length_Utf8 (Z) > 4) then
         Result := False;
         return;
      end if;
      --  set is_verb, line 400
      Z.B_Is_verb := True;
      --  unset is_noun, line 400
      Z.B_Is_noun := False;
      --  <-, line 400
      Slice_From (Z, "است");

      Result := True;
   end R_Prefix_Step4_Verb;

   procedure R_Suffix_Noun_Step1a (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 407
      Z.Ket := Z.C;      --  [, line 408

      --  substring, line 408
      Find_Among_Backward (Z, A_10, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 408

      --  among, line 408
      case A is
         when 1 =>
            --  (, line 409
            if not (Length_Utf8 (Z) >= 4) then
               Result := False;
               return;
            end if;
            --  delete, line 409
            Slice_Del (Z);
         when 2 =>
            --  (, line 410
            if not (Length_Utf8 (Z) >= 5) then
               Result := False;
               return;
            end if;
            --  delete, line 410
            Slice_Del (Z);
         when 3 =>
            --  (, line 411
            if not (Length_Utf8 (Z) >= 6) then
               Result := False;
               return;
            end if;
            --  delete, line 411
            Slice_Del (Z);
         when others =>
            null;
      end case;

      Result := True;
   end R_Suffix_Noun_Step1a;

   procedure R_Suffix_Noun_Step1b (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 414
      Z.Ket := Z.C;      --  [, line 415

      --  substring, line 415
      if Z.C - 1 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 134 then
         Result := False;
         return;
         --  substring, line 415
      end if;
      Find_Among_Backward (Z, A_11, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 415

      --  (, line 416
      if not (Length_Utf8 (Z) > 5) then
         Result := False;
         return;
      end if;
      --  delete, line 416
      Slice_Del (Z);

      Result := True;
   end R_Suffix_Noun_Step1b;

   procedure R_Suffix_Noun_Step2a (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 420
      Z.Ket := Z.C;      --  [, line 421

      --  substring, line 421
      Find_Among_Backward (Z, A_12, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 421

      --  (, line 422
      if not (Length_Utf8 (Z) > 4) then
         Result := False;
         return;
      end if;
      --  delete, line 422
      Slice_Del (Z);

      Result := True;
   end R_Suffix_Noun_Step2a;

   procedure R_Suffix_Noun_Step2b (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 426
      Z.Ket := Z.C;      --  [, line 427

      --  substring, line 427
      if Z.C - 3 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 170 then
         Result := False;
         return;
         --  substring, line 427
      end if;
      Find_Among_Backward (Z, A_13, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 427

      --  (, line 428
      if not (Length_Utf8 (Z) >= 5) then
         Result := False;
         return;
      end if;
      --  delete, line 428
      Slice_Del (Z);

      Result := True;
   end R_Suffix_Noun_Step2b;

   procedure R_Suffix_Noun_Step2c1 (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 432
      Z.Ket := Z.C;      --  [, line 433

      --  substring, line 433
      if Z.C - 1 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 170 then
         Result := False;
         return;
         --  substring, line 433
      end if;
      Find_Among_Backward (Z, A_14, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 433

      --  (, line 434
      if not (Length_Utf8 (Z) >= 4) then
         Result := False;
         return;
      end if;
      --  delete, line 434
      Slice_Del (Z);

      Result := True;
   end R_Suffix_Noun_Step2c1;

   procedure R_Suffix_Noun_Step2c2 (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 437
      Z.Ket := Z.C;      --  [, line 438

      --  substring, line 438
      if Z.C - 1 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 169 then
         Result := False;
         return;
         --  substring, line 438
      end if;
      Find_Among_Backward (Z, A_15, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 438

      --  (, line 439
      if not (Length_Utf8 (Z) >= 4) then
         Result := False;
         return;
      end if;
      --  delete, line 439
      Slice_Del (Z);

      Result := True;
   end R_Suffix_Noun_Step2c2;

   procedure R_Suffix_Noun_Step3 (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 442
      Z.Ket := Z.C;      --  [, line 443

      --  substring, line 443
      if Z.C - 1 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 138 then
         Result := False;
         return;
         --  substring, line 443
      end if;
      Find_Among_Backward (Z, A_16, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 443

      --  (, line 444
      if not (Length_Utf8 (Z) >= 3) then
         Result := False;
         return;
      end if;
      --  delete, line 444
      Slice_Del (Z);

      Result := True;
   end R_Suffix_Noun_Step3;

   procedure R_Suffix_Verb_Step1 (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 448
      Z.Ket := Z.C;      --  [, line 449

      --  substring, line 449
      Find_Among_Backward (Z, A_17, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 449

      --  among, line 449
      case A is
         when 1 =>
            --  (, line 450
            if not (Length_Utf8 (Z) >= 4) then
               Result := False;
               return;
            end if;
            --  delete, line 450
            Slice_Del (Z);
         when 2 =>
            --  (, line 451
            if not (Length_Utf8 (Z) >= 5) then
               Result := False;
               return;
            end if;
            --  delete, line 451
            Slice_Del (Z);
         when 3 =>
            --  (, line 452
            if not (Length_Utf8 (Z) >= 6) then
               Result := False;
               return;
            end if;
            --  delete, line 452
            Slice_Del (Z);
         when others =>
            null;
      end case;

      Result := True;
   end R_Suffix_Verb_Step1;

   procedure R_Suffix_Verb_Step2a (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 455
      Z.Ket := Z.C;      --  [, line 456

      --  substring, line 456
      Find_Among_Backward (Z, A_18, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 456

      --  among, line 456
      case A is
         when 1 =>
            --  (, line 457
            if not (Length_Utf8 (Z) >= 4) then
               Result := False;
               return;
            end if;
            --  delete, line 457
            Slice_Del (Z);
         when 2 =>
            --  (, line 459
            if not (Length_Utf8 (Z) >= 5) then
               Result := False;
               return;
            end if;
            --  delete, line 459
            Slice_Del (Z);
         when 3 =>
            --  (, line 460
            if not (Length_Utf8 (Z) > 5) then
               Result := False;
               return;
            end if;
            --  delete, line 460
            Slice_Del (Z);
         when 4 =>
            --  (, line 461
            if not (Length_Utf8 (Z) >= 6) then
               Result := False;
               return;
            end if;
            --  delete, line 461
            Slice_Del (Z);
         when others =>
            null;
      end case;

      Result := True;
   end R_Suffix_Verb_Step2a;

   procedure R_Suffix_Verb_Step2b (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 465
      Z.Ket := Z.C;      --  [, line 466

      --  substring, line 466
      if Z.C - 3 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 133 and then Character'Pos (Z.P (Z.C)) /= 167) then
         Result := False;
         return;
         --  substring, line 466
      end if;
      Find_Among_Backward (Z, A_19, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 466

      --  (, line 467
      if not (Length_Utf8 (Z) >= 5) then
         Result := False;
         return;
      end if;
      --  delete, line 467
      Slice_Del (Z);

      Result := True;
   end R_Suffix_Verb_Step2b;

   procedure R_Suffix_Verb_Step2c (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 472
      Z.Ket := Z.C;      --  [, line 473

      --  substring, line 473
      if Z.C - 1 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 136 then
         Result := False;
         return;
         --  substring, line 473
      end if;
      Find_Among_Backward (Z, A_20, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 473

      --  among, line 473
      case A is
         when 1 =>
            --  (, line 474
            if not (Length_Utf8 (Z) >= 4) then
               Result := False;
               return;
            end if;
            --  delete, line 474
            Slice_Del (Z);
         when 2 =>
            --  (, line 475
            if not (Length_Utf8 (Z) >= 6) then
               Result := False;
               return;
            end if;
            --  delete, line 475
            Slice_Del (Z);
         when others =>
            null;
      end case;

      Result := True;
   end R_Suffix_Verb_Step2c;

   procedure R_Suffix_All_alef_maqsura (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
   begin
      --  (, line 479
      Z.Ket := Z.C;      --  [, line 480

      --  substring, line 480
      if Z.C - 1 <= Z.Lb or else Character'Pos (Z.P (Z.C)) /= 137 then
         Result := False;
         return;
         --  substring, line 480
      end if;
      Find_Among_Backward (Z, A_21, Among_String, null, A);
      if A = 0 then
         Result := False;
         return;
      end if;
      Z.Bra := Z.C;      --  ], line 480

      --  (, line 481
      --  <-, line 481
      Slice_From (Z, "ي");

      Result := True;
   end R_Suffix_All_alef_maqsura;

   procedure Stem (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
      v_6 : Integer;
      v_7 : Char_Index;
      v_8 : Char_Index;
      v_9 : Char_Index;
      v_10 : Char_Index;
      v_12 : Char_Index;
      v_13 : Char_Index;
      v_15 : Char_Index;
      v_16 : Char_Index;
      v_17 : Char_Index;
      v_18 : Char_Index;
      v_19 : Char_Index;
   begin
      --  (, line 488
      --  set is_noun, line 490
      Z.B_Is_noun := True;
      --  set is_verb, line 491
      Z.B_Is_verb := True;
      --  unset is_defined, line 492
      Z.B_Is_defined := False;
      --  do, line 495
      v_1 := Z.C;
      --  call Checks1, line 495
      R_Checks1 (Z, Result);
      Z.C := v_1;
      --  do, line 498
      --  call Normalize_pre, line 498
      R_Normalize_pre (Z, Result);
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 501

      --  do, line 503
      v_3 := Z.L - Z.C;
      --  or, line 517
      v_4 := Z.L - Z.C;
      --  (, line 505
      --  Boolean test is_verb, line 506
      if not Z.B_Is_verb then
         goto lab2;
      end if;
      --  or, line 512
      v_5 := Z.L - Z.C;
      --  (, line 508
      --  atleast, line 509
      begin
         v_6 := 1;

         <<lab5>>

         loop
            v_7 := Z.L - Z.C;
            --  call Suffix_Verb_Step1, line 509
            R_Suffix_Verb_Step1 (Z, Result);
            if not Result then
               goto lab6;
            end if;
            v_6 := v_6 - 1;
            goto lab5;

            <<lab6>>
            Z.C := Z.L - v_7;

            exit;
         end loop;
         if v_6 > 0 then
            goto lab4;
         end if;
      end;
      --  or, line 510
      v_8 := Z.L - Z.C;
      --  call Suffix_Verb_Step2a, line 510
      R_Suffix_Verb_Step2a (Z, Result);
      if not Result then
         goto lab8;
      end if;
      goto lab7;

      <<lab8>>
      Z.C := Z.L - v_8;
      --  call Suffix_Verb_Step2c, line 510
      R_Suffix_Verb_Step2c (Z, Result);
      if not Result then
         goto lab9;
      end if;
      goto lab7;

      <<lab9>>
      Z.C := Z.L - v_8;
      --  next, line 510
      C := Skip_Utf8_Backward (Z);
      if C < 0 then
         goto lab4;
      end if;
      Z.C := C;

      <<lab7>>
      goto lab3;

      <<lab4>>
      Z.C := Z.L - v_5;
      --  call Suffix_Verb_Step2b, line 512
      R_Suffix_Verb_Step2b (Z, Result);
      if not Result then
         goto lab10;
      end if;
      goto lab3;

      <<lab10>>
      Z.C := Z.L - v_5;
      --  call Suffix_Verb_Step2a, line 513
      R_Suffix_Verb_Step2a (Z, Result);
      if not Result then
         goto lab2;
      end if;

      <<lab3>>
      goto lab1;

      <<lab2>>
      Z.C := Z.L - v_4;
      --  (, line 517
      --  Boolean test is_noun, line 518
      if not Z.B_Is_noun then
         goto lab11;
      end if;
      --  (, line 519
      --  try, line 521
      v_9 := Z.L - Z.C;
      --  or, line 523
      v_10 := Z.L - Z.C;
      --  call Suffix_Noun_Step2c2, line 522
      R_Suffix_Noun_Step2c2 (Z, Result);
      if not Result then
         goto lab14;
      end if;
      goto lab13;

      <<lab14>>
      Z.C := Z.L - v_10;
      --  (, line 523
      --  not, line 523
      --  Boolean test is_defined, line 523
      if not Z.B_Is_defined then
         goto lab16;
      end if;
      goto lab15;

      <<lab16>>
      --  call Suffix_Noun_Step1a, line 523
      R_Suffix_Noun_Step1a (Z, Result);
      if not Result then
         goto lab15;
      end if;
      --  or, line 525
      v_12 := Z.L - Z.C;
      --  call Suffix_Noun_Step2a, line 524
      R_Suffix_Noun_Step2a (Z, Result);
      if not Result then
         goto lab18;
      end if;
      goto lab17;

      <<lab18>>
      Z.C := Z.L - v_12;
      --  call Suffix_Noun_Step2b, line 525
      R_Suffix_Noun_Step2b (Z, Result);
      if not Result then
         goto lab19;
      end if;
      goto lab17;

      <<lab19>>
      Z.C := Z.L - v_12;
      --  call Suffix_Noun_Step2c1, line 526
      R_Suffix_Noun_Step2c1 (Z, Result);
      if not Result then
         goto lab20;
      end if;
      goto lab17;

      <<lab20>>
      Z.C := Z.L - v_12;
      --  next, line 527
      C := Skip_Utf8_Backward (Z);
      if C < 0 then
         goto lab15;
      end if;
      Z.C := C;

      <<lab17>>
      goto lab13;

      <<lab15>>
      Z.C := Z.L - v_10;
      --  (, line 528
      --  call Suffix_Noun_Step1b, line 528
      R_Suffix_Noun_Step1b (Z, Result);
      if not Result then
         goto lab21;
      end if;
      --  or, line 530
      v_13 := Z.L - Z.C;
      --  call Suffix_Noun_Step2a, line 529
      R_Suffix_Noun_Step2a (Z, Result);
      if not Result then
         goto lab23;
      end if;
      goto lab22;

      <<lab23>>
      Z.C := Z.L - v_13;
      --  call Suffix_Noun_Step2b, line 530
      R_Suffix_Noun_Step2b (Z, Result);
      if not Result then
         goto lab24;
      end if;
      goto lab22;

      <<lab24>>
      Z.C := Z.L - v_13;
      --  call Suffix_Noun_Step2c1, line 531
      R_Suffix_Noun_Step2c1 (Z, Result);
      if not Result then
         goto lab21;
      end if;

      <<lab22>>
      goto lab13;

      <<lab21>>
      Z.C := Z.L - v_10;
      --  (, line 532
      --  not, line 532
      --  Boolean test is_defined, line 532
      if not Z.B_Is_defined then
         goto lab26;
      end if;
      goto lab25;

      <<lab26>>
      --  call Suffix_Noun_Step2a, line 532
      R_Suffix_Noun_Step2a (Z, Result);
      if not Result then
         goto lab25;
      end if;
      goto lab13;

      <<lab25>>
      Z.C := Z.L - v_10;
      --  call Suffix_Noun_Step2b, line 533
      R_Suffix_Noun_Step2b (Z, Result);
      if not Result then
         Z.C := Z.L - v_9;
         goto lab12;
      end if;

      <<lab13>>

      <<lab12>>
      --  call Suffix_Noun_Step3, line 535
      R_Suffix_Noun_Step3 (Z, Result);
      if not Result then
         goto lab11;
      end if;
      goto lab1;

      <<lab11>>
      Z.C := Z.L - v_4;
      --  call Suffix_All_alef_maqsura, line 541
      R_Suffix_All_alef_maqsura (Z, Result);
      if not Result then
         goto lab0;
      end if;

      <<lab1>>

      <<lab0>>
      Z.C := Z.L - v_3;
      Z.C := Z.Lb;
      --  do, line 546
      v_15 := Z.C;
      --  (, line 546
      --  try, line 547
      v_16 := Z.C;
      --  call Prefix_Step1, line 547
      R_Prefix_Step1 (Z, Result);
      if not Result then
         Z.C := v_16;
         goto lab28;
      end if;

      <<lab28>>
      --  try, line 548
      v_17 := Z.C;
      --  call Prefix_Step2, line 548
      R_Prefix_Step2 (Z, Result);
      if not Result then
         Z.C := v_17;
         goto lab29;
      end if;

      <<lab29>>
      --  or, line 550
      v_18 := Z.C;
      --  call Prefix_Step3a_Noun, line 549
      R_Prefix_Step3a_Noun (Z, Result);
      if not Result then
         goto lab31;
      end if;
      goto lab30;

      <<lab31>>
      Z.C := v_18;
      --  (, line 550
      --  Boolean test is_noun, line 550
      if not Z.B_Is_noun then
         goto lab32;
      end if;
      --  call Prefix_Step3b_Noun, line 550
      R_Prefix_Step3b_Noun (Z, Result);
      if not Result then
         goto lab32;
      end if;
      goto lab30;

      <<lab32>>
      Z.C := v_18;
      --  (, line 551
      --  Boolean test is_verb, line 551
      if not Z.B_Is_verb then
         goto lab27;
      end if;
      --  try, line 551
      v_19 := Z.C;
      --  call Prefix_Step3_Verb, line 551
      R_Prefix_Step3_Verb (Z, Result);
      if not Result then
         Z.C := v_19;
         goto lab33;
      end if;

      <<lab33>>
      --  call Prefix_Step4_Verb, line 551
      R_Prefix_Step4_Verb (Z, Result);
      if not Result then
         goto lab27;
      end if;

      <<lab30>>

      <<lab27>>
      Z.C := v_15;
      --  do, line 556
      --  call Normalize_post, line 556
      R_Normalize_post (Z, Result);

      Result := True;
   end Stem;
end Stemmer.Arabic;
