--  Generated by Snowball 2.2.0 - https://snowballstem.org/

package body Stemmer.German is

   pragma Style_Checks ("-mr");
   pragma Warnings (Off, "*variable*is never read and never assigned*");
   pragma Warnings (Off, "*mode could be*instead of*");
   pragma Warnings (Off, "*formal parameter.*is not modified*");
   pragma Warnings (Off, "*this line is too long*");
   pragma Warnings (Off, "*is not referenced*");

   procedure R_Standard_suffix (Z : in out Context_Type; Result : out Boolean);
   procedure R_R2 (Z : in out Context_Type; Result : out Boolean);
   procedure R_R1 (Z : in out Context_Type; Result : out Boolean);
   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean);
   procedure R_Postlude (Z : in out Context_Type; Result : out Boolean);
   procedure R_Prelude (Z : in out Context_Type; Result : out Boolean);

   G_V : constant Grouping_Array (0 .. 159) := (
      True, False, False, False, True, False, False, False,
      True, False, False, False, False, False, True, False,
      False, False, False, False, True, False, False, False,
      True, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, True, False, False, False, False,
      False, False, False, False, False, False, False, False,
      False, False, False, False, False, True, False, False,
      False, False, False, True, False, False, False, False
   );

   G_S_ending : constant Grouping_Array (0 .. 23) := (
      True, False, True, False, True, True, True, False,
      False, True, True, True, True, False, False, False,
      True, False, True, False, False, False, False, False
   );

   G_St_ending : constant Grouping_Array (0 .. 23) := (
      True, False, True, False, True, True, True, False,
      False, True, True, True, True, False, False, False,
      False, False, True, False, False, False, False, False
   );
   Among_String : constant String := "" & "U" & "Y" & "ä" & "ö" & "ü" & "e" & "em" & "en" & "ern" & "er" & "s"
      & "es" & "en" & "er" & "st" & "est" & "ig" & "lich" & "end" & "ig" & "ung"
      & "lich" & "isch" & "ik" & "heit" & "keit";

   A_0 : constant Among_Array_Type (0 .. 5) := (
      (1, 0, -1, 5, 0),
      (1, 1, 0, 2, 0),
      (2, 2, 0, 1, 0),
      (3, 4, 0, 3, 0),
      (5, 6, 0, 4, 0),
      (7, 8, 0, 2, 0));

   A_1 : constant Among_Array_Type (0 .. 6) := (
      (9, 9, -1, 2, 0),
      (10, 11, -1, 1, 0),
      (12, 13, -1, 2, 0),
      (14, 16, -1, 1, 0),
      (17, 18, -1, 1, 0),
      (19, 19, -1, 3, 0),
      (20, 21, 5, 2, 0));

   A_2 : constant Among_Array_Type (0 .. 3) := (
      (22, 23, -1, 1, 0),
      (24, 25, -1, 1, 0),
      (26, 27, -1, 2, 0),
      (28, 30, 2, 1, 0));

   A_3 : constant Among_Array_Type (0 .. 1) := (
      (31, 32, -1, 1, 0),
      (33, 36, -1, 1, 0));

   A_4 : constant Among_Array_Type (0 .. 7) := (
      (37, 39, -1, 1, 0),
      (40, 41, -1, 2, 0),
      (42, 44, -1, 1, 0),
      (45, 48, -1, 3, 0),
      (49, 52, -1, 2, 0),
      (53, 54, -1, 2, 0),
      (55, 58, -1, 3, 0),
      (59, 62, -1, 4, 0));


   procedure R_Prelude (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
      v_6 : Char_Index;
   begin
      --  (, line 33
      --  test, line 35
      v_1 := Z.C;
      --  repeat, line 35

      <<lab0>>

      loop
         v_2 := Z.C;
         --  or, line 38
         v_3 := Z.C;
         --  (, line 36
         Z.Bra := Z.C;         --  [, line 37

         --  literal, line 37
         C := Eq_S (Z, "ß");
         if C = 0 then
            goto lab3;
         end if;
         Z.C := Z.C + C;
         Z.Ket := Z.C;         --  ], line 37

         --  <-, line 37
         Slice_From (Z, "ss");
         goto lab2;

         <<lab3>>
         Z.C := v_3;
         --  next, line 38
         C := Skip_Utf8 (Z);
         if C < 0 then
            goto lab1;
         end if;
         Z.C := C;

         <<lab2>>
         goto lab0;

         <<lab1>>
         Z.C := v_2;

         exit;
      end loop;
      Z.C := v_1;
      --  repeat, line 41

      <<lab4>>

      loop
         v_4 := Z.C;
         --  goto, line 41
         loop
            v_5 := Z.C;
            --  (, line 41
            In_Grouping (Z, G_V, 97, 252, False, C);
            if C /= 0 then
               goto lab7;
            end if;
            Z.Bra := Z.C;            --  [, line 42

            --  or, line 42
            v_6 := Z.C;
            --  (, line 42
            --  literal, line 42
            C := Eq_S (Z, "u");
            if C = 0 then
               goto lab9;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 42

            In_Grouping (Z, G_V, 97, 252, False, C);
            if C /= 0 then
               goto lab9;
            end if;
            --  <-, line 42
            Slice_From (Z, "U");
            goto lab8;

            <<lab9>>
            Z.C := v_6;
            --  (, line 43
            --  literal, line 43
            C := Eq_S (Z, "y");
            if C = 0 then
               goto lab7;
            end if;
            Z.C := Z.C + C;
            Z.Ket := Z.C;            --  ], line 43

            In_Grouping (Z, G_V, 97, 252, False, C);
            if C /= 0 then
               goto lab7;
            end if;
            --  <-, line 43
            Slice_From (Z, "Y");

            <<lab8>>
            Z.C := v_5;
            exit;

            <<lab7>>
            Z.C := v_5;
            if Z.C >= Z.L then
               goto lab5;
            end if;
            --  goto, line 41
            C := Skip_Utf8 (Z);
            if C < 0 then
               goto lab5;
            end if;
            Z.C := C;
         end loop;
         goto lab4;

         <<lab5>>
         Z.C := v_4;

         exit;
      end loop;

      Result := True;
   end R_Prelude;

   procedure R_Mark_regions (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
   begin
      --  (, line 47
      Z.I_P1 := Z.L;
      Z.I_P2 := Z.L;
      --  test, line 52
      v_1 := Z.C;
      --  (, line 52
      C := Skip_Utf8 (Z, 3);      --  hop, line 52

      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := C;
      --  setmark x, line 52
      Z.I_X := Z.C;
      Z.C := v_1;
            --  gopast, line 54
      --  grouping v, line 54
      Out_Grouping (Z, G_V, 97, 252, True, C);
      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C + C;
            --  gopast, line 54
      --  non v, line 54
      In_Grouping (Z, G_V, 97, 252, True, C);
      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C + C;
      --  setmark p1, line 54
      Z.I_P1 := Z.C;
      --  try, line 55
      --  (, line 55
      if not (Z.I_P1 < Z.I_X) then
         goto lab2;
      end if;
      Z.I_P1 := Z.I_X;

      <<lab2>>
            --  gopast, line 56
      --  grouping v, line 56
      Out_Grouping (Z, G_V, 97, 252, True, C);
      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C + C;
            --  gopast, line 56
      --  non v, line 56
      In_Grouping (Z, G_V, 97, 252, True, C);
      if C < 0 then
         Result := False;
         return;
      end if;
      Z.C := Z.C + C;
      --  setmark p2, line 56
      Z.I_P2 := Z.C;

      Result := True;
   end R_Mark_regions;

   procedure R_Postlude (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
   begin
      --  repeat, line 60

      <<lab0>>

      loop
         v_1 := Z.C;
         --  (, line 60
         Z.Bra := Z.C;         --  [, line 62

         --  substring, line 62
         Find_Among (Z, A_0, Among_String, null, A);
         if A = 0 then
            goto lab1;
         end if;
         Z.Ket := Z.C;         --  ], line 62

         --  among, line 62
         case A is
            when 1 =>
               --  (, line 63
               --  <-, line 63
               Slice_From (Z, "y");
            when 2 =>
               --  (, line 64
               --  <-, line 64
               Slice_From (Z, "u");
            when 3 =>
               --  (, line 65
               --  <-, line 65
               Slice_From (Z, "a");
            when 4 =>
               --  (, line 66
               --  <-, line 66
               Slice_From (Z, "o");
            when 5 =>
               --  (, line 68
               --  next, line 68
               C := Skip_Utf8 (Z);
               if C < 0 then
                  goto lab1;
               end if;
               Z.C := C;
            when others =>
               null;
         end case;
         goto lab0;

         <<lab1>>
         Z.C := v_1;

         exit;
      end loop;

      Result := True;
   end R_Postlude;

   procedure R_R1 (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_P1 <= Z.C);
   end R_R1;

   procedure R_R2 (Z : in out Context_Type; Result : out Boolean) is
   begin
      Result := (Z.I_P2 <= Z.C);
   end R_R2;

   procedure R_Standard_suffix (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_3 : Char_Index;
      v_4 : Char_Index;
      v_5 : Char_Index;
      v_6 : Char_Index;
      v_7 : Char_Index;
      v_8 : Char_Index;
      v_9 : Char_Index;
      v_10 : Char_Index;
   begin
      --  (, line 78
      --  do, line 79
      v_1 := Z.L - Z.C;
      --  (, line 79
      Z.Ket := Z.C;      --  [, line 80

      --  substring, line 80
      if Z.C <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#c6020#) then
         goto lab0;
         --  substring, line 80
      end if;
      Find_Among_Backward (Z, A_1, Among_String, null, A);
      if A = 0 then
         goto lab0;
      end if;
      Z.Bra := Z.C;      --  ], line 80

      --  call R1, line 80
      R_R1 (Z, Result);
      if not Result then
         goto lab0;
      end if;
      --  among, line 80
      case A is
         when 1 =>
            --  (, line 82
            --  delete, line 82
            Slice_Del (Z);
         when 2 =>
            --  (, line 85
            --  delete, line 85
            Slice_Del (Z);
            --  try, line 86
            v_2 := Z.L - Z.C;
            --  (, line 86
            Z.Ket := Z.C;            --  [, line 86

            --  literal, line 86
            C := Eq_S_Backward (Z, "s");
            if C = 0 then
               Z.C := Z.L - v_2;
               goto lab1;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 86

            --  literal, line 86
            C := Eq_S_Backward (Z, "nis");
            if C = 0 then
               Z.C := Z.L - v_2;
               goto lab1;
            end if;
            Z.C := Z.C - C;
            --  delete, line 86
            Slice_Del (Z);

            <<lab1>>
         when 3 =>
            --  (, line 89
            In_Grouping_Backward (Z, G_S_ending, 98, 116, False, C);
            if C /= 0 then
               goto lab0;
            end if;
            --  delete, line 89
            Slice_Del (Z);
         when others =>
            null;
      end case;

      <<lab0>>
      Z.C := Z.L - v_1;
      --  do, line 93
      v_3 := Z.L - Z.C;
      --  (, line 93
      Z.Ket := Z.C;      --  [, line 94

      --  substring, line 94
      if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#144000#) then
         goto lab2;
         --  substring, line 94
      end if;
      Find_Among_Backward (Z, A_2, Among_String, null, A);
      if A = 0 then
         goto lab2;
      end if;
      Z.Bra := Z.C;      --  ], line 94

      --  call R1, line 94
      R_R1 (Z, Result);
      if not Result then
         goto lab2;
      end if;
      --  among, line 94
      case A is
         when 1 =>
            --  (, line 96
            --  delete, line 96
            Slice_Del (Z);
         when 2 =>
            --  (, line 99
            In_Grouping_Backward (Z, G_St_ending, 98, 116, False, C);
            if C /= 0 then
               goto lab2;
            end if;
            C := Skip_Utf8_Backward (Z, 3);            --  hop, line 99

            if C < 0 then
               goto lab2;
            end if;
            Z.C := C;
            --  delete, line 99
            Slice_Del (Z);
         when others =>
            null;
      end case;

      <<lab2>>
      Z.C := Z.L - v_3;
      --  do, line 103
      v_4 := Z.L - Z.C;
      --  (, line 103
      Z.Ket := Z.C;      --  [, line 104

      --  substring, line 104
      if Z.C - 1 <= Z.Lb or else Check_Among (Z, Z.C - 1, 3, 16#100990#) then
         goto lab3;
         --  substring, line 104
      end if;
      Find_Among_Backward (Z, A_4, Among_String, null, A);
      if A = 0 then
         goto lab3;
      end if;
      Z.Bra := Z.C;      --  ], line 104

      --  call R2, line 104
      R_R2 (Z, Result);
      if not Result then
         goto lab3;
      end if;
      --  among, line 104
      case A is
         when 1 =>
            --  (, line 106
            --  delete, line 106
            Slice_Del (Z);
            --  try, line 107
            v_5 := Z.L - Z.C;
            --  (, line 107
            Z.Ket := Z.C;            --  [, line 107

            --  literal, line 107
            C := Eq_S_Backward (Z, "ig");
            if C = 0 then
               Z.C := Z.L - v_5;
               goto lab4;
            end if;
            Z.C := Z.C - C;
            Z.Bra := Z.C;            --  ], line 107

            --  not, line 107
            v_6 := Z.L - Z.C;
            --  literal, line 107
            C := Eq_S_Backward (Z, "e");
            if C = 0 then
               goto lab5;
            end if;
            Z.C := Z.C - C;
            Z.C := Z.L - v_5;
            goto lab4;

            <<lab5>>
            Z.C := Z.L - v_6;
            --  call R2, line 107
            R_R2 (Z, Result);
            if not Result then
               Z.C := Z.L - v_5;
               goto lab4;
            end if;
            --  delete, line 107
            Slice_Del (Z);

            <<lab4>>
         when 2 =>
            --  (, line 110
            --  not, line 110
            v_7 := Z.L - Z.C;
            --  literal, line 110
            C := Eq_S_Backward (Z, "e");
            if C = 0 then
               goto lab6;
            end if;
            Z.C := Z.C - C;
            goto lab3;

            <<lab6>>
            Z.C := Z.L - v_7;
            --  delete, line 110
            Slice_Del (Z);
         when 3 =>
            --  (, line 113
            --  delete, line 113
            Slice_Del (Z);
            --  try, line 114
            v_8 := Z.L - Z.C;
            --  (, line 114
            Z.Ket := Z.C;            --  [, line 115

            --  or, line 115
            v_9 := Z.L - Z.C;
            --  literal, line 115
            C := Eq_S_Backward (Z, "er");
            if C = 0 then
               goto lab9;
            end if;
            Z.C := Z.C - C;
            goto lab8;

            <<lab9>>
            Z.C := Z.L - v_9;
            --  literal, line 115
            C := Eq_S_Backward (Z, "en");
            if C = 0 then
               Z.C := Z.L - v_8;
               goto lab7;
            end if;
            Z.C := Z.C - C;

            <<lab8>>
            Z.Bra := Z.C;            --  ], line 115

            --  call R1, line 115
            R_R1 (Z, Result);
            if not Result then
               Z.C := Z.L - v_8;
               goto lab7;
            end if;
            --  delete, line 115
            Slice_Del (Z);

            <<lab7>>
         when 4 =>
            --  (, line 119
            --  delete, line 119
            Slice_Del (Z);
            --  try, line 120
            v_10 := Z.L - Z.C;
            --  (, line 120
            Z.Ket := Z.C;            --  [, line 121

            --  substring, line 121
            if Z.C - 1 <= Z.Lb or else (Character'Pos (Z.P (Z.C)) /= 103 and then Character'Pos (Z.P (Z.C)) /= 104) then
               Z.C := Z.L - v_10;
               goto lab10;
               --  substring, line 121
            end if;
            Find_Among_Backward (Z, A_3, Among_String, null, A);
            if A = 0 then
               Z.C := Z.L - v_10;
               goto lab10;
            end if;
            Z.Bra := Z.C;            --  ], line 121

            --  call R2, line 121
            R_R2 (Z, Result);
            if not Result then
               Z.C := Z.L - v_10;
               goto lab10;
            end if;
            --  (, line 123
            --  delete, line 123
            Slice_Del (Z);

            <<lab10>>
         when others =>
            null;
      end case;

      <<lab3>>
      Z.C := Z.L - v_4;

      Result := True;
   end R_Standard_suffix;

   procedure Stem (Z : in out Context_Type; Result : out Boolean) is
      C : Result_Index;
      A : Integer;
      v_1 : Char_Index;
      v_2 : Char_Index;
      v_4 : Char_Index;
   begin
      --  (, line 133
      --  do, line 134
      v_1 := Z.C;
      --  call prelude, line 134
      R_Prelude (Z, Result);
      Z.C := v_1;
      --  do, line 135
      v_2 := Z.C;
      --  call mark_regions, line 135
      R_Mark_regions (Z, Result);
      Z.C := v_2;
      Z.Lb := Z.C; Z.C := Z.L;      --  backwards, line 136

      --  do, line 137
      --  call standard_suffix, line 137
      R_Standard_suffix (Z, Result);
      Z.C := Z.Lb;
      --  do, line 138
      v_4 := Z.C;
      --  call postlude, line 138
      R_Postlude (Z, Result);
      Z.C := v_4;

      Result := True;
   end Stem;
end Stemmer.German;
